var box2d=window.box2d=function(t){"use strict";class e{constructor(t=.5,e=.5,s=.5,i=1){this.r=t,this.g=e,this.b=s,this.a=i}Clone(){return(new e).Copy(this)}Copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}Set(t,e,s,i=this.a){this.SetRGBA(t,e,s,i)}SetByteRGB(t,e,s){return this.r=t/255,this.g=e/255,this.b=s/255,this}SetByteRGBA(t,e,s,i){return this.r=t/255,this.g=e/255,this.b=s/255,this.a=i/255,this}SetRGB(t,e,s){return this.r=t,this.g=e,this.b=s,this}SetRGBA(t,e,s,i){return this.r=t,this.g=e,this.b=s,this.a=i,this}SelfAdd(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Add(t,e){return e.r=this.r+t.r,e.g=this.g+t.g,e.b=this.b+t.b,e.a=this.a+t.a,e}SelfSub(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Sub(t,e){return e.r=this.r-t.r,e.g=this.g-t.g,e.b=this.b-t.b,e.a=this.a-t.a,e}SelfMul(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mul(t,e){return e.r=this.r*t,e.g=this.g*t,e.b=this.b*t,e.a=this.a*t,e}Mix(t,s){e.MixColors(this,t,s)}static MixColors(t,e,s){const i=s*(e.r-t.r),n=s*(e.g-t.g),o=s*(e.b-t.b),r=s*(e.a-t.a);t.r+=i,t.g+=n,t.b+=o,t.a+=r,e.r-=i,e.g-=n,e.b-=o,e.a-=r}MakeStyleString(t=this.a){return e.MakeStyleString(this.r,this.g,this.b,t)}static MakeStyleString(t,e,s,i=1){return t*=255,e*=255,s*=255,i<1?`rgba(${t},${e},${s},${i})`:`rgb(${t},${e},${s})`}}var s;e.ZERO=new e(0,0,0,0),e.RED=new e(1,0,0),e.GREEN=new e(0,1,0),e.BLUE=new e(0,0,1),t.b2DrawFlags=void 0,(s=t.b2DrawFlags||(t.b2DrawFlags={}))[s.e_none=0]="e_none",s[s.e_shapeBit=1]="e_shapeBit",s[s.e_jointBit=2]="e_jointBit",s[s.e_aabbBit=4]="e_aabbBit",s[s.e_pairBit=8]="e_pairBit",s[s.e_centerOfMassBit=16]="e_centerOfMassBit",s[s.e_all=63]="e_all";function b2Maybe(t,e){return void 0!==t?t:e}const i=1e37,n=3.14159265359;class o{constructor(t=0,e=0,s=0){this.major=0,this.minor=0,this.revision=0,this.major=t,this.minor=e,this.revision=s}toString(){return this.major+"."+this.minor+"."+this.revision}}const r=new o(2,4,1);function b2MakeArray(t,e){const s=new Array(t);for(let i=0;i<t;++i)s[i]=e(i);return s}function b2MakeNumberArray(t,e=0){const s=new Array(t);for(let i=0;i<t;++i)s[i]=e;return s}class _{constructor(t){this.m_stack=[],this.m_count=0,this.m_stack=b2MakeArray(t,t=>null),this.m_count=0}Reset(){return this.m_count=0,this}Push(t){this.m_stack[this.m_count]=t,this.m_count++}Pop(){this.m_count--;const t=this.m_stack[this.m_count];return this.m_stack[this.m_count]=null,t}GetCount(){return this.m_count}}const h=Math.abs;function b2Min(t,e){return t<e?t:e}function b2Max(t,e){return t>e?t:e}function b2Clamp(t,e,s){return t<e?e:t>s?s:t}const m=isFinite;function b2Sq(t){return t*t}const a=Math.sqrt,l=Math.pow;const c=Math.cos,u=Math.sin,d=Math.acos,p=Math.asin,y=Math.atan2;class b{constructor(t=0,e=0){this.x=t,this.y=e}Clone(){return new b(this.x,this.y)}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return this.x=t.x,this.y=t.y,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this}SelfAddXY(t,e){return this.x+=t,this.y+=e,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this}SelfSubXY(t,e){return this.x-=t,this.y-=e,this}SelfMul(t){return this.x*=t,this.y*=t,this}SelfMulAdd(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SelfMulSub(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}LengthSquared(){const t=this.x,e=this.y;return t*t+e*e}Normalize(){const t=this.Length();if(t>=1e-5){const e=1/t;this.x*=e,this.y*=e}return t}SelfNormalize(){const t=this.Length();if(t>=1e-5){const e=1/t;this.x*=e,this.y*=e}return this}SelfRotate(t){const e=Math.cos(t),s=Math.sin(t),i=this.x;return this.x=e*i-s*this.y,this.y=s*i+e*this.y,this}SelfRotateCosSin(t,e){const s=this.x;return this.x=t*s-e*this.y,this.y=e*s+t*this.y,this}IsValid(){return isFinite(this.x)&&isFinite(this.y)}SelfCrossVS(t){const e=this.x;return this.x=t*this.y,this.y=-t*e,this}SelfCrossSV(t){const e=this.x;return this.x=-t*this.y,this.y=t*e,this}SelfMinV(t){return this.x=b2Min(this.x,t.x),this.y=b2Min(this.y,t.y),this}SelfMaxV(t){return this.x=b2Max(this.x,t.x),this.y=b2Max(this.y,t.y),this}SelfAbs(){return this.x=h(this.x),this.y=h(this.y),this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this}SelfSkew(){const t=this.x;return this.x=-this.y,this.y=t,this}static MakeArray(t){return b2MakeArray(t,t=>new b)}static AbsV(t,e){return e.x=h(t.x),e.y=h(t.y),e}static MinV(t,e,s){return s.x=b2Min(t.x,e.x),s.y=b2Min(t.y,e.y),s}static MaxV(t,e,s){return s.x=b2Max(t.x,e.x),s.y=b2Max(t.y,e.y),s}static ClampV(t,e,s,i){return i.x=b2Clamp(t.x,e.x,s.x),i.y=b2Clamp(t.y,e.y,s.y),i}static RotateV(t,e,s){const i=t.x,n=t.y,o=Math.cos(e),r=Math.sin(e);return s.x=o*i-r*n,s.y=r*i+o*n,s}static DotVV(t,e){return t.x*e.x+t.y*e.y}static CrossVV(t,e){return t.x*e.y-t.y*e.x}static CrossVS(t,e,s){const i=t.x;return s.x=e*t.y,s.y=-e*i,s}static CrossVOne(t,e){const s=t.x;return e.x=t.y,e.y=-s,e}static CrossSV(t,e,s){const i=e.x;return s.x=-t*e.y,s.y=t*i,s}static CrossOneV(t,e){const s=t.x;return e.x=-t.y,e.y=s,e}static AddVV(t,e,s){return s.x=t.x+e.x,s.y=t.y+e.y,s}static SubVV(t,e,s){return s.x=t.x-e.x,s.y=t.y-e.y,s}static MulSV(t,e,s){return s.x=e.x*t,s.y=e.y*t,s}static MulVS(t,e,s){return s.x=t.x*e,s.y=t.y*e,s}static AddVMulSV(t,e,s,i){return i.x=t.x+e*s.x,i.y=t.y+e*s.y,i}static SubVMulSV(t,e,s,i){return i.x=t.x-e*s.x,i.y=t.y-e*s.y,i}static AddVCrossSV(t,e,s,i){const n=s.x;return i.x=t.x-e*s.y,i.y=t.y+e*n,i}static MidVV(t,e,s){return s.x=.5*(t.x+e.x),s.y=.5*(t.y+e.y),s}static ExtVV(t,e,s){return s.x=.5*(e.x-t.x),s.y=.5*(e.y-t.y),s}static IsEqualToV(t,e){return t.x===e.x&&t.y===e.y}static DistanceVV(t,e){const s=t.x-e.x,i=t.y-e.y;return Math.sqrt(s*s+i*i)}static DistanceSquaredVV(t,e){const s=t.x-e.x,i=t.y-e.y;return s*s+i*i}static NegV(t,e){return e.x=-t.x,e.y=-t.y,e}}b.ZERO=new b(0,0),b.UNITX=new b(1,0),b.UNITY=new b(0,1),b.s_t0=new b,b.s_t1=new b,b.s_t2=new b,b.s_t3=new b;const x=new b(0,0);class A{constructor(...t){if(t[0]instanceof Float32Array){if(3!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:0,s="number"==typeof t[1]?t[1]:0,i="number"==typeof t[2]?t[2]:0;this.data=new Float32Array([e,s,i])}}get x(){return this.data[0]}set x(t){this.data[0]=t}get y(){return this.data[1]}set y(t){this.data[1]=t}get z(){return this.data[2]}set z(t){this.data[2]=t}Clone(){return new A(this.x,this.y,this.z)}SetZero(){return this.x=0,this.y=0,this.z=0,this}SetXYZ(t,e,s){return this.x=t,this.y=e,this.z=s,this}Copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}SelfAddXYZ(t,e,s){return this.x+=t,this.y+=e,this.z+=s,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}SelfSubXYZ(t,e,s){return this.x-=t,this.y-=e,this.z-=s,this}SelfMul(t){return this.x*=t,this.y*=t,this.z*=t,this}static DotV3V3(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static CrossV3V3(t,e,s){const i=t.x,n=t.y,o=t.z,r=e.x,_=e.y,h=e.z;return s.x=n*h-o*_,s.y=o*r-i*h,s.z=i*_-n*r,s}}A.ZERO=new A(0,0,0),A.s_t0=new A;class S{constructor(){this.ex=new b(1,0),this.ey=new b(0,1)}Clone(){return(new S).Copy(this)}static FromVV(t,e){return(new S).SetVV(t,e)}static FromSSSS(t,e,s,i){return(new S).SetSSSS(t,e,s,i)}static FromAngle(t){return(new S).SetAngle(t)}SetSSSS(t,e,s,i){return this.ex.Set(t,s),this.ey.Set(e,i),this}SetVV(t,e){return this.ex.Copy(t),this.ey.Copy(e),this}SetAngle(t){const e=Math.cos(t),s=Math.sin(t);return this.ex.Set(e,s),this.ey.Set(-s,e),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this}SetIdentity(){return this.ex.Set(1,0),this.ey.Set(0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this}GetAngle(){return Math.atan2(this.ex.y,this.ex.x)}GetInverse(t){const e=this.ex.x,s=this.ey.x,i=this.ex.y,n=this.ey.y;let o=e*n-s*i;return 0!==o&&(o=1/o),t.ex.x=o*n,t.ey.x=-o*s,t.ex.y=-o*i,t.ey.y=o*e,t}Solve(t,e,s){const i=this.ex.x,n=this.ey.x,o=this.ex.y,r=this.ey.y;let _=i*r-n*o;return 0!==_&&(_=1/_),s.x=_*(r*t-n*e),s.y=_*(i*e-o*t),s}SelfAbs(){return this.ex.SelfAbs(),this.ey.SelfAbs(),this}SelfInv(){return this.GetInverse(this),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this}SelfSubM(t){return this.ex.SelfSub(t.ex),this.ey.SelfSub(t.ey),this}static AbsM(t,e){const s=t.ex,i=t.ey;return e.ex.x=h(s.x),e.ex.y=h(s.y),e.ey.x=h(i.x),e.ey.y=h(i.y),e}static MulMV(t,e,s){const i=t.ex,n=t.ey,o=e.x,r=e.y;return s.x=i.x*o+n.x*r,s.y=i.y*o+n.y*r,s}static MulTMV(t,e,s){const i=t.ex,n=t.ey,o=e.x,r=e.y;return s.x=i.x*o+i.y*r,s.y=n.x*o+n.y*r,s}static AddMM(t,e,s){const i=t.ex,n=t.ey,o=e.ex,r=e.ey;return s.ex.x=i.x+o.x,s.ex.y=i.y+o.y,s.ey.x=n.x+r.x,s.ey.y=n.y+r.y,s}static MulMM(t,e,s){const i=t.ex.x,n=t.ex.y,o=t.ey.x,r=t.ey.y,_=e.ex.x,h=e.ex.y,m=e.ey.x,a=e.ey.y;return s.ex.x=i*_+o*h,s.ex.y=n*_+r*h,s.ey.x=i*m+o*a,s.ey.y=n*m+r*a,s}static MulTMM(t,e,s){const i=t.ex.x,n=t.ex.y,o=t.ey.x,r=t.ey.y,_=e.ex.x,h=e.ex.y,m=e.ey.x,a=e.ey.y;return s.ex.x=i*_+n*h,s.ex.y=o*_+r*h,s.ey.x=i*m+n*a,s.ey.y=o*m+r*a,s}}S.IDENTITY=new S;class V{constructor(){this.data=new Float32Array([1,0,0,0,1,0,0,0,1]),this.ex=new A(this.data.subarray(0,3)),this.ey=new A(this.data.subarray(3,6)),this.ez=new A(this.data.subarray(6,9))}Clone(){return(new V).Copy(this)}SetVVV(t,e,s){return this.ex.Copy(t),this.ey.Copy(e),this.ez.Copy(s),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this.ez.Copy(t.ez),this}SetIdentity(){return this.ex.SetXYZ(1,0,0),this.ey.SetXYZ(0,1,0),this.ez.SetXYZ(0,0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this.ez.SetZero(),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this.ez.SelfAdd(t.ez),this}Solve33(t,e,s,i){const n=this.ex.x,o=this.ex.y,r=this.ex.z,_=this.ey.x,h=this.ey.y,m=this.ey.z,a=this.ez.x,l=this.ez.y,c=this.ez.z;let u=n*(h*c-m*l)+o*(m*a-_*c)+r*(_*l-h*a);return 0!==u&&(u=1/u),i.x=u*(t*(h*c-m*l)+e*(m*a-_*c)+s*(_*l-h*a)),i.y=u*(n*(e*c-s*l)+o*(s*a-t*c)+r*(t*l-e*a)),i.z=u*(n*(h*s-m*e)+o*(m*t-_*s)+r*(_*e-h*t)),i}Solve22(t,e,s){const i=this.ex.x,n=this.ey.x,o=this.ex.y,r=this.ey.y;let _=i*r-n*o;return 0!==_&&(_=1/_),s.x=_*(r*t-n*e),s.y=_*(i*e-o*t),s}GetInverse22(t){const e=this.ex.x,s=this.ey.x,i=this.ex.y,n=this.ey.y;let o=e*n-s*i;0!==o&&(o=1/o),t.ex.x=o*n,t.ey.x=-o*s,t.ex.z=0,t.ex.y=-o*i,t.ey.y=o*e,t.ey.z=0,t.ez.x=0,t.ez.y=0,t.ez.z=0}GetSymInverse33(t){let e=A.DotV3V3(this.ex,A.CrossV3V3(this.ey,this.ez,A.s_t0));0!==e&&(e=1/e);const s=this.ex.x,i=this.ey.x,n=this.ez.x,o=this.ey.y,r=this.ez.y,_=this.ez.z;t.ex.x=e*(o*_-r*r),t.ex.y=e*(n*r-i*_),t.ex.z=e*(i*r-n*o),t.ey.x=t.ex.y,t.ey.y=e*(s*_-n*n),t.ey.z=e*(n*i-s*r),t.ez.x=t.ex.z,t.ez.y=t.ey.z,t.ez.z=e*(s*o-i*i)}static MulM33V3(t,e,s){const i=e.x,n=e.y,o=e.z;return s.x=t.ex.x*i+t.ey.x*n+t.ez.x*o,s.y=t.ex.y*i+t.ey.y*n+t.ez.y*o,s.z=t.ex.z*i+t.ey.z*n+t.ez.z*o,s}static MulM33XYZ(t,e,s,i,n){return n.x=t.ex.x*e+t.ey.x*s+t.ez.x*i,n.y=t.ex.y*e+t.ey.y*s+t.ez.y*i,n.z=t.ex.z*e+t.ey.z*s+t.ez.z*i,n}static MulM33V2(t,e,s){const i=e.x,n=e.y;return s.x=t.ex.x*i+t.ey.x*n,s.y=t.ex.y*i+t.ey.y*n,s}static MulM33XY(t,e,s,i){return i.x=t.ex.x*e+t.ey.x*s,i.y=t.ex.y*e+t.ey.y*s,i}}V.IDENTITY=new V;class f{constructor(t=0){this.s=0,this.c=1,t&&(this.s=Math.sin(t),this.c=Math.cos(t))}Clone(){return(new f).Copy(this)}Copy(t){return this.s=t.s,this.c=t.c,this}SetAngle(t){return this.s=Math.sin(t),this.c=Math.cos(t),this}SetIdentity(){return this.s=0,this.c=1,this}GetAngle(){return Math.atan2(this.s,this.c)}GetXAxis(t){return t.x=this.c,t.y=this.s,t}GetYAxis(t){return t.x=-this.s,t.y=this.c,t}static MulRR(t,e,s){const i=t.c,n=t.s,o=e.c,r=e.s;return s.s=n*o+i*r,s.c=i*o-n*r,s}static MulTRR(t,e,s){const i=t.c,n=t.s,o=e.c,r=e.s;return s.s=i*r-n*o,s.c=i*o+n*r,s}static MulRV(t,e,s){const i=t.c,n=t.s,o=e.x,r=e.y;return s.x=i*o-n*r,s.y=n*o+i*r,s}static MulTRV(t,e,s){const i=t.c,n=t.s,o=e.x,r=e.y;return s.x=i*o+n*r,s.y=-n*o+i*r,s}}f.IDENTITY=new f;class C{constructor(){this.p=new b,this.q=new f}Clone(){return(new C).Copy(this)}Copy(t){return this.p.Copy(t.p),this.q.Copy(t.q),this}SetIdentity(){return this.p.SetZero(),this.q.SetIdentity(),this}SetPositionRotation(t,e){return this.p.Copy(t),this.q.Copy(e),this}SetPositionAngle(t,e){return this.p.Copy(t),this.q.SetAngle(e),this}SetPosition(t){return this.p.Copy(t),this}SetPositionXY(t,e){return this.p.Set(t,e),this}SetRotation(t){return this.q.Copy(t),this}SetRotationAngle(t){return this.q.SetAngle(t),this}GetPosition(){return this.p}GetRotation(){return this.q}GetRotationAngle(){return this.q.GetAngle()}GetAngle(){return this.q.GetAngle()}static MulXV(t,e,s){const i=t.q.c,n=t.q.s,o=e.x,r=e.y;return s.x=i*o-n*r+t.p.x,s.y=n*o+i*r+t.p.y,s}static MulTXV(t,e,s){const i=t.q.c,n=t.q.s,o=e.x-t.p.x,r=e.y-t.p.y;return s.x=i*o+n*r,s.y=-n*o+i*r,s}static MulXX(t,e,s){return f.MulRR(t.q,e.q,s.q),b.AddVV(f.MulRV(t.q,e.p,s.p),t.p,s.p),s}static MulTXX(t,e,s){return f.MulTRR(t.q,e.q,s.q),f.MulTRV(t.q,b.SubVV(e.p,t.p,s.p),s.p),s}}C.IDENTITY=new C;class w{constructor(){this.localCenter=new b,this.c0=new b,this.c=new b,this.a0=0,this.a=0,this.alpha0=0}Clone(){return(new w).Copy(this)}Copy(t){return this.localCenter.Copy(t.localCenter),this.c0.Copy(t.c0),this.c.Copy(t.c),this.a0=t.a0,this.a=t.a,this.alpha0=t.alpha0,this}GetTransform(t,e){t.p.x=(1-e)*this.c0.x+e*this.c.x,t.p.y=(1-e)*this.c0.y+e*this.c.y;const s=(1-e)*this.a0+e*this.a;return t.q.SetAngle(s),t.p.SelfSub(f.MulRV(t.q,this.localCenter,b.s_t0)),t}Advance(t){const e=(t-this.alpha0)/(1-this.alpha0);this.c0.SelfMulAdd(e,this.c.Clone().SelfSub(this.c0)),this.a0+=e*(this.a-this.a0),this.alpha0=t}Normalize(){const t=6.28318530718*Math.floor(this.a0/6.28318530718);this.a0-=t,this.a-=t}}class B{constructor(){this.m_start=Date.now()}Reset(){return this.m_start=Date.now(),this}GetMilliseconds(){return Date.now()-this.m_start}}class v{constructor(){this.mass=0,this.center=new b(0,0),this.I=0}}var g;t.b2ShapeType=void 0,(g=t.b2ShapeType||(t.b2ShapeType={}))[g.e_unknown=-1]="e_unknown",g[g.e_circleShape=0]="e_circleShape",g[g.e_edgeShape=1]="e_edgeShape",g[g.e_polygonShape=2]="e_polygonShape",g[g.e_chainShape=3]="e_chainShape",g[g.e_shapeTypeCount=4]="e_shapeTypeCount";class M{constructor(e,s){this.m_type=t.b2ShapeType.e_unknown,this.m_radius=0,this.m_type=e,this.m_radius=s}Copy(t){return this.m_radius=t.m_radius,this}GetType(){return this.m_type}}class I{constructor(){this.m_buffer=b.MakeArray(2),this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0}Copy(t){return t.m_vertices===t.m_buffer?(this.m_vertices=this.m_buffer,this.m_buffer[0].Copy(t.m_buffer[0]),this.m_buffer[1].Copy(t.m_buffer[1])):this.m_vertices=t.m_vertices,this.m_count=t.m_count,this.m_radius=t.m_radius,this}Reset(){return this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0,this}SetShape(t,e){t.SetupDistanceProxy(this,e)}SetVerticesRadius(t,e,s){this.m_vertices=t,this.m_count=e,this.m_radius=s}Set(...t){t[0]instanceof M?this.SetShape(t[0],t[1]):this.SetVerticesRadius(t[0],t[1],t[2])}GetSupport(t){let e=0,s=b.DotVV(this.m_vertices[0],t);for(let i=1;i<this.m_count;++i){const n=b.DotVV(this.m_vertices[i],t);n>s&&(e=i,s=n)}return e}GetSupportVertex(t){let e=0,s=b.DotVV(this.m_vertices[0],t);for(let i=1;i<this.m_count;++i){const n=b.DotVV(this.m_vertices[i],t);n>s&&(e=i,s=n)}return this.m_vertices[e]}GetVertexCount(){return this.m_count}GetVertex(t){return this.m_vertices[t]}}class D{constructor(){this.metric=0,this.count=0,this.indexA=[0,0,0],this.indexB=[0,0,0]}Reset(){return this.metric=0,this.count=0,this}}class T{constructor(){this.proxyA=new I,this.proxyB=new I,this.transformA=new C,this.transformB=new C,this.useRadii=!1}Reset(){return this.proxyA.Reset(),this.proxyB.Reset(),this.transformA.SetIdentity(),this.transformB.SetIdentity(),this.useRadii=!1,this}}class G{constructor(){this.pointA=new b,this.pointB=new b,this.distance=0,this.iterations=0}Reset(){return this.pointA.SetZero(),this.pointB.SetZero(),this.distance=0,this.iterations=0,this}}t.b2_gjkCalls=0,t.b2_gjkIters=0,t.b2_gjkMaxIters=0;class P{constructor(){this.wA=new b,this.wB=new b,this.w=new b,this.a=0,this.indexA=0,this.indexB=0}Copy(t){return this.wA.Copy(t.wA),this.wB.Copy(t.wB),this.w.Copy(t.w),this.a=t.a,this.indexA=t.indexA,this.indexB=t.indexB,this}}class L{constructor(){this.m_v1=new P,this.m_v2=new P,this.m_v3=new P,this.m_vertices=[],this.m_count=0,this.m_vertices[0]=this.m_v1,this.m_vertices[1]=this.m_v2,this.m_vertices[2]=this.m_v3}ReadCache(t,e,s,i,n){this.m_count=t.count;const o=this.m_vertices;for(let r=0;r<this.m_count;++r){const _=o[r];_.indexA=t.indexA[r],_.indexB=t.indexB[r];const h=e.GetVertex(_.indexA),m=i.GetVertex(_.indexB);C.MulXV(s,h,_.wA),C.MulXV(n,m,_.wB),b.SubVV(_.wB,_.wA,_.w),_.a=0}if(this.m_count>1){const e=t.metric,s=this.GetMetric();(s<.5*e||2*e<s||s<1e-5)&&(this.m_count=0)}if(0===this.m_count){const t=o[0];t.indexA=0,t.indexB=0;const r=e.GetVertex(0),_=i.GetVertex(0);C.MulXV(s,r,t.wA),C.MulXV(n,_,t.wB),b.SubVV(t.wB,t.wA,t.w),t.a=1,this.m_count=1}}WriteCache(t){t.metric=this.GetMetric(),t.count=this.m_count;const e=this.m_vertices;for(let s=0;s<this.m_count;++s)t.indexA[s]=e[s].indexA,t.indexB[s]=e[s].indexB}GetSearchDirection(t){switch(this.m_count){case 1:return b.NegV(this.m_v1.w,t);case 2:{const e=b.SubVV(this.m_v2.w,this.m_v1.w,t);return b.CrossVV(e,b.NegV(this.m_v1.w,b.s_t0))>0?b.CrossOneV(e,t):b.CrossVOne(e,t)}default:return t.SetZero()}}GetClosestPoint(t){switch(this.m_count){case 0:return t.SetZero();case 1:return t.Copy(this.m_v1.w);case 2:return t.Set(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y);case 3:default:return t.SetZero()}}GetWitnessPoints(t,e){switch(this.m_count){case 0:break;case 1:t.Copy(this.m_v1.wA),e.Copy(this.m_v1.wB);break;case 2:t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x,t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y,e.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x,e.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;break;case 3:e.x=t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x,e.y=t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y}}GetMetric(){switch(this.m_count){case 0:case 1:return 0;case 2:return b.DistanceVV(this.m_v1.w,this.m_v2.w);case 3:return b.CrossVV(b.SubVV(this.m_v2.w,this.m_v1.w,b.s_t0),b.SubVV(this.m_v3.w,this.m_v1.w,b.s_t1));default:return 0}}Solve2(){const t=this.m_v1.w,e=this.m_v2.w,s=b.SubVV(e,t,L.s_e12),i=-b.DotVV(t,s);if(i<=0)return this.m_v1.a=1,void(this.m_count=1);const n=b.DotVV(e,s);if(n<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);const o=1/(n+i);this.m_v1.a=n*o,this.m_v2.a=i*o,this.m_count=2}Solve3(){const t=this.m_v1.w,e=this.m_v2.w,s=this.m_v3.w,i=b.SubVV(e,t,L.s_e12),n=b.DotVV(t,i),o=b.DotVV(e,i),r=-n,_=b.SubVV(s,t,L.s_e13),h=b.DotVV(t,_),m=b.DotVV(s,_),a=-h,l=b.SubVV(s,e,L.s_e23),c=b.DotVV(e,l),u=b.DotVV(s,l),d=-c,p=b.CrossVV(i,_),y=p*b.CrossVV(e,s),x=p*b.CrossVV(s,t),A=p*b.CrossVV(t,e);if(r<=0&&a<=0)return this.m_v1.a=1,void(this.m_count=1);if(o>0&&r>0&&A<=0){const t=1/(o+r);return this.m_v1.a=o*t,this.m_v2.a=r*t,void(this.m_count=2)}if(m>0&&a>0&&x<=0){const t=1/(m+a);return this.m_v1.a=m*t,this.m_v3.a=a*t,this.m_count=2,void this.m_v2.Copy(this.m_v3)}if(o<=0&&d<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);if(m<=0&&u<=0)return this.m_v3.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v3);if(u>0&&d>0&&y<=0){const t=1/(u+d);return this.m_v2.a=u*t,this.m_v3.a=d*t,this.m_count=2,void this.m_v1.Copy(this.m_v3)}const S=1/(y+x+A);this.m_v1.a=y*S,this.m_v2.a=x*S,this.m_v3.a=A*S,this.m_count=3}}L.s_e12=new b,L.s_e13=new b,L.s_e23=new b;const R=new L,F=[0,0,0],k=[0,0,0],q=new b,J=new b,z=new b,j=new b,O=new b;function b2Distance(e,s,i){++t.b2_gjkCalls;const n=i.proxyA,o=i.proxyB,r=i.transformA,_=i.transformB,h=R;h.ReadCache(s,n,r,o,_);const m=h.m_vertices,a=F,l=k;let c=0,u=0;for(;u<20;){c=h.m_count;for(let t=0;t<c;++t)a[t]=m[t].indexA,l[t]=m[t].indexB;switch(h.m_count){case 1:break;case 2:h.Solve2();break;case 3:h.Solve3()}if(3===h.m_count)break;const e=h.GetSearchDirection(J);if(e.LengthSquared()<1e-5*1e-5)break;const s=m[h.m_count];s.indexA=n.GetSupport(f.MulTRV(r.q,b.NegV(e,b.s_t0),j)),C.MulXV(r,n.GetVertex(s.indexA),s.wA),s.indexB=o.GetSupport(f.MulTRV(_.q,e,O)),C.MulXV(_,o.GetVertex(s.indexB),s.wB),b.SubVV(s.wB,s.wA,s.w),++u,++t.b2_gjkIters;let i=!1;for(let t=0;t<c;++t)if(s.indexA===a[t]&&s.indexB===l[t]){i=!0;break}if(i)break;++h.m_count}if(t.b2_gjkMaxIters=b2Max(t.b2_gjkMaxIters,u),h.GetWitnessPoints(e.pointA,e.pointB),e.distance=b.DistanceVV(e.pointA,e.pointB),e.iterations=u,h.WriteCache(s),i.useRadii){const t=n.m_radius,s=o.m_radius;if(e.distance>t+s&&e.distance>1e-5){e.distance-=t+s;const i=b.SubVV(e.pointB,e.pointA,z);i.Normalize(),e.pointA.SelfMulAdd(t,i),e.pointB.SelfMulSub(s,i)}else{const t=b.MidVV(e.pointA,e.pointB,q);e.pointA.Copy(t),e.pointB.Copy(t),e.distance=0}}}const N=new b,X=new L,E=new b,Z=new b,W=new b,Q=new b,Y=new b,K=new b;var U,H,$;t.b2ContactFeatureType=void 0,(U=t.b2ContactFeatureType||(t.b2ContactFeatureType={}))[U.e_vertex=0]="e_vertex",U[U.e_face=1]="e_face";class tt{constructor(){this._key=0,this._key_invalid=!1,this._indexA=0,this._indexB=0,this._typeA=0,this._typeB=0}get key(){return this._key_invalid&&(this._key_invalid=!1,this._key=this._indexA|this._indexB<<8|this._typeA<<16|this._typeB<<24),this._key}set key(t){this._key=t,this._key_invalid=!1,this._indexA=255&this._key,this._indexB=this._key>>8&255,this._typeA=this._key>>16&255,this._typeB=this._key>>24&255}get indexA(){return this._indexA}set indexA(t){this._indexA=t,this._key_invalid=!0}get indexB(){return this._indexB}set indexB(t){this._indexB=t,this._key_invalid=!0}get typeA(){return this._typeA}set typeA(t){this._typeA=t,this._key_invalid=!0}get typeB(){return this._typeB}set typeB(t){this._typeB=t,this._key_invalid=!0}}class et{constructor(){this.cf=new tt}Copy(t){return this.key=t.key,this}Clone(){return(new et).Copy(this)}get key(){return this.cf.key}set key(t){this.cf.key=t}}class st{constructor(){this.localPoint=new b,this.normalImpulse=0,this.tangentImpulse=0,this.id=new et}static MakeArray(t){return b2MakeArray(t,t=>new st)}Reset(){this.localPoint.SetZero(),this.normalImpulse=0,this.tangentImpulse=0,this.id.key=0}Copy(t){return this.localPoint.Copy(t.localPoint),this.normalImpulse=t.normalImpulse,this.tangentImpulse=t.tangentImpulse,this.id.Copy(t.id),this}}t.b2ManifoldType=void 0,(H=t.b2ManifoldType||(t.b2ManifoldType={}))[H.e_unknown=-1]="e_unknown",H[H.e_circles=0]="e_circles",H[H.e_faceA=1]="e_faceA",H[H.e_faceB=2]="e_faceB";class it{constructor(){this.points=st.MakeArray(2),this.localNormal=new b,this.localPoint=new b,this.type=t.b2ManifoldType.e_unknown,this.pointCount=0}Reset(){for(let t=0;t<2;++t)this.points[t].Reset();this.localNormal.SetZero(),this.localPoint.SetZero(),this.type=t.b2ManifoldType.e_unknown,this.pointCount=0}Copy(t){this.pointCount=t.pointCount;for(let e=0;e<2;++e)this.points[e].Copy(t.points[e]);return this.localNormal.Copy(t.localNormal),this.localPoint.Copy(t.localPoint),this.type=t.type,this}Clone(){return(new it).Copy(this)}}class nt{constructor(){this.normal=new b,this.points=b.MakeArray(2),this.separations=b2MakeNumberArray(2)}Initialize(e,s,i,n,o){if(0!==e.pointCount)switch(e.type){case t.b2ManifoldType.e_circles:{this.normal.Set(1,0);const t=C.MulXV(s,e.localPoint,nt.Initialize_s_pointA),r=C.MulXV(n,e.points[0].localPoint,nt.Initialize_s_pointB);b.DistanceSquaredVV(t,r)>1e-5*1e-5&&b.SubVV(r,t,this.normal).SelfNormalize();const _=b.AddVMulSV(t,i,this.normal,nt.Initialize_s_cA),h=b.SubVMulSV(r,o,this.normal,nt.Initialize_s_cB);b.MidVV(_,h,this.points[0]),this.separations[0]=b.DotVV(b.SubVV(h,_,b.s_t0),this.normal);break}case t.b2ManifoldType.e_faceA:{f.MulRV(s.q,e.localNormal,this.normal);const t=C.MulXV(s,e.localPoint,nt.Initialize_s_planePoint);for(let s=0;s<e.pointCount;++s){const r=C.MulXV(n,e.points[s].localPoint,nt.Initialize_s_clipPoint),_=i-b.DotVV(b.SubVV(r,t,b.s_t0),this.normal),h=b.AddVMulSV(r,_,this.normal,nt.Initialize_s_cA),m=b.SubVMulSV(r,o,this.normal,nt.Initialize_s_cB);b.MidVV(h,m,this.points[s]),this.separations[s]=b.DotVV(b.SubVV(m,h,b.s_t0),this.normal)}break}case t.b2ManifoldType.e_faceB:{f.MulRV(n.q,e.localNormal,this.normal);const t=C.MulXV(n,e.localPoint,nt.Initialize_s_planePoint);for(let n=0;n<e.pointCount;++n){const r=C.MulXV(s,e.points[n].localPoint,nt.Initialize_s_clipPoint),_=o-b.DotVV(b.SubVV(r,t,b.s_t0),this.normal),h=b.AddVMulSV(r,_,this.normal,nt.Initialize_s_cB),m=b.SubVMulSV(r,i,this.normal,nt.Initialize_s_cA);b.MidVV(m,h,this.points[n]),this.separations[n]=b.DotVV(b.SubVV(m,h,b.s_t0),this.normal)}this.normal.SelfNeg();break}}}}nt.Initialize_s_pointA=new b,nt.Initialize_s_pointB=new b,nt.Initialize_s_cA=new b,nt.Initialize_s_cB=new b,nt.Initialize_s_planePoint=new b,nt.Initialize_s_clipPoint=new b,t.b2PointState=void 0,($=t.b2PointState||(t.b2PointState={}))[$.b2_nullState=0]="b2_nullState",$[$.b2_addState=1]="b2_addState",$[$.b2_persistState=2]="b2_persistState",$[$.b2_removeState=3]="b2_removeState";class ot{constructor(){this.v=new b,this.id=new et}static MakeArray(t){return b2MakeArray(t,t=>new ot)}Copy(t){return this.v.Copy(t.v),this.id.Copy(t.id),this}}class rt{constructor(){this.p1=new b,this.p2=new b,this.maxFraction=1}Copy(t){return this.p1.Copy(t.p1),this.p2.Copy(t.p2),this.maxFraction=t.maxFraction,this}}class _t{constructor(){this.normal=new b,this.fraction=0}Copy(t){return this.normal.Copy(t.normal),this.fraction=t.fraction,this}}class ht{constructor(){this.lowerBound=new b,this.upperBound=new b,this.m_cache_center=new b,this.m_cache_extent=new b}Copy(t){return this.lowerBound.Copy(t.lowerBound),this.upperBound.Copy(t.upperBound),this}IsValid(){return!!this.lowerBound.IsValid()&&(!!this.upperBound.IsValid()&&(!(this.upperBound.x<this.lowerBound.x)&&!(this.upperBound.y<this.lowerBound.y)))}GetCenter(){return b.MidVV(this.lowerBound,this.upperBound,this.m_cache_center)}GetExtents(){return b.ExtVV(this.lowerBound,this.upperBound,this.m_cache_extent)}GetPerimeter(){return 2*(this.upperBound.x-this.lowerBound.x+(this.upperBound.y-this.lowerBound.y))}Combine1(t){return this.lowerBound.x=b2Min(this.lowerBound.x,t.lowerBound.x),this.lowerBound.y=b2Min(this.lowerBound.y,t.lowerBound.y),this.upperBound.x=b2Max(this.upperBound.x,t.upperBound.x),this.upperBound.y=b2Max(this.upperBound.y,t.upperBound.y),this}Combine2(t,e){return this.lowerBound.x=b2Min(t.lowerBound.x,e.lowerBound.x),this.lowerBound.y=b2Min(t.lowerBound.y,e.lowerBound.y),this.upperBound.x=b2Max(t.upperBound.x,e.upperBound.x),this.upperBound.y=b2Max(t.upperBound.y,e.upperBound.y),this}static Combine(t,e,s){return s.Combine2(t,e),s}Contains(t){let e=!0;return e=e&&this.lowerBound.x<=t.lowerBound.x,e=e&&this.lowerBound.y<=t.lowerBound.y,e=e&&t.upperBound.x<=this.upperBound.x,e=e&&t.upperBound.y<=this.upperBound.y,e}RayCast(t,e){let s=-i,n=i;const o=e.p1.x,r=e.p1.y,_=e.p2.x-e.p1.x,m=e.p2.y-e.p1.y,a=h(_),l=h(m),c=t.normal;if(a<1e-5){if(o<this.lowerBound.x||this.upperBound.x<o)return!1}else{const t=1/_;let e=(this.lowerBound.x-o)*t,i=(this.upperBound.x-o)*t,r=-1;if(e>i){const t=e;e=i,i=t,r=1}if(e>s&&(c.x=r,c.y=0,s=e),n=b2Min(n,i),s>n)return!1}if(l<1e-5){if(r<this.lowerBound.y||this.upperBound.y<r)return!1}else{const t=1/m;let e=(this.lowerBound.y-r)*t,i=(this.upperBound.y-r)*t,o=-1;if(e>i){const t=e;e=i,i=t,o=1}if(e>s&&(c.x=0,c.y=o,s=e),n=b2Min(n,i),s>n)return!1}return!(s<0||e.maxFraction<s)&&(t.fraction=s,!0)}TestContain(t){return!(t.x<this.lowerBound.x||this.upperBound.x<t.x)&&!(t.y<this.lowerBound.y||this.upperBound.y<t.y)}TestOverlap(t){return!(this.upperBound.x<t.lowerBound.x)&&(!(this.upperBound.y<t.lowerBound.y)&&(!(t.upperBound.x<this.lowerBound.x)&&!(t.upperBound.y<this.lowerBound.y)))}}function b2TestOverlapAABB(t,e){return!(t.upperBound.x<e.lowerBound.x)&&(!(t.upperBound.y<e.lowerBound.y)&&(!(e.upperBound.x<t.lowerBound.x)&&!(e.upperBound.y<t.lowerBound.y)))}function b2ClipSegmentToLine(e,s,i,n,o){let r=0;const _=s[0],h=s[1],m=b.DotVV(i,_.v)-n,a=b.DotVV(i,h.v)-n;if(m<=0&&e[r++].Copy(_),a<=0&&e[r++].Copy(h),m*a<0){const s=m/(m-a),i=e[r].v;i.x=_.v.x+s*(h.v.x-_.v.x),i.y=_.v.y+s*(h.v.y-_.v.y);const n=e[r].id;n.cf.indexA=o,n.cf.indexB=_.id.cf.indexB,n.cf.typeA=t.b2ContactFeatureType.e_vertex,n.cf.typeB=t.b2ContactFeatureType.e_face,++r}return r}const mt=new T,at=new D,lt=new G;function b2TestOverlapShape(t,e,s,i,n,o){const r=mt.Reset();r.proxyA.SetShape(t,e),r.proxyB.SetShape(s,i),r.transformA.Copy(n),r.transformB.Copy(o),r.useRadii=!0;const _=at.Reset();_.count=0;const h=lt.Reset();return b2Distance(h,_,r),h.distance<1e-4}function verify(t){if(null===t)throw new Error;return t}class ct{constructor(t=0){this.m_id=0,this.aabb=new ht,this._userData=null,this.parent=null,this.child1=null,this.child2=null,this.height=0,this.moved=!1,this.m_id=t}get userData(){if(null===this._userData)throw new Error;return this._userData}set userData(t){if(null!==this._userData)throw new Error;this._userData=t}Reset(){this._userData=null}IsLeaf(){return null===this.child1}}class ut{constructor(){this.m_root=null,this.m_freeList=null,this.m_insertionCount=0,this.m_stack=new _(256)}Query(...t){let e,s;t[0]instanceof ht?(e=t[0],s=t[1]):(e=t[1],s=t[0]);const i=this.m_stack.Reset();for(i.Push(this.m_root);i.GetCount()>0;){const t=i.Pop();if(null!==t&&t.aabb.TestOverlap(e))if(t.IsLeaf()){if(!s(t))return}else i.Push(t.child1),i.Push(t.child2)}}QueryPoint(t,e){const s=this.m_stack.Reset();for(s.Push(this.m_root);s.GetCount()>0;){const i=s.Pop();if(null!==i&&i.aabb.TestContain(t))if(i.IsLeaf()){if(!e(i))return}else s.Push(i.child1),s.Push(i.child2)}}RayCast(...t){let e,s;t[0]instanceof rt?(s=t[0],e=t[1]):(s=t[1],e=t[0]);const i=s.p1,n=s.p2,o=b.SubVV(n,i,ut.s_r);o.Normalize();const r=b.CrossOneV(o,ut.s_v),_=b.AbsV(r,ut.s_abs_v);let m=s.maxFraction;const a=ut.s_segmentAABB;let l=i.x+m*(n.x-i.x),c=i.y+m*(n.y-i.y);a.lowerBound.x=b2Min(i.x,l),a.lowerBound.y=b2Min(i.y,c),a.upperBound.x=b2Max(i.x,l),a.upperBound.y=b2Max(i.y,c);const u=this.m_stack.Reset();for(u.Push(this.m_root);u.GetCount()>0;){const t=u.Pop();if(null===t)continue;if(!b2TestOverlapAABB(t.aabb,a))continue;const o=t.aabb.GetCenter(),d=t.aabb.GetExtents();if(!(h(b.DotVV(r,b.SubVV(i,o,b.s_t0)))-b.DotVV(_,d)>0))if(t.IsLeaf()){const o=ut.s_subInput;o.p1.Copy(s.p1),o.p2.Copy(s.p2),o.maxFraction=m;const r=e(o,t);if(0===r)return;r>0&&(m=r,l=i.x+m*(n.x-i.x),c=i.y+m*(n.y-i.y),a.lowerBound.x=b2Min(i.x,l),a.lowerBound.y=b2Min(i.y,c),a.upperBound.x=b2Max(i.x,l),a.upperBound.y=b2Max(i.y,c))}else u.Push(t.child1),u.Push(t.child2)}}AllocateNode(){if(null!==this.m_freeList){const t=this.m_freeList;return this.m_freeList=t.parent,t.parent=null,t.child1=null,t.child2=null,t.height=0,t.moved=!1,t}return new ct(ut.s_node_id++)}FreeNode(t){t.parent=this.m_freeList,t.child1=null,t.child2=null,t.height=-1,t.Reset(),this.m_freeList=t}CreateProxy(t,e){const s=this.AllocateNode();return s.aabb.lowerBound.x=t.lowerBound.x-.1,s.aabb.lowerBound.y=t.lowerBound.y-.1,s.aabb.upperBound.x=t.upperBound.x+.1,s.aabb.upperBound.y=t.upperBound.y+.1,s.userData=e,s.height=0,s.moved=!0,this.InsertLeaf(s),s}DestroyProxy(t){this.RemoveLeaf(t),this.FreeNode(t)}MoveProxy(t,e,s){const i=ut.MoveProxy_s_fatAABB;i.lowerBound.x=e.lowerBound.x-.1,i.lowerBound.y=e.lowerBound.y-.1,i.upperBound.x=e.upperBound.x+.1,i.upperBound.y=e.upperBound.y+.1;const n=4*s.x,o=4*s.y;n<0?i.lowerBound.x+=n:i.upperBound.x+=n,o<0?i.lowerBound.y+=o:i.upperBound.y+=o;const r=t.aabb;if(r.Contains(e)){const t=ut.MoveProxy_s_hugeAABB;if(t.lowerBound.x=i.lowerBound.x-.4,t.lowerBound.y=i.lowerBound.y-.4,t.upperBound.x=i.upperBound.x+.4,t.upperBound.y=i.upperBound.y+.4,t.Contains(r))return!1}return this.RemoveLeaf(t),t.aabb.Copy(i),this.InsertLeaf(t),t.moved=!0,!0}InsertLeaf(t){if(++this.m_insertionCount,null===this.m_root)return this.m_root=t,void(this.m_root.parent=null);const e=t.aabb;let s=this.m_root;for(;!s.IsLeaf();){const t=verify(s.child1),i=verify(s.child2),n=s.aabb.GetPerimeter(),o=ut.s_combinedAABB;o.Combine2(s.aabb,e);const r=o.GetPerimeter(),_=2*r,h=2*(r-n);let m;const a=ut.s_aabb;let l,c,u;if(t.IsLeaf()?(a.Combine2(e,t.aabb),m=a.GetPerimeter()+h):(a.Combine2(e,t.aabb),l=t.aabb.GetPerimeter(),c=a.GetPerimeter(),m=c-l+h),i.IsLeaf()?(a.Combine2(e,i.aabb),u=a.GetPerimeter()+h):(a.Combine2(e,i.aabb),l=i.aabb.GetPerimeter(),c=a.GetPerimeter(),u=c-l+h),_<m&&_<u)break;s=m<u?t:i}const i=s.parent,n=this.AllocateNode();n.parent=i,n.aabb.Combine2(e,s.aabb),n.height=s.height+1,null!==i?(i.child1===s?i.child1=n:i.child2=n,n.child1=s,n.child2=t,s.parent=n,t.parent=n):(n.child1=s,n.child2=t,s.parent=n,t.parent=n,this.m_root=n);let o=t.parent;for(;null!==o;){o=this.Balance(o);const t=verify(o.child1),e=verify(o.child2);o.height=1+b2Max(t.height,e.height),o.aabb.Combine2(t.aabb,e.aabb),o=o.parent}}RemoveLeaf(t){if(t===this.m_root)return void(this.m_root=null);const e=verify(t.parent),s=e&&e.parent,i=verify(e.child1===t?e.child2:e.child1);if(null!==s){s.child1===e?s.child1=i:s.child2=i,i.parent=s,this.FreeNode(e);let t=s;for(;null!==t;){t=this.Balance(t);const e=verify(t.child1),s=verify(t.child2);t.aabb.Combine2(e.aabb,s.aabb),t.height=1+b2Max(e.height,s.height),t=t.parent}}else this.m_root=i,i.parent=null,this.FreeNode(e)}Balance(t){if(t.IsLeaf()||t.height<2)return t;const e=verify(t.child1),s=verify(t.child2),i=s.height-e.height;if(i>1){const i=verify(s.child1),n=verify(s.child2);return s.child1=t,s.parent=t.parent,t.parent=s,null!==s.parent?s.parent.child1===t?s.parent.child1=s:s.parent.child2=s:this.m_root=s,i.height>n.height?(s.child2=i,t.child2=n,n.parent=t,t.aabb.Combine2(e.aabb,n.aabb),s.aabb.Combine2(t.aabb,i.aabb),t.height=1+b2Max(e.height,n.height),s.height=1+b2Max(t.height,i.height)):(s.child2=n,t.child2=i,i.parent=t,t.aabb.Combine2(e.aabb,i.aabb),s.aabb.Combine2(t.aabb,n.aabb),t.height=1+b2Max(e.height,i.height),s.height=1+b2Max(t.height,n.height)),s}if(i<-1){const i=verify(e.child1),n=verify(e.child2);return e.child1=t,e.parent=t.parent,t.parent=e,null!==e.parent?e.parent.child1===t?e.parent.child1=e:e.parent.child2=e:this.m_root=e,i.height>n.height?(e.child2=i,t.child1=n,n.parent=t,t.aabb.Combine2(s.aabb,n.aabb),e.aabb.Combine2(t.aabb,i.aabb),t.height=1+b2Max(s.height,n.height),e.height=1+b2Max(t.height,i.height)):(e.child2=n,t.child1=i,i.parent=t,t.aabb.Combine2(s.aabb,i.aabb),e.aabb.Combine2(t.aabb,n.aabb),t.height=1+b2Max(s.height,i.height),e.height=1+b2Max(t.height,n.height)),e}return t}GetHeight(){return null===this.m_root?0:this.m_root.height}static GetAreaNode(t){if(null===t)return 0;if(t.IsLeaf())return 0;let e=t.aabb.GetPerimeter();return e+=ut.GetAreaNode(t.child1),e+=ut.GetAreaNode(t.child2),e}GetAreaRatio(){if(null===this.m_root)return 0;const t=this.m_root.aabb.GetPerimeter();return ut.GetAreaNode(this.m_root)/t}static ComputeHeightNode(t){if(null===t)return 0;if(t.IsLeaf())return 0;return 1+b2Max(ut.ComputeHeightNode(t.child1),ut.ComputeHeightNode(t.child2))}ComputeHeight(){return ut.ComputeHeightNode(this.m_root)}ValidateStructure(t){if(null===t)return;if(this.m_root,t.IsLeaf())return;const e=verify(t.child1),s=verify(t.child2);this.ValidateStructure(e),this.ValidateStructure(s)}ValidateMetrics(t){if(null===t)return;if(t.IsLeaf())return;const e=verify(t.child1),s=verify(t.child2);ut.s_aabb.Combine2(e.aabb,s.aabb),this.ValidateMetrics(e),this.ValidateMetrics(s)}Validate(){}static GetMaxBalanceNode(t,e){if(null===t)return e;if(t.height<=1)return e;const s=verify(t.child1),i=verify(t.child2);return b2Max(e,h(i.height-s.height))}GetMaxBalance(){return ut.GetMaxBalanceNode(this.m_root,0)}RebuildBottomUp(){this.Validate()}static ShiftOriginNode(t,e){if(null===t)return;if(t.height<=1)return;const s=t.child1,i=t.child2;ut.ShiftOriginNode(s,e),ut.ShiftOriginNode(i,e),t.aabb.lowerBound.SelfSub(e),t.aabb.upperBound.SelfSub(e)}ShiftOrigin(t){ut.ShiftOriginNode(this.m_root,t)}}ut.s_r=new b,ut.s_v=new b,ut.s_abs_v=new b,ut.s_segmentAABB=new ht,ut.s_subInput=new rt,ut.s_combinedAABB=new ht,ut.s_aabb=new ht,ut.s_node_id=0,ut.MoveProxy_s_fatAABB=new ht,ut.MoveProxy_s_hugeAABB=new ht;class dt{constructor(t,e){this.proxyA=t,this.proxyB=e}}class pt{constructor(){this.m_tree=new ut,this.m_proxyCount=0,this.m_moveCount=0,this.m_moveBuffer=[],this.m_pairCount=0,this.m_pairBuffer=[]}CreateProxy(t,e){const s=this.m_tree.CreateProxy(t,e);return++this.m_proxyCount,this.BufferMove(s),s}DestroyProxy(t){this.UnBufferMove(t),--this.m_proxyCount,this.m_tree.DestroyProxy(t)}MoveProxy(t,e,s){this.m_tree.MoveProxy(t,e,s)&&this.BufferMove(t)}TouchProxy(t){this.BufferMove(t)}GetProxyCount(){return this.m_proxyCount}UpdatePairs(t){this.m_pairCount=0;for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];if(null===e)continue;const s=e.aabb;this.m_tree.Query(s,t=>{if(t.m_id===e.m_id)return!0;if(t.moved&&t.m_id>e.m_id)return!0;let s,i;if(t.m_id<e.m_id?(s=t,i=e):(s=e,i=t),this.m_pairCount===this.m_pairBuffer.length)this.m_pairBuffer[this.m_pairCount]=new dt(s,i);else{const t=this.m_pairBuffer[this.m_pairCount];t.proxyA=s,t.proxyB=i}return++this.m_pairCount,!0})}for(let e=0;e<this.m_pairCount;++e){const s=this.m_pairBuffer[e];t(s.proxyA.userData,s.proxyB.userData)}for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];null!==e&&(e.moved=!1)}this.m_moveCount=0}Query(...t){this.m_tree.Query(t[0],t[1])}QueryPoint(t,e){this.m_tree.QueryPoint(t,e)}RayCast(t,e){this.m_tree.RayCast(t,e)}GetTreeHeight(){return this.m_tree.GetHeight()}GetTreeBalance(){return this.m_tree.GetMaxBalance()}GetTreeQuality(){return this.m_tree.GetAreaRatio()}ShiftOrigin(t){this.m_tree.ShiftOrigin(t)}BufferMove(t){this.m_moveBuffer[this.m_moveCount]=t,++this.m_moveCount}UnBufferMove(t){for(let e=0;e<this.m_moveCount;e++)this.m_moveBuffer[e]==t&&(this.m_moveBuffer[e]=null)}}class yt extends M{constructor(){super(t.b2ShapeType.e_edgeShape,.01),this.m_vertex1=new b,this.m_vertex2=new b,this.m_vertex0=new b,this.m_vertex3=new b,this.m_oneSided=!1}SetOneSided(t,e,s,i){return this.m_vertex0.Copy(t),this.m_vertex1.Copy(e),this.m_vertex2.Copy(s),this.m_vertex3.Copy(i),this.m_oneSided=!0,this}SetTwoSided(t,e){return this.m_vertex1.Copy(t),this.m_vertex2.Copy(e),this.m_oneSided=!1,this}Clone(){return(new yt).Copy(this)}Copy(t){return super.Copy(t),this.m_vertex1.Copy(t.m_vertex1),this.m_vertex2.Copy(t.m_vertex2),this.m_vertex0.Copy(t.m_vertex0),this.m_vertex3.Copy(t.m_vertex3),this.m_oneSided=t.m_oneSided,this}GetChildCount(){return 1}TestPoint(t,e){return!1}RayCast(t,e,s,i){const n=C.MulTXV(s,e.p1,yt.RayCast_s_p1),o=C.MulTXV(s,e.p2,yt.RayCast_s_p2),r=b.SubVV(o,n,yt.RayCast_s_d),_=this.m_vertex1,h=this.m_vertex2,m=b.SubVV(h,_,yt.RayCast_s_e),a=t.normal.Set(m.y,-m.x).SelfNormalize(),l=b.DotVV(a,b.SubVV(_,n,b.s_t0));if(this.m_oneSided&&l>0)return!1;const c=b.DotVV(a,r);if(0===c)return!1;const u=l/c;if(u<0||e.maxFraction<u)return!1;const d=b.AddVMulSV(n,u,r,yt.RayCast_s_q),p=b.SubVV(h,_,yt.RayCast_s_r),y=b.DotVV(p,p);if(0===y)return!1;const x=b.DotVV(b.SubVV(d,_,b.s_t0),p)/y;return!(x<0||1<x)&&(t.fraction=u,f.MulRV(s.q,t.normal,t.normal),l>0&&t.normal.SelfNeg(),!0)}ComputeAABB(t,e,s){const i=C.MulXV(e,this.m_vertex1,yt.ComputeAABB_s_v1),n=C.MulXV(e,this.m_vertex2,yt.ComputeAABB_s_v2);b.MinV(i,n,t.lowerBound),b.MaxV(i,n,t.upperBound);const o=this.m_radius;t.lowerBound.SelfSubXY(o,o),t.upperBound.SelfAddXY(o,o)}ComputeMass(t,e){t.mass=0,b.MidVV(this.m_vertex1,this.m_vertex2,t.center),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertex1),t.m_vertices[1].Copy(this.m_vertex2),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){return i.SetZero(),0}Dump(t){t("    const shape: b2EdgeShape = new b2EdgeShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_vertex0.Set(%.15f, %.15f);\n",this.m_vertex0.x,this.m_vertex0.y),t("    shape.m_vertex1.Set(%.15f, %.15f);\n",this.m_vertex1.x,this.m_vertex1.y),t("    shape.m_vertex2.Set(%.15f, %.15f);\n",this.m_vertex2.x,this.m_vertex2.y),t("    shape.m_vertex3.Set(%.15f, %.15f);\n",this.m_vertex3.x,this.m_vertex3.y),t("    shape.m_oneSided = %s;\n",this.m_oneSided)}}yt.RayCast_s_p1=new b,yt.RayCast_s_p2=new b,yt.RayCast_s_d=new b,yt.RayCast_s_e=new b,yt.RayCast_s_q=new b,yt.RayCast_s_r=new b,yt.ComputeAABB_s_v1=new b,yt.ComputeAABB_s_v2=new b;class bt extends M{constructor(){super(t.b2ShapeType.e_chainShape,.01),this.m_vertices=[],this.m_count=0,this.m_prevVertex=new b,this.m_nextVertex=new b}CreateLoop(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._CreateLoop(t=>({x:e[2*t],y:e[2*t+1]}),e.length/2)}{const e=t[0],s=t[1]||e.length;return this._CreateLoop(t=>e[t],s)}}_CreateLoop(t,e){if(e<3)return this;this.m_count=e+1,this.m_vertices=b.MakeArray(this.m_count);for(let s=0;s<e;++s)this.m_vertices[s].Copy(t(s));return this.m_vertices[e].Copy(this.m_vertices[0]),this.m_prevVertex.Copy(this.m_vertices[this.m_count-2]),this.m_nextVertex.Copy(this.m_vertices[1]),this}CreateChain(...t){if("number"==typeof t[0][0]){const e=t[0],s=t[1],i=t[2];if(e.length%2!=0)throw new Error;return this._CreateChain(t=>({x:e[2*t],y:e[2*t+1]}),e.length/2,s,i)}{const e=t[0],s=t[1]||e.length,i=t[2],n=t[3];return this._CreateChain(t=>e[t],s,i,n)}}_CreateChain(t,e,s,i){this.m_count=e,this.m_vertices=b.MakeArray(e);for(let s=0;s<e;++s)this.m_vertices[s].Copy(t(s));return this.m_prevVertex.Copy(s),this.m_nextVertex.Copy(i),this}Clone(){return(new bt).Copy(this)}Copy(t){return super.Copy(t),this._CreateChain(e=>t.m_vertices[e],t.m_count,t.m_prevVertex,t.m_nextVertex),this.m_prevVertex.Copy(t.m_prevVertex),this.m_nextVertex.Copy(t.m_nextVertex),this}GetChildCount(){return this.m_count-1}GetChildEdge(t,e){t.m_radius=this.m_radius,t.m_vertex1.Copy(this.m_vertices[e]),t.m_vertex2.Copy(this.m_vertices[e+1]),t.m_oneSided=!0,e>0?t.m_vertex0.Copy(this.m_vertices[e-1]):t.m_vertex0.Copy(this.m_prevVertex),e<this.m_count-2?t.m_vertex3.Copy(this.m_vertices[e+2]):t.m_vertex3.Copy(this.m_nextVertex)}TestPoint(t,e){return!1}RayCast(t,e,s,i){const n=bt.RayCast_s_edgeShape;return n.m_vertex1.Copy(this.m_vertices[i]),n.m_vertex2.Copy(this.m_vertices[(i+1)%this.m_count]),n.RayCast(t,e,s,0)}ComputeAABB(t,e,s){const i=this.m_vertices[s],n=this.m_vertices[(s+1)%this.m_count],o=C.MulXV(e,i,bt.ComputeAABB_s_v1),r=C.MulXV(e,n,bt.ComputeAABB_s_v2),_=b.MinV(o,r,bt.ComputeAABB_s_lower),h=b.MaxV(o,r,bt.ComputeAABB_s_upper);t.lowerBound.x=_.x-this.m_radius,t.lowerBound.y=_.y-this.m_radius,t.upperBound.x=h.x+this.m_radius,t.upperBound.y=h.y+this.m_radius}ComputeMass(t,e){t.mass=0,t.center.SetZero(),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertices[e]),e+1<this.m_count?t.m_vertices[1].Copy(this.m_vertices[e+1]):t.m_vertices[1].Copy(this.m_vertices[0]),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){return i.SetZero(),0}Dump(t){t("    const shape: b2ChainShape = new b2ChainShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new bVec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.CreateChain(vs, %d);\n",this.m_count),t("    shape.m_prevVertex.Set(%.15f, %.15f);\n",this.m_prevVertex.x,this.m_prevVertex.y),t("    shape.m_nextVertex.Set(%.15f, %.15f);\n",this.m_nextVertex.x,this.m_nextVertex.y)}}bt.RayCast_s_edgeShape=new yt,bt.ComputeAABB_s_v1=new b,bt.ComputeAABB_s_v2=new b,bt.ComputeAABB_s_lower=new b,bt.ComputeAABB_s_upper=new b;class xt extends M{constructor(e=0){super(t.b2ShapeType.e_circleShape,e),this.m_p=new b}Set(t,e=this.m_radius){return this.m_p.Copy(t),this.m_radius=e,this}Clone(){return(new xt).Copy(this)}Copy(t){return super.Copy(t),this.m_p.Copy(t.m_p),this}GetChildCount(){return 1}TestPoint(t,e){const s=C.MulXV(t,this.m_p,xt.TestPoint_s_center),i=b.SubVV(e,s,xt.TestPoint_s_d);return b.DotVV(i,i)<=b2Sq(this.m_radius)}RayCast(t,e,s,i){const n=C.MulXV(s,this.m_p,xt.RayCast_s_position),o=b.SubVV(e.p1,n,xt.RayCast_s_s),r=b.DotVV(o,o)-b2Sq(this.m_radius),_=b.SubVV(e.p2,e.p1,xt.RayCast_s_r),h=b.DotVV(o,_),m=b.DotVV(_,_),l=h*h-m*r;if(l<0||m<1e-5)return!1;let c=-(h+a(l));return 0<=c&&c<=e.maxFraction*m&&(c/=m,t.fraction=c,b.AddVMulSV(o,c,_,t.normal).SelfNormalize(),!0)}ComputeAABB(t,e,s){const i=C.MulXV(e,this.m_p,xt.ComputeAABB_s_p);t.lowerBound.Set(i.x-this.m_radius,i.y-this.m_radius),t.upperBound.Set(i.x+this.m_radius,i.y+this.m_radius)}ComputeMass(t,e){const s=b2Sq(this.m_radius);t.mass=e*n*s,t.center.Copy(this.m_p),t.I=t.mass*(.5*s+b.DotVV(this.m_p,this.m_p))}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_p),t.m_count=1,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){const o=C.MulXV(s,this.m_p,new b),r=-(b.DotVV(t,o)-e);if(r<1e-5-this.m_radius)return 0;if(r>this.m_radius)return i.Copy(o),n*this.m_radius*this.m_radius;const _=this.m_radius*this.m_radius,h=r*r,m=_*(p(r/this.m_radius)+n/2)+r*a(_-h),c=-2/3*l(_-h,1.5)/m;return i.x=o.x+t.x*c,i.y=o.y+t.y*c,m}Dump(t){t("    const shape: b2CircleShape = new b2CircleShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_p.Set(%.15f, %.15f);\n",this.m_p.x,this.m_p.y)}}xt.TestPoint_s_center=new b,xt.TestPoint_s_d=new b,xt.RayCast_s_position=new b,xt.RayCast_s_s=new b,xt.RayCast_s_r=new b,xt.ComputeAABB_s_p=new b;const At=new b,St=new b;function b2CollideCircles(e,s,i,n,o){e.pointCount=0;const r=C.MulXV(i,s.m_p,At),_=C.MulXV(o,n.m_p,St),h=b.DistanceSquaredVV(r,_),m=s.m_radius+n.m_radius;h>m*m||(e.type=t.b2ManifoldType.e_circles,e.localPoint.Copy(s.m_p),e.localNormal.SetZero(),e.pointCount=1,e.points[0].localPoint.Copy(n.m_p),e.points[0].id.key=0)}const Vt=new b,ft=new b,Ct=new b;function b2CollidePolygonAndCircle(e,s,n,o,r){e.pointCount=0;const _=C.MulXV(r,o.m_p,Vt),h=C.MulTXV(n,_,ft);let m=0,a=-i;const l=s.m_radius+o.m_radius,c=s.m_count,u=s.m_vertices,d=s.m_normals;for(let t=0;t<c;++t){const e=b.DotVV(d[t],b.SubVV(h,u[t],b.s_t0));if(e>l)return;e>a&&(a=e,m=t)}const p=m,y=(p+1)%c,x=u[p],A=u[y];if(a<1e-5)return e.pointCount=1,e.type=t.b2ManifoldType.e_faceA,e.localNormal.Copy(d[m]),b.MidVV(x,A,e.localPoint),e.points[0].localPoint.Copy(o.m_p),void(e.points[0].id.key=0);const S=b.DotVV(b.SubVV(h,x,b.s_t0),b.SubVV(A,x,b.s_t1)),V=b.DotVV(b.SubVV(h,A,b.s_t0),b.SubVV(x,A,b.s_t1));if(S<=0){if(b.DistanceSquaredVV(h,x)>l*l)return;e.pointCount=1,e.type=t.b2ManifoldType.e_faceA,b.SubVV(h,x,e.localNormal).SelfNormalize(),e.localPoint.Copy(x),e.points[0].localPoint.Copy(o.m_p),e.points[0].id.key=0}else if(V<=0){if(b.DistanceSquaredVV(h,A)>l*l)return;e.pointCount=1,e.type=t.b2ManifoldType.e_faceA,b.SubVV(h,A,e.localNormal).SelfNormalize(),e.localPoint.Copy(A),e.points[0].localPoint.Copy(o.m_p),e.points[0].id.key=0}else{const s=b.MidVV(x,A,Ct);if(b.DotVV(b.SubVV(h,s,b.s_t1),d[p])>l)return;e.pointCount=1,e.type=t.b2ManifoldType.e_faceA,e.localNormal.Copy(d[p]).SelfNormalize(),e.localPoint.Copy(s),e.points[0].localPoint.Copy(o.m_p),e.points[0].id.key=0}}const wt=new b,Bt=new b,vt=new b,gt=new b,Mt=new b,It=new b,Dt=new b,Tt=new et;function b2CollideEdgeAndCircle(e,s,i,n,o){e.pointCount=0;const r=C.MulTXV(i,C.MulXV(o,n.m_p,b.s_t0),wt),_=s.m_vertex1,h=s.m_vertex2,m=b.SubVV(h,_,Bt),a=Dt.Set(m.y,-m.x),l=b.DotVV(a,b.SubVV(r,_,b.s_t0));if(s.m_oneSided&&l<0)return;const c=b.DotVV(m,b.SubVV(h,r,b.s_t0)),u=b.DotVV(m,b.SubVV(r,_,b.s_t0)),d=s.m_radius+n.m_radius,p=Tt;if(p.cf.indexB=0,p.cf.typeB=t.b2ContactFeatureType.e_vertex,u<=0){const i=_,o=b.SubVV(r,i,vt);if(b.DotVV(o,o)>d*d)return;if(s.m_oneSided){const t=s.m_vertex0,e=_,i=b.SubVV(e,t,gt);if(b.DotVV(i,b.SubVV(e,r,b.s_t0))>0)return}return p.cf.indexA=0,p.cf.typeA=t.b2ContactFeatureType.e_vertex,e.pointCount=1,e.type=t.b2ManifoldType.e_circles,e.localNormal.SetZero(),e.localPoint.Copy(i),e.points[0].id.Copy(p),void e.points[0].localPoint.Copy(n.m_p)}if(c<=0){const i=h,o=b.SubVV(r,i,vt);if(b.DotVV(o,o)>d*d)return;if(s.m_oneSided){const t=s.m_vertex3,e=h,i=b.SubVV(t,e,Mt);if(b.DotVV(i,b.SubVV(r,e,b.s_t0))>0)return}return p.cf.indexA=1,p.cf.typeA=t.b2ContactFeatureType.e_vertex,e.pointCount=1,e.type=t.b2ManifoldType.e_circles,e.localNormal.SetZero(),e.localPoint.Copy(i),e.points[0].id.Copy(p),void e.points[0].localPoint.Copy(n.m_p)}const y=b.DotVV(m,m),x=It;x.x=1/y*(c*_.x+u*h.x),x.y=1/y*(c*_.y+u*h.y);const A=b.SubVV(r,x,vt);b.DotVV(A,A)>d*d||(l<0&&a.Set(-a.x,-a.y),a.Normalize(),p.cf.indexA=0,p.cf.typeA=t.b2ContactFeatureType.e_face,e.pointCount=1,e.type=t.b2ManifoldType.e_faceA,e.localNormal.Copy(a),e.localPoint.Copy(_),e.points[0].id.Copy(p),e.points[0].localPoint.Copy(n.m_p))}var Gt;!function(t){t[t.e_unknown=0]="e_unknown",t[t.e_edgeA=1]="e_edgeA",t[t.e_edgeB=2]="e_edgeB"}(Gt||(Gt={}));class Pt{constructor(){this.normal=new b,this.type=Gt.e_unknown,this.index=0,this.separation=0}}const Lt=new Pt,Rt=[new b,new b];const Ft=new Pt,kt=new b;const qt=new C,Jt=new b,zt=new b,jt=new b,Ot=new b,Nt=new b,Xt=new b,Et=new b,Zt=new class{constructor(){this.vertices=[],this.normals=[],this.count=0}},Wt=new class{constructor(){this.i1=0,this.i2=0,this.v1=new b,this.v2=new b,this.normal=new b,this.sideNormal1=new b,this.sideOffset1=0,this.sideNormal2=new b,this.sideOffset2=0}},Qt=[new ot,new ot],Yt=[new ot,new ot],Kt=[new ot,new ot];function b2CollideEdgeAndPolygon(e,s,i,n,o){e.pointCount=0;const r=C.MulTXX(i,o,qt),_=C.MulXV(r,n.m_centroid,Jt),h=s.m_vertex1,m=s.m_vertex2,a=b.SubVV(m,h,zt);a.Normalize();const l=jt.Set(a.y,-a.x),c=b.DotVV(l,b.SubVV(_,h,b.s_t0)),u=s.m_oneSided;if(u&&c<0)return;const d=Zt;d.count=n.m_count;for(let t=0;t<n.m_count;++t)d.vertices.length<=t&&d.vertices.push(new b),d.normals.length<=t&&d.normals.push(new b),C.MulXV(r,n.m_vertices[t],d.vertices[t]),f.MulRV(r.q,n.m_normals[t],d.normals[t]);const p=n.m_radius+s.m_radius,y=function(t,e,s){const i=Lt;i.type=Gt.e_edgeA,i.index=-1,i.separation=-Number.MAX_VALUE,i.normal.SetZero();const n=Rt;n[0].Copy(s),n[1].Copy(s).SelfNeg();for(let s=0;s<2;++s){let o=Number.MAX_VALUE;for(let i=0;i<t.count;++i){const r=b.DotVV(n[s],b.SubVV(t.vertices[i],e,b.s_t0));r<o&&(o=r)}o>i.separation&&(i.index=s,i.separation=o,i.normal.Copy(n[s]))}return i}(d,h,l);if(y.separation>p)return;const x=function(t,e,s){const i=Ft;i.type=Gt.e_unknown,i.index=-1,i.separation=-Number.MAX_VALUE,i.normal.SetZero();for(let n=0;n<t.count;++n){const o=b.NegV(t.normals[n],kt),r=b2Min(b.DotVV(o,b.SubVV(t.vertices[n],e,b.s_t0)),b.DotVV(o,b.SubVV(t.vertices[n],s,b.s_t0)));r>i.separation&&(i.type=Gt.e_edgeB,i.index=n,i.separation=r,i.normal.Copy(o))}return i}(d,h,m);if(x.separation>p)return;let A;if(A=x.separation-p>.98*(y.separation-p)+.001?x:y,u){const t=b.SubVV(h,s.m_vertex0,Ot);t.Normalize();const e=Nt.Set(t.y,-t.x),i=b.CrossVV(t,a)>=0,n=b.SubVV(s.m_vertex3,m,Xt);n.Normalize();const o=Et.Set(n.y,-n.x),r=b.CrossVV(a,n)>=0,_=.1;if(b.DotVV(A.normal,a)<=0)if(i){if(b.CrossVV(A.normal,e)>_)return}else A=y;else if(r){if(b.CrossVV(o,A.normal)>_)return}else A=y}const S=Qt,V=Wt;if(A.type===Gt.e_edgeA){e.type=t.b2ManifoldType.e_faceA;let s=0,i=b.DotVV(A.normal,d.normals[0]);for(let t=1;t<d.count;++t){const e=b.DotVV(A.normal,d.normals[t]);e<i&&(i=e,s=t)}const n=s,o=n+1<d.count?n+1:0;S[0].v.Copy(d.vertices[n]),S[0].id.cf.indexA=0,S[0].id.cf.indexB=n,S[0].id.cf.typeA=t.b2ContactFeatureType.e_face,S[0].id.cf.typeB=t.b2ContactFeatureType.e_vertex,S[1].v.Copy(d.vertices[o]),S[1].id.cf.indexA=0,S[1].id.cf.indexB=o,S[1].id.cf.typeA=t.b2ContactFeatureType.e_face,S[1].id.cf.typeB=t.b2ContactFeatureType.e_vertex,V.i1=0,V.i2=1,V.v1.Copy(h),V.v2.Copy(m),V.normal.Copy(A.normal),V.sideNormal1.Copy(a).SelfNeg(),V.sideNormal2.Copy(a)}else e.type=t.b2ManifoldType.e_faceB,S[0].v.Copy(m),S[0].id.cf.indexA=1,S[0].id.cf.indexB=A.index,S[0].id.cf.typeA=t.b2ContactFeatureType.e_vertex,S[0].id.cf.typeB=t.b2ContactFeatureType.e_face,S[1].v.Copy(h),S[1].id.cf.indexA=0,S[1].id.cf.indexB=A.index,S[1].id.cf.typeA=t.b2ContactFeatureType.e_vertex,S[1].id.cf.typeB=t.b2ContactFeatureType.e_face,V.i1=A.index,V.i2=V.i1+1<d.count?V.i1+1:0,V.v1.Copy(d.vertices[V.i1]),V.v2.Copy(d.vertices[V.i2]),V.normal.Copy(d.normals[V.i1]),V.sideNormal1.Set(V.normal.y,-V.normal.x),V.sideNormal2.Copy(V.sideNormal1).SelfNeg();V.sideOffset1=b.DotVV(V.sideNormal1,V.v1),V.sideOffset2=b.DotVV(V.sideNormal2,V.v2);const w=Yt,B=Kt;let v;if(v=b2ClipSegmentToLine(w,S,V.sideNormal1,V.sideOffset1,V.i1),v<2)return;if(v=b2ClipSegmentToLine(B,w,V.sideNormal2,V.sideOffset2,V.i2),v<2)return;A.type===Gt.e_edgeA?(e.localNormal.Copy(V.normal),e.localPoint.Copy(V.v1)):(e.localNormal.Copy(n.m_normals[V.i1]),e.localPoint.Copy(n.m_vertices[V.i1]));let g=0;for(let t=0;t<2;++t){if(b.DotVV(V.normal,b.SubVV(B[t].v,V.v1,b.s_t0))<=p){const s=e.points[g];A.type===Gt.e_edgeA?(C.MulTXV(r,B[t].v,s.localPoint),s.id.Copy(B[t].id)):(s.localPoint.Copy(B[t].v),s.id.cf.typeA=B[t].id.cf.typeB,s.id.cf.typeB=B[t].id.cf.typeA,s.id.cf.indexA=B[t].id.cf.indexB,s.id.cf.indexB=B[t].id.cf.indexA),++g}}e.pointCount=g}const Ut=new C,Ht=new b,$t=new b;function b2FindMaxSeparation(t,e,s,n,o){const r=e.m_count,_=n.m_count,h=e.m_normals,m=e.m_vertices,a=n.m_vertices,l=C.MulTXX(o,s,Ut);let c=0,u=-i;for(let t=0;t<r;++t){const e=f.MulRV(l.q,h[t],Ht),s=C.MulXV(l,m[t],$t);let n=i;for(let t=0;t<_;++t){const i=b.DotVV(e,b.SubVV(a[t],s,b.s_t0));i<n&&(n=i)}n>u&&(u=n,c=t)}return t[0]=c,u}const te=new b;const ee=[new ot,new ot],se=[new ot,new ot],ie=[new ot,new ot],ne=[0],oe=[0],re=new b,_e=new b,he=new b,me=new b,ae=new b,le=new b,ce=new b,ue=new b;function b2CollidePolygons(e,s,n,o,r){e.pointCount=0;const _=s.m_radius+o.m_radius,h=ne;h[0]=0;const m=b2FindMaxSeparation(h,s,n,o,r);if(m>_)return;const a=oe;a[0]=0;const l=b2FindMaxSeparation(a,o,r,s,n);if(l>_)return;let c,u,d,p,y=0,x=0;l>m+5e-4?(c=o,u=s,d=r,p=n,y=a[0],e.type=t.b2ManifoldType.e_faceB,x=1):(c=s,u=o,d=n,p=r,y=h[0],e.type=t.b2ManifoldType.e_faceA,x=0);const A=ee;!function(e,s,n,o,r,_){const h=s.m_normals,m=r.m_count,a=r.m_vertices,l=r.m_normals,c=f.MulTRV(_.q,f.MulRV(n.q,h[o],b.s_t0),te);let u=0,d=i;for(let t=0;t<m;++t){const e=b.DotVV(c,l[t]);e<d&&(d=e,u=t)}const p=u,y=p+1<m?p+1:0,x=e[0];C.MulXV(_,a[p],x.v);const A=x.id.cf;A.indexA=o,A.indexB=p,A.typeA=t.b2ContactFeatureType.e_face,A.typeB=t.b2ContactFeatureType.e_vertex;const S=e[1];C.MulXV(_,a[y],S.v);const V=S.id.cf;V.indexA=o,V.indexB=y,V.typeA=t.b2ContactFeatureType.e_face,V.typeB=t.b2ContactFeatureType.e_vertex}(A,c,d,y,u,p);const S=c.m_count,V=c.m_vertices,w=y,B=y+1<S?y+1:0,v=V[w],g=V[B],M=b.SubVV(g,v,re);M.Normalize();const I=b.CrossVOne(M,_e),D=b.MidVV(v,g,he),T=f.MulRV(d.q,M,ae),G=b.CrossVOne(T,me),P=C.MulXV(d,v,ce),L=C.MulXV(d,g,ue),R=b.DotVV(G,P),F=-b.DotVV(T,P)+_,k=b.DotVV(T,L)+_,q=se,J=ie;let z;if(z=b2ClipSegmentToLine(q,A,b.NegV(T,le),F,w),z<2)return;if(z=b2ClipSegmentToLine(J,q,T,k,B),z<2)return;e.localNormal.Copy(I),e.localPoint.Copy(D);let j=0;for(let t=0;t<2;++t){const s=J[t];if(b.DotVV(G,s.v)-R<=_){const t=e.points[j];if(C.MulTXV(p,s.v,t.localPoint),t.id.Copy(s.id),x){const e=t.id.cf;t.id.cf.indexA=e.indexB,t.id.cf.indexB=e.indexA,t.id.cf.typeA=e.typeB,t.id.cf.typeB=e.typeA}++j}}e.pointCount=j}class de extends M{constructor(){super(t.b2ShapeType.e_polygonShape,.01),this.m_centroid=new b(0,0),this.m_vertices=[],this.m_normals=[],this.m_count=0}Clone(){return(new de).Copy(this)}Copy(t){super.Copy(t),this.m_centroid.Copy(t.m_centroid),this.m_count=t.m_count,this.m_vertices=b.MakeArray(this.m_count),this.m_normals=b.MakeArray(this.m_count);for(let e=0;e<this.m_count;++e)this.m_vertices[e].Copy(t.m_vertices[e]),this.m_normals[e].Copy(t.m_normals[e]);return this}GetChildCount(){return 1}Set(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._Set(t=>({x:e[2*t],y:e[2*t+1]}),e.length/2)}{const e=t[0],s=t[1]||e.length;return this._Set(t=>e[t],s)}}_Set(t,e){if(e<3)return this.SetAsBox(1,1);let s=e;const i=[];for(let e=0;e<s;++e){const s=t(e);let n=!0;for(let t=0;t<i.length;++t)if(b.DistanceSquaredVV(s,i[t])<625e-8){n=!1;break}n&&i.push(s)}if(s=i.length,s<3)return this.SetAsBox(1,1);let n=0,o=i[0].x;for(let t=1;t<s;++t){const e=i[t].x;(e>o||e===o&&i[t].y<i[n].y)&&(n=t,o=e)}const r=[];let _=0,h=n;for(;;){r[_]=h;let t=0;for(let e=1;e<s;++e){if(t===h){t=e;continue}const s=b.SubVV(i[t],i[r[_]],de.Set_s_r),n=b.SubVV(i[e],i[r[_]],de.Set_s_v),o=b.CrossVV(s,n);o<0&&(t=e),0===o&&n.LengthSquared()>s.LengthSquared()&&(t=e)}if(++_,h=t,t===n)break}this.m_count=_,this.m_vertices=b.MakeArray(this.m_count),this.m_normals=b.MakeArray(this.m_count);for(let t=0;t<_;++t)this.m_vertices[t].Copy(i[r[t]]);for(let t=0;t<_;++t){const e=this.m_vertices[t],s=this.m_vertices[(t+1)%_],i=b.SubVV(s,e,b.s_t0);b.CrossVOne(i,this.m_normals[t]).SelfNormalize()}return de.ComputeCentroid(this.m_vertices,_,this.m_centroid),this}SetAsBox(t,e,s,i=0){if(this.m_count=4,this.m_vertices=b.MakeArray(this.m_count),this.m_normals=b.MakeArray(this.m_count),this.m_vertices[0].Set(-t,-e),this.m_vertices[1].Set(t,-e),this.m_vertices[2].Set(t,e),this.m_vertices[3].Set(-t,e),this.m_normals[0].Set(0,-1),this.m_normals[1].Set(1,0),this.m_normals[2].Set(0,1),this.m_normals[3].Set(-1,0),this.m_centroid.SetZero(),s){this.m_centroid.Copy(s);const t=new C;t.SetPosition(s),t.SetRotationAngle(i);for(let e=0;e<this.m_count;++e)C.MulXV(t,this.m_vertices[e],this.m_vertices[e]),f.MulRV(t.q,this.m_normals[e],this.m_normals[e])}return this}TestPoint(t,e){const s=C.MulTXV(t,e,de.TestPoint_s_pLocal);for(let t=0;t<this.m_count;++t){if(b.DotVV(this.m_normals[t],b.SubVV(s,this.m_vertices[t],b.s_t0))>0)return!1}return!0}RayCast(t,e,s,i){const n=C.MulTXV(s,e.p1,de.RayCast_s_p1),o=C.MulTXV(s,e.p2,de.RayCast_s_p2),r=b.SubVV(o,n,de.RayCast_s_d);let _=0,h=e.maxFraction,m=-1;for(let t=0;t<this.m_count;++t){const e=b.DotVV(this.m_normals[t],b.SubVV(this.m_vertices[t],n,b.s_t0)),s=b.DotVV(this.m_normals[t],r);if(0===s){if(e<0)return!1}else s<0&&e<_*s?(_=e/s,m=t):s>0&&e<h*s&&(h=e/s);if(h<_)return!1}return m>=0&&(t.fraction=_,f.MulRV(s.q,this.m_normals[m],t.normal),!0)}ComputeAABB(t,e,s){const i=C.MulXV(e,this.m_vertices[0],t.lowerBound),n=t.upperBound.Copy(i);for(let t=0;t<this.m_count;++t){const s=C.MulXV(e,this.m_vertices[t],de.ComputeAABB_s_v);b.MinV(s,i,i),b.MaxV(s,n,n)}const o=this.m_radius;i.SelfSubXY(o,o),n.SelfAddXY(o,o)}ComputeMass(t,e){const s=de.ComputeMass_s_center.SetZero();let i=0,n=0;const o=de.ComputeMass_s_s.Copy(this.m_vertices[0]);for(let t=0;t<this.m_count;++t){const e=b.SubVV(this.m_vertices[t],o,de.ComputeMass_s_e1),r=b.SubVV(this.m_vertices[(t+1)%this.m_count],o,de.ComputeMass_s_e2),_=b.CrossVV(e,r),h=.5*_;i+=h,s.SelfAdd(b.MulSV(h*(1/3),b.AddVV(e,r,b.s_t0),b.s_t1));const m=e.x,a=e.y,l=r.x,c=r.y;n+=1/3*.25*_*(m*m+l*m+l*l+(a*a+c*a+c*c))}t.mass=e*i,s.SelfMul(1/i),b.AddVV(s,o,t.center),t.I=e*n,t.I+=t.mass*(b.DotVV(t.center,t.center)-b.DotVV(s,s))}Validate(){for(let t=0;t<this.m_count;++t){const e=t,s=(t+1)%this.m_count,i=this.m_vertices[e],n=b.SubVV(this.m_vertices[s],i,de.Validate_s_e);for(let t=0;t<this.m_count;++t){if(t===e||t===s)continue;const o=b.SubVV(this.m_vertices[t],i,de.Validate_s_v);if(b.CrossVV(n,o)<0)return!1}}return!0}SetupDistanceProxy(t,e){t.m_vertices=this.m_vertices,t.m_count=this.m_count,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){const n=f.MulTRV(s.q,t,de.ComputeSubmergedArea_s_normalL),o=e-b.DotVV(t,s.p),r=[];let _=0,h=-1,m=-1,a=!1;for(let t=0;t<this.m_count;++t){r[t]=b.DotVV(n,this.m_vertices[t])-o;const e=r[t]<-1e-5;t>0&&(e?a||(h=t-1,_++):a&&(m=t-1,_++)),a=e}switch(_){case 0:if(a){const t=de.ComputeSubmergedArea_s_md;return this.ComputeMass(t,1),C.MulXV(s,t.center,i),t.mass}return 0;case 1:-1===h?h=this.m_count-1:m=this.m_count-1}const l=(h+1)%this.m_count,c=(m+1)%this.m_count,u=(0-r[h])/(r[l]-r[h]),d=(0-r[m])/(r[c]-r[m]),p=de.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[h].x*(1-u)+this.m_vertices[l].x*u,this.m_vertices[h].y*(1-u)+this.m_vertices[l].y*u),y=de.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[m].x*(1-d)+this.m_vertices[c].x*d,this.m_vertices[m].y*(1-d)+this.m_vertices[c].y*d);let x=0;const A=de.ComputeSubmergedArea_s_center.SetZero();let S,V=this.m_vertices[l],w=l;for(;w!==c;){w=(w+1)%this.m_count,S=w===c?y:this.m_vertices[w];const t=.5*((V.x-p.x)*(S.y-p.y)-(V.y-p.y)*(S.x-p.x));x+=t,A.x+=t*(p.x+V.x+S.x)/3,A.y+=t*(p.y+V.y+S.y)/3,V=S}return A.SelfMul(1/x),C.MulXV(s,A,i),x}Dump(t){t("    const shape: b2PolygonShape = new b2PolygonShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new b2Vec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.Set(vs, %d);\n",this.m_count)}static ComputeCentroid(t,e,s){const i=s;i.SetZero();let n=0;const o=de.ComputeCentroid_s_s.Copy(t[0]);for(let s=0;s<e;++s){const r=b.SubVV(t[0],o,de.ComputeCentroid_s_p1),_=b.SubVV(t[s],o,de.ComputeCentroid_s_p2),h=b.SubVV(t[(s+1)%e],o,de.ComputeCentroid_s_p3),m=b.SubVV(_,r,de.ComputeCentroid_s_e1),a=b.SubVV(h,r,de.ComputeCentroid_s_e2),l=.5*b.CrossVV(m,a);n+=l,i.x+=l*(1/3)*(r.x+_.x+h.x),i.y+=l*(1/3)*(r.y+_.y+h.y)}return i.x=1/n*i.x+o.x,i.y=1/n*i.y+o.y,i}}de.Set_s_r=new b,de.Set_s_v=new b,de.TestPoint_s_pLocal=new b,de.RayCast_s_p1=new b,de.RayCast_s_p2=new b,de.RayCast_s_d=new b,de.ComputeAABB_s_v=new b,de.ComputeMass_s_center=new b,de.ComputeMass_s_s=new b,de.ComputeMass_s_e1=new b,de.ComputeMass_s_e2=new b,de.Validate_s_e=new b,de.Validate_s_v=new b,de.ComputeSubmergedArea_s_normalL=new b,de.ComputeSubmergedArea_s_md=new v,de.ComputeSubmergedArea_s_intoVec=new b,de.ComputeSubmergedArea_s_outoVec=new b,de.ComputeSubmergedArea_s_center=new b,de.ComputeCentroid_s_s=new b,de.ComputeCentroid_s_p1=new b,de.ComputeCentroid_s_p2=new b,de.ComputeCentroid_s_p3=new b,de.ComputeCentroid_s_e1=new b,de.ComputeCentroid_s_e2=new b,t.b2_toiTime=0,t.b2_toiMaxTime=0,t.b2_toiCalls=0,t.b2_toiIters=0,t.b2_toiMaxIters=0,t.b2_toiRootIters=0,t.b2_toiMaxRootIters=0;const pe=new C,ye=new C,be=new b,xe=new b,Ae=new b,Se=new b,Ve=new b;class fe{constructor(){this.proxyA=new I,this.proxyB=new I,this.sweepA=new w,this.sweepB=new w,this.tMax=0}}var Ce,we;t.b2TOIOutputState=void 0,(Ce=t.b2TOIOutputState||(t.b2TOIOutputState={}))[Ce.e_unknown=0]="e_unknown",Ce[Ce.e_failed=1]="e_failed",Ce[Ce.e_overlapped=2]="e_overlapped",Ce[Ce.e_touching=3]="e_touching",Ce[Ce.e_separated=4]="e_separated";class Be{constructor(){this.state=t.b2TOIOutputState.e_unknown,this.t=0}}t.b2SeparationFunctionType=void 0,(we=t.b2SeparationFunctionType||(t.b2SeparationFunctionType={}))[we.e_unknown=-1]="e_unknown",we[we.e_points=0]="e_points",we[we.e_faceA=1]="e_faceA",we[we.e_faceB=2]="e_faceB";class ve{constructor(){this.m_sweepA=new w,this.m_sweepB=new w,this.m_type=t.b2SeparationFunctionType.e_unknown,this.m_localPoint=new b,this.m_axis=new b}Initialize(e,s,i,n,o,r){this.m_proxyA=s,this.m_proxyB=n;const _=e.count;this.m_sweepA.Copy(i),this.m_sweepB.Copy(o);const h=pe,m=ye;if(this.m_sweepA.GetTransform(h,r),this.m_sweepB.GetTransform(m,r),1===_){this.m_type=t.b2SeparationFunctionType.e_points;const s=this.m_proxyA.GetVertex(e.indexA[0]),i=this.m_proxyB.GetVertex(e.indexB[0]),n=C.MulXV(h,s,be),o=C.MulXV(m,i,xe);b.SubVV(o,n,this.m_axis);return this.m_axis.Normalize()}if(e.indexA[0]===e.indexA[1]){this.m_type=t.b2SeparationFunctionType.e_faceB;const s=this.m_proxyB.GetVertex(e.indexB[0]),i=this.m_proxyB.GetVertex(e.indexB[1]);b.CrossVOne(b.SubVV(i,s,b.s_t0),this.m_axis).SelfNormalize();const n=f.MulRV(m.q,this.m_axis,Ae);b.MidVV(s,i,this.m_localPoint);const o=C.MulXV(m,this.m_localPoint,xe),r=this.m_proxyA.GetVertex(e.indexA[0]),_=C.MulXV(h,r,be);let a=b.DotVV(b.SubVV(_,o,b.s_t0),n);return a<0&&(this.m_axis.SelfNeg(),a=-a),a}{this.m_type=t.b2SeparationFunctionType.e_faceA;const s=this.m_proxyA.GetVertex(e.indexA[0]),i=this.m_proxyA.GetVertex(e.indexA[1]);b.CrossVOne(b.SubVV(i,s,b.s_t0),this.m_axis).SelfNormalize();const n=f.MulRV(h.q,this.m_axis,Ae);b.MidVV(s,i,this.m_localPoint);const o=C.MulXV(h,this.m_localPoint,be),r=this.m_proxyB.GetVertex(e.indexB[0]),_=C.MulXV(m,r,xe);let a=b.DotVV(b.SubVV(_,o,b.s_t0),n);return a<0&&(this.m_axis.SelfNeg(),a=-a),a}}FindMinSeparation(e,s,i){const n=pe,o=ye;switch(this.m_sweepA.GetTransform(n,i),this.m_sweepB.GetTransform(o,i),this.m_type){case t.b2SeparationFunctionType.e_points:{const t=f.MulTRV(n.q,this.m_axis,Se),i=f.MulTRV(o.q,b.NegV(this.m_axis,b.s_t0),Ve);e[0]=this.m_proxyA.GetSupport(t),s[0]=this.m_proxyB.GetSupport(i);const r=this.m_proxyA.GetVertex(e[0]),_=this.m_proxyB.GetVertex(s[0]),h=C.MulXV(n,r,be),m=C.MulXV(o,_,xe);return b.DotVV(b.SubVV(m,h,b.s_t0),this.m_axis)}case t.b2SeparationFunctionType.e_faceA:{const t=f.MulRV(n.q,this.m_axis,Ae),i=C.MulXV(n,this.m_localPoint,be),r=f.MulTRV(o.q,b.NegV(t,b.s_t0),Ve);e[0]=-1,s[0]=this.m_proxyB.GetSupport(r);const _=this.m_proxyB.GetVertex(s[0]),h=C.MulXV(o,_,xe);return b.DotVV(b.SubVV(h,i,b.s_t0),t)}case t.b2SeparationFunctionType.e_faceB:{const t=f.MulRV(o.q,this.m_axis,Ae),i=C.MulXV(o,this.m_localPoint,xe),r=f.MulTRV(n.q,b.NegV(t,b.s_t0),Se);s[0]=-1,e[0]=this.m_proxyA.GetSupport(r);const _=this.m_proxyA.GetVertex(e[0]),h=C.MulXV(n,_,be);return b.DotVV(b.SubVV(h,i,b.s_t0),t)}default:return e[0]=-1,s[0]=-1,0}}Evaluate(e,s,i){const n=pe,o=ye;switch(this.m_sweepA.GetTransform(n,i),this.m_sweepB.GetTransform(o,i),this.m_type){case t.b2SeparationFunctionType.e_points:{const t=this.m_proxyA.GetVertex(e),i=this.m_proxyB.GetVertex(s),r=C.MulXV(n,t,be),_=C.MulXV(o,i,xe);return b.DotVV(b.SubVV(_,r,b.s_t0),this.m_axis)}case t.b2SeparationFunctionType.e_faceA:{const t=f.MulRV(n.q,this.m_axis,Ae),e=C.MulXV(n,this.m_localPoint,be),i=this.m_proxyB.GetVertex(s),r=C.MulXV(o,i,xe);return b.DotVV(b.SubVV(r,e,b.s_t0),t)}case t.b2SeparationFunctionType.e_faceB:{const t=f.MulRV(o.q,this.m_axis,Ae),s=C.MulXV(o,this.m_localPoint,xe),i=this.m_proxyA.GetVertex(e),r=C.MulXV(n,i,be);return b.DotVV(b.SubVV(r,s,b.s_t0),t)}default:return 0}}}const ge=new B,Me=new D,Ie=new T,De=new G,Te=new ve,Ge=[0],Pe=[0],Le=new w,Re=new w;function b2TimeOfImpact(e,s){const i=ge.Reset();++t.b2_toiCalls,e.state=t.b2TOIOutputState.e_unknown,e.t=s.tMax;const n=s.proxyA,o=s.proxyB,r=b2Max(8,b2Max(n.m_count,o.m_count)),_=Le.Copy(s.sweepA),m=Re.Copy(s.sweepB);_.Normalize(),m.Normalize();const a=s.tMax,l=b2Max(.005,n.m_radius+o.m_radius-.015);let c=0;let u=0;const d=Me;d.count=0;const p=Ie;for(p.proxyA.Copy(s.proxyA),p.proxyB.Copy(s.proxyB),p.useRadii=!1;;){const s=pe,i=ye;_.GetTransform(s,c),m.GetTransform(i,c),p.transformA.Copy(s),p.transformB.Copy(i);const y=De;if(b2Distance(y,d,p),y.distance<=0){e.state=t.b2TOIOutputState.e_overlapped,e.t=0;break}if(y.distance<l+.00125){e.state=t.b2TOIOutputState.e_touching,e.t=c;break}const b=Te;b.Initialize(d,n,_,o,m,c);let x=!1,A=a,S=0;for(;;){const s=Ge,i=Pe;let n=b.FindMinSeparation(s,i,A);if(n>l+.00125){e.state=t.b2TOIOutputState.e_separated,e.t=a,x=!0;break}if(n>l-.00125){c=A;break}let o=b.Evaluate(s[0],i[0],c);if(o<l-.00125){e.state=t.b2TOIOutputState.e_failed,e.t=c,x=!0;break}if(o<=l+.00125){e.state=t.b2TOIOutputState.e_touching,e.t=c,x=!0;break}let _=0,m=c,u=A;for(;;){let e=0;e=1&_?m+(l-o)*(u-m)/(n-o):.5*(m+u),++_,++t.b2_toiRootIters;const r=b.Evaluate(s[0],i[0],e);if(h(r-l)<.00125){A=e;break}if(r>l?(m=e,o=r):(u=e,n=r),50===_)break}if(t.b2_toiMaxRootIters=b2Max(t.b2_toiMaxRootIters,_),++S,S===r)break}if(++u,++t.b2_toiIters,x)break;if(20===u){e.state=t.b2TOIOutputState.e_failed,e.t=c;break}}t.b2_toiMaxIters=b2Max(t.b2_toiMaxIters,u);const y=i.GetMilliseconds();t.b2_toiMaxTime=b2Max(t.b2_toiMaxTime,y),t.b2_toiTime+=y}var Fe,ke;t.b2JointType=void 0,(Fe=t.b2JointType||(t.b2JointType={}))[Fe.e_unknownJoint=0]="e_unknownJoint",Fe[Fe.e_revoluteJoint=1]="e_revoluteJoint",Fe[Fe.e_prismaticJoint=2]="e_prismaticJoint",Fe[Fe.e_distanceJoint=3]="e_distanceJoint",Fe[Fe.e_pulleyJoint=4]="e_pulleyJoint",Fe[Fe.e_mouseJoint=5]="e_mouseJoint",Fe[Fe.e_gearJoint=6]="e_gearJoint",Fe[Fe.e_wheelJoint=7]="e_wheelJoint",Fe[Fe.e_weldJoint=8]="e_weldJoint",Fe[Fe.e_frictionJoint=9]="e_frictionJoint",Fe[Fe.e_ropeJoint=10]="e_ropeJoint",Fe[Fe.e_motorJoint=11]="e_motorJoint",Fe[Fe.e_areaJoint=12]="e_areaJoint";class qe{constructor(t){this._other=null,this.prev=null,this.next=null,this.joint=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class Je{constructor(e){this.type=t.b2JointType.e_unknownJoint,this.userData=null,this.collideConnected=!1,this.type=e}}class ze{constructor(e){this.m_type=t.b2JointType.e_unknownJoint,this.m_prev=null,this.m_next=null,this.m_edgeA=new qe(this),this.m_edgeB=new qe(this),this.m_index=0,this.m_islandFlag=!1,this.m_collideConnected=!1,this.m_userData=null,this.m_type=e.type,this.m_edgeA.other=e.bodyB,this.m_edgeB.other=e.bodyA,this.m_bodyA=e.bodyA,this.m_bodyB=e.bodyB,this.m_collideConnected=b2Maybe(e.collideConnected,!1),this.m_userData=b2Maybe(e.userData,null)}GetType(){return this.m_type}GetBodyA(){return this.m_bodyA}GetBodyB(){return this.m_bodyB}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}IsEnabled(){return this.m_bodyA.IsEnabled()&&this.m_bodyB.IsEnabled()}GetCollideConnected(){return this.m_collideConnected}Dump(t){t("// Dump is not supported for this joint type.\n")}ShiftOrigin(t){}Draw(e){const s=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),n=s.p,o=i.p,r=this.GetAnchorA(ze.Draw_s_p1),_=this.GetAnchorB(ze.Draw_s_p2),h=ze.Draw_s_color.SetRGB(.5,.8,.8);switch(this.m_type){case t.b2JointType.e_distanceJoint:e.DrawSegment(r,_,h);break;case t.b2JointType.e_pulleyJoint:{const t=this,s=t.GetGroundAnchorA(),i=t.GetGroundAnchorB();e.DrawSegment(s,r,h),e.DrawSegment(i,_,h),e.DrawSegment(s,i,h)}break;case t.b2JointType.e_mouseJoint:{const t=ze.Draw_s_c;t.Set(0,1,0),e.DrawPoint(r,4,t),e.DrawPoint(_,4,t),t.Set(.8,.8,.8),e.DrawSegment(r,_,t)}break;default:e.DrawSegment(n,r,h),e.DrawSegment(r,_,h),e.DrawSegment(o,_,h)}}}ze.Draw_s_p1=new b,ze.Draw_s_p2=new b,ze.Draw_s_color=new e(.5,.8,.8),ze.Draw_s_c=new e;class je extends Je{constructor(){super(t.b2JointType.e_distanceJoint),this.localAnchorA=new b,this.localAnchorB=new b,this.length=1,this.minLength=0,this.maxLength=i,this.stiffness=0,this.damping=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(i,this.localAnchorB),this.length=b2Max(b.DistanceVV(s,i),.005),this.minLength=this.length,this.maxLength=this.length}}class Oe extends ze{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_length=0,this.m_minLength=0,this.m_maxLength=0,this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_gamma=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_indexA=0,this.m_indexB=0,this.m_u=new b,this.m_rA=new b,this.m_rB=new b,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_currentLength=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_softMass=0,this.m_mass=0,this.m_qA=new f,this.m_qB=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_localAnchorA.Copy(b2Maybe(t.localAnchorA,b.ZERO)),this.m_localAnchorB.Copy(b2Maybe(t.localAnchorB,b.ZERO)),this.m_length=b2Max(b2Maybe(t.length,this.GetCurrentLength()),.005),this.m_minLength=b2Max(b2Maybe(t.minLength,this.m_length),.005),this.m_maxLength=b2Max(b2Maybe(t.maxLength,this.m_length),this.m_minLength),this.m_stiffness=b2Maybe(t.stiffness,0),this.m_damping=b2Maybe(t.damping,0)}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.x,e.y=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.y,e}GetReactionTorque(t){return 0}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetLength(t){return this.m_impulse=0,this.m_length=b2Max(.005,t),this.m_length}GetLength(){return this.m_length}SetMinLength(t){return this.m_lowerImpulse=0,this.m_minLength=b2Clamp(t,.005,this.m_maxLength),this.m_minLength}SetMaxLength(t){return this.m_upperImpulse=0,this.m_maxLength=b2Max(t,this.m_minLength),this.m_maxLength}GetCurrentLength(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,new b),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,new b);return b.DistanceVV(t,e)}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2DistanceJointDef = new b2DistanceJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.length = %.15f;\n",this.m_length),t("  jd.minLength = %.15f;\n",this.m_minLength),t("  jd.maxLength = %.15f;\n",this.m_maxLength),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,_=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const m=this.m_qA.SetAngle(s),a=this.m_qB.SetAngle(r);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),f.MulRV(m,this.m_lalcA,this.m_rA),b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),f.MulRV(a,this.m_lalcB,this.m_rB),this.m_u.x=o.x+this.m_rB.x-e.x-this.m_rA.x,this.m_u.y=o.y+this.m_rB.y-e.y-this.m_rA.y,this.m_currentLength=this.m_u.Length(),this.m_currentLength>.005?this.m_u.SelfMul(1/this.m_currentLength):(this.m_u.SetZero(),this.m_mass=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0);const l=b.CrossVV(this.m_rA,this.m_u),c=b.CrossVV(this.m_rB,this.m_u);let u=this.m_invMassA+this.m_invIA*l*l+this.m_invMassB+this.m_invIB*c*c;if(this.m_mass=0!==u?1/u:0,this.m_stiffness>0&&this.m_minLength<this.m_maxLength){const e=this.m_currentLength-this.m_length,s=this.m_damping,i=this.m_stiffness,n=t.step.dt;this.m_gamma=n*(s+n*i),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=e*n*i*this.m_gamma,u+=this.m_gamma,this.m_softMass=0!==u?1/u:0}else this.m_gamma=0,this.m_bias=0,this.m_softMass=this.m_mass;if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=b.MulSV(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse,this.m_u,Oe.InitVelocityConstraints_s_P);i.SelfMulSub(this.m_invMassA,e),n-=this.m_invIA*b.CrossVV(this.m_rA,e),_.SelfMulAdd(this.m_invMassB,e),h+=this.m_invIB*b.CrossVV(this.m_rB,e)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;if(this.m_minLength<this.m_maxLength){if(this.m_stiffness>0){const t=b.AddVCrossSV(e,s,this.m_rA,Oe.SolveVelocityConstraints_s_vpA),o=b.AddVCrossSV(i,n,this.m_rB,Oe.SolveVelocityConstraints_s_vpB),r=b.DotVV(this.m_u,b.SubVV(o,t,b.s_t0)),_=-this.m_softMass*(r+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=_;const h=b.MulSV(_,this.m_u,Oe.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,h),s-=this.m_invIA*b.CrossVV(this.m_rA,h),i.SelfMulAdd(this.m_invMassB,h),n+=this.m_invIB*b.CrossVV(this.m_rB,h)}{const o=b2Max(0,this.m_currentLength-this.m_minLength)*t.step.inv_dt,r=b.AddVCrossSV(e,s,this.m_rA,Oe.SolveVelocityConstraints_s_vpA),_=b.AddVCrossSV(i,n,this.m_rB,Oe.SolveVelocityConstraints_s_vpB),h=b.DotVV(this.m_u,b.SubVV(_,r,b.s_t0));let m=-this.m_mass*(h+o);const a=this.m_lowerImpulse;this.m_lowerImpulse=b2Max(0,this.m_lowerImpulse+m),m=this.m_lowerImpulse-a;const l=b.MulSV(m,this.m_u,Oe.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,l),s-=this.m_invIA*b.CrossVV(this.m_rA,l),i.SelfMulAdd(this.m_invMassB,l),n+=this.m_invIB*b.CrossVV(this.m_rB,l)}{const o=b2Max(0,this.m_maxLength-this.m_currentLength)*t.step.inv_dt,r=b.AddVCrossSV(e,s,this.m_rA,Oe.SolveVelocityConstraints_s_vpA),_=b.AddVCrossSV(i,n,this.m_rB,Oe.SolveVelocityConstraints_s_vpB),h=b.DotVV(this.m_u,b.SubVV(r,_,b.s_t0));let m=-this.m_mass*(h+o);const a=this.m_upperImpulse;this.m_upperImpulse=b2Max(0,this.m_upperImpulse+m),m=this.m_upperImpulse-a;const l=b.MulSV(-m,this.m_u,Oe.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,l),s-=this.m_invIA*b.CrossVV(this.m_rA,l),i.SelfMulAdd(this.m_invMassB,l),n+=this.m_invIB*b.CrossVV(this.m_rB,l)}}else{const t=b.AddVCrossSV(e,s,this.m_rA,Oe.SolveVelocityConstraints_s_vpA),o=b.AddVCrossSV(i,n,this.m_rB,Oe.SolveVelocityConstraints_s_vpB),r=b.DotVV(this.m_u,b.SubVV(o,t,b.s_t0)),_=-this.m_mass*r;this.m_impulse+=_;const h=b.MulSV(_,this.m_u,Oe.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,h),s-=this.m_invIA*b.CrossVV(this.m_rA,h),i.SelfMulAdd(this.m_invMassB,h),n+=this.m_invIB*b.CrossVV(this.m_rB,h)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n),_=f.MulRV(o,this.m_lalcA,this.m_rA),m=f.MulRV(r,this.m_lalcB,this.m_rB),a=this.m_u;a.x=i.x+m.x-e.x-_.x,a.y=i.y+m.y-e.y-_.y;const l=this.m_u.Normalize();let c;if(this.m_minLength==this.m_maxLength)c=l-this.m_minLength;else if(l<this.m_minLength)c=l-this.m_minLength;else{if(!(this.m_maxLength<l))return!0;c=l-this.m_maxLength}const u=-this.m_mass*c,d=b.MulSV(u,a,Oe.SolvePositionConstraints_s_P);return e.SelfMulSub(this.m_invMassA,d),s-=this.m_invIA*b.CrossVV(_,d),i.SelfMulAdd(this.m_invMassB,d),n+=this.m_invIB*b.CrossVV(m,d),t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,h(c)<.005}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),n=C.MulXV(e,this.m_localAnchorA,Oe.Draw_s_pA),o=C.MulXV(s,this.m_localAnchorB,Oe.Draw_s_pB),r=b.SubVV(o,n,Oe.Draw_s_axis);r.Normalize();const _=Oe.Draw_s_c1,h=Oe.Draw_s_c2,m=Oe.Draw_s_c3,a=Oe.Draw_s_c4;t.DrawSegment(n,o,a);const l=b.AddVMulSV(n,this.m_length,r,Oe.Draw_s_pRest);if(t.DrawPoint(l,8,_),this.m_minLength!=this.m_maxLength){if(this.m_minLength>.005){const e=b.AddVMulSV(n,this.m_minLength,r,Oe.Draw_s_pMin);t.DrawPoint(e,4,h)}if(this.m_maxLength<i){const e=b.AddVMulSV(n,this.m_maxLength,r,Oe.Draw_s_pMax);t.DrawPoint(e,4,m)}}}}Oe.InitVelocityConstraints_s_P=new b,Oe.SolveVelocityConstraints_s_vpA=new b,Oe.SolveVelocityConstraints_s_vpB=new b,Oe.SolveVelocityConstraints_s_P=new b,Oe.SolvePositionConstraints_s_P=new b,Oe.Draw_s_pA=new b,Oe.Draw_s_pB=new b,Oe.Draw_s_axis=new b,Oe.Draw_s_c1=new e(.7,.7,.7),Oe.Draw_s_c2=new e(.3,.9,.3),Oe.Draw_s_c3=new e(.9,.3,.3),Oe.Draw_s_c4=new e(.4,.4,.4),Oe.Draw_s_pRest=new b,Oe.Draw_s_pMin=new b,Oe.Draw_s_pMax=new b;class Ne extends ze{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_impulse=0,this.m_targetArea=0,this.m_delta=new b,this.m_bodies=t.bodies,this.m_stiffness=b2Maybe(t.stiffness,0),this.m_damping=b2Maybe(t.damping,0),this.m_targetLengths=b2MakeNumberArray(t.bodies.length),this.m_normals=b.MakeArray(t.bodies.length),this.m_joints=[],this.m_deltas=b.MakeArray(t.bodies.length);const e=new je;e.stiffness=this.m_stiffness,e.damping=this.m_damping,this.m_targetArea=0;for(let t=0;t<this.m_bodies.length;++t){const s=this.m_bodies[t],i=this.m_bodies[(t+1)%this.m_bodies.length],n=s.GetWorldCenter(),o=i.GetWorldCenter();this.m_targetLengths[t]=b.DistanceVV(n,o),this.m_targetArea+=b.CrossVV(n,o),e.Initialize(s,i,n,o),this.m_joints[t]=s.GetWorld().CreateJoint(e)}this.m_targetArea*=.5}GetAnchorA(t){return t}GetAnchorB(t){return t}GetReactionForce(t,e){return e}GetReactionTorque(t){return 0}SetStiffness(t){this.m_stiffness=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetStiffness(t)}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetDamping(t)}GetDamping(){return this.m_damping}Dump(t){t("Area joint dumping is not supported.\n")}InitVelocityConstraints(t){for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[(e+this.m_bodies.length-1)%this.m_bodies.length],i=this.m_bodies[(e+1)%this.m_bodies.length],n=t.positions[s.m_islandIndex].c,o=t.positions[i.m_islandIndex].c,r=this.m_deltas[e];b.SubVV(o,n,r)}if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],i=t.velocities[s.m_islandIndex].v,n=this.m_deltas[e];i.x+=s.m_invMass*n.y*.5*this.m_impulse,i.y+=s.m_invMass*-n.x*.5*this.m_impulse}}else this.m_impulse=0}SolveVelocityConstraints(t){let e=0,s=0;for(let i=0;i<this.m_bodies.length;++i){const n=this.m_bodies[i],o=t.velocities[n.m_islandIndex].v,r=this.m_deltas[i];e+=r.LengthSquared()/n.GetMass(),s+=b.CrossVV(o,r)}const i=-2*s/e;this.m_impulse+=i;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],n=t.velocities[s.m_islandIndex].v,o=this.m_deltas[e];n.x+=s.m_invMass*o.y*.5*i,n.y+=s.m_invMass*-o.x*.5*i}}SolvePositionConstraints(t){let e=0,s=0;for(let i=0;i<this.m_bodies.length;++i){const n=this.m_bodies[i],o=this.m_bodies[(i+1)%this.m_bodies.length],r=t.positions[n.m_islandIndex].c,_=t.positions[o.m_islandIndex].c,h=b.SubVV(_,r,this.m_delta);let m=h.Length();m<1e-5&&(m=1),this.m_normals[i].x=h.y/m,this.m_normals[i].y=-h.x/m,e+=m,s+=b.CrossVV(r,_)}s*=.5;const i=.5*(this.m_targetArea-s)/e;let n=!0;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],o=t.positions[s.m_islandIndex].c,r=(e+1)%this.m_bodies.length,_=b.AddVV(this.m_normals[e],this.m_normals[r],this.m_delta);_.SelfMul(i);const h=_.LengthSquared();h>b2Sq(.2)&&_.SelfMul(.2/a(h)),h>b2Sq(.005)&&(n=!1),o.x+=_.x,o.y+=_.y}return n}}class Xe{constructor(){this.categoryBits=1,this.maskBits=65535,this.groupIndex=0}Clone(){return(new Xe).Copy(this)}Copy(t){return this.categoryBits=t.categoryBits,this.maskBits=t.maskBits,this.groupIndex=t.groupIndex||0,this}}Xe.DEFAULT=new Xe;class Ee{constructor(){this.userData=null,this.friction=.2,this.restitution=0,this.restitutionThreshold=1,this.density=0,this.isSensor=!1,this.filter=new Xe}}class Ze{constructor(t,e){this.aabb=new ht,this.childIndex=0,this.fixture=t,this.childIndex=e,this.fixture.m_shape.ComputeAABB(this.aabb,this.fixture.m_body.GetTransform(),e),this.treeNode=this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb,this)}Reset(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode)}Touch(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode)}Synchronize(t,e){if(t===e)this.fixture.m_shape.ComputeAABB(this.aabb,t,this.childIndex),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,b.ZERO);else{const s=Ze.Synchronize_s_aabb1,i=Ze.Synchronize_s_aabb2;this.fixture.m_shape.ComputeAABB(s,t,this.childIndex),this.fixture.m_shape.ComputeAABB(i,e,this.childIndex),this.aabb.Combine2(s,i);const n=Ze.Synchronize_s_displacement;n.Copy(i.GetCenter()).SelfSub(s.GetCenter()),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,n)}}}Ze.Synchronize_s_aabb1=new ht,Ze.Synchronize_s_aabb2=new ht,Ze.Synchronize_s_displacement=new b;class We{constructor(t,e){this.m_density=0,this.m_next=null,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=1,this.m_proxies=[],this.m_filter=new Xe,this.m_isSensor=!1,this.m_userData=null,this.m_body=t,this.m_shape=e.shape.Clone(),this.m_userData=b2Maybe(e.userData,null),this.m_friction=b2Maybe(e.friction,.2),this.m_restitution=b2Maybe(e.restitution,0),this.m_restitutionThreshold=b2Maybe(e.restitutionThreshold,0),this.m_filter.Copy(b2Maybe(e.filter,Xe.DEFAULT)),this.m_isSensor=b2Maybe(e.isSensor,!1),this.m_density=b2Maybe(e.density,0)}get m_proxyCount(){return this.m_proxies.length}Create(t,e,s){}Destroy(){}Reset(){}GetType(){return this.m_shape.GetType()}GetShape(){return this.m_shape}SetSensor(t){t!==this.m_isSensor&&(this.m_body.SetAwake(!0),this.m_isSensor=t)}IsSensor(){return this.m_isSensor}SetFilterData(t){this.m_filter.Copy(t),this.Refilter()}GetFilterData(){return this.m_filter}Refilter(){let t=this.m_body.GetContactList();for(;t;){const e=t.contact,s=e.GetFixtureA(),i=e.GetFixtureB();s!==this&&i!==this||e.FlagForFiltering(),t=t.next}this.TouchProxies()}GetBody(){return this.m_body}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}TestPoint(t){return this.m_shape.TestPoint(this.m_body.GetTransform(),t)}RayCast(t,e,s){return this.m_shape.RayCast(t,e,this.m_body.GetTransform(),s)}GetMassData(t=new v){return this.m_shape.ComputeMass(t,this.m_density),t}SetDensity(t){this.m_density=t}GetDensity(){return this.m_density}GetFriction(){return this.m_friction}SetFriction(t){this.m_friction=t}GetRestitution(){return this.m_restitution}SetRestitution(t){this.m_restitution=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetAABB(t){return this.m_proxies[t].aabb}Dump(t,e){t("    const fd: b2FixtureDef = new b2FixtureDef();\n"),t("    fd.friction = %.15f;\n",this.m_friction),t("    fd.restitution = %.15f;\n",this.m_restitution),t("    fd.restitutionThreshold = %.15f;\n",this.m_restitutionThreshold),t("    fd.density = %.15f;\n",this.m_density),t("    fd.isSensor = %s;\n",this.m_isSensor?"true":"false"),t("    fd.filter.categoryBits = %d;\n",this.m_filter.categoryBits),t("    fd.filter.maskBits = %d;\n",this.m_filter.maskBits),t("    fd.filter.groupIndex = %d;\n",this.m_filter.groupIndex),this.m_shape.Dump(t),t("\n"),t("    fd.shape = shape;\n"),t("\n"),t("    bodies[%d].CreateFixture(fd);\n",e)}CreateProxies(){if(0!==this.m_proxies.length)throw new Error;for(let t=0;t<this.m_shape.GetChildCount();++t)this.m_proxies[t]=new Ze(this,t)}DestroyProxies(){for(const t of this.m_proxies)t.Reset();this.m_proxies.length=0}TouchProxies(){for(const t of this.m_proxies)t.Touch()}Synchronize(t,e,s){this.SynchronizeProxies(e,s)}SynchronizeProxies(t,e){for(const s of this.m_proxies)s.Synchronize(t,e)}}t.b2BodyType=void 0,(ke=t.b2BodyType||(t.b2BodyType={}))[ke.b2_unknown=-1]="b2_unknown",ke[ke.b2_staticBody=0]="b2_staticBody",ke[ke.b2_kinematicBody=1]="b2_kinematicBody",ke[ke.b2_dynamicBody=2]="b2_dynamicBody";class Qe{constructor(e,s){this.m_type=t.b2BodyType.b2_staticBody,this.m_islandFlag=!1,this.m_awakeFlag=!1,this.m_autoSleepFlag=!1,this.m_bulletFlag=!1,this.m_fixedRotationFlag=!1,this.m_enabledFlag=!1,this.m_toiFlag=!1,this.m_islandIndex=0,this.m_xf=new C,this.m_sweep=new w,this.m_linearVelocity=new b,this.m_angularVelocity=0,this.m_force=new b,this.m_torque=0,this.m_prev=null,this.m_next=null,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_jointList=null,this.m_contactList=null,this.m_mass=1,this.m_invMass=1,this.m_I=0,this.m_invI=0,this.m_linearDamping=0,this.m_angularDamping=0,this.m_gravityScale=1,this.m_sleepTime=0,this.m_userData=null,this.m_bulletFlag=b2Maybe(e.bullet,!1),this.m_fixedRotationFlag=b2Maybe(e.fixedRotation,!1),this.m_autoSleepFlag=b2Maybe(e.allowSleep,!0),b2Maybe(e.awake,!1)&&b2Maybe(e.type,t.b2BodyType.b2_staticBody)!==t.b2BodyType.b2_staticBody&&(this.m_awakeFlag=!0),this.m_enabledFlag=b2Maybe(e.enabled,!0),this.m_world=s,this.m_xf.p.Copy(b2Maybe(e.position,b.ZERO)),this.m_xf.q.SetAngle(b2Maybe(e.angle,0)),this.m_sweep.localCenter.SetZero(),this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),this.m_sweep.a0=this.m_sweep.a=this.m_xf.q.GetAngle(),this.m_sweep.alpha0=0,this.m_linearVelocity.Copy(b2Maybe(e.linearVelocity,b.ZERO)),this.m_angularVelocity=b2Maybe(e.angularVelocity,0),this.m_linearDamping=b2Maybe(e.linearDamping,0),this.m_angularDamping=b2Maybe(e.angularDamping,0),this.m_gravityScale=b2Maybe(e.gravityScale,1),this.m_force.SetZero(),this.m_torque=0,this.m_sleepTime=0,this.m_type=b2Maybe(e.type,t.b2BodyType.b2_staticBody),this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_userData=e.userData,this.m_fixtureList=null,this.m_fixtureCount=0}CreateFixture(t,e=0){return t instanceof M?this.CreateFixtureShapeDensity(t,e):this.CreateFixtureDef(t)}CreateFixtureDef(t){if(this.m_world.IsLocked())throw new Error;const e=new We(this,t);return this.m_enabledFlag&&e.CreateProxies(),e.m_next=this.m_fixtureList,this.m_fixtureList=e,++this.m_fixtureCount,e.m_density>0&&this.ResetMassData(),this.m_world.m_newContacts=!0,e}CreateFixtureShapeDensity(t,e=0){const s=Qe.CreateFixtureShapeDensity_s_def;return s.shape=t,s.density=e,this.CreateFixtureDef(s)}DestroyFixture(t){if(this.m_world.IsLocked())throw new Error;let e=this.m_fixtureList,s=null;for(;null!==e;){if(e===t){s?s.m_next=t.m_next:this.m_fixtureList=t.m_next;break}s=e,e=e.m_next}let i=this.m_contactList;for(;i;){const e=i.contact;i=i.next;const s=e.GetFixtureA(),n=e.GetFixtureB();t!==s&&t!==n||this.m_world.m_contactManager.Destroy(e)}this.m_enabledFlag&&t.DestroyProxies(),t.m_next=null,t.Reset(),--this.m_fixtureCount,this.ResetMassData()}SetTransformVec(t,e){this.SetTransformXY(t.x,t.y,e)}SetTransformXY(t,e,s){if(this.m_world.IsLocked())throw new Error;this.m_xf.q.SetAngle(s),this.m_xf.p.Set(t,e),C.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.a=s,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_sweep.a0=s;for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf);this.m_world.m_newContacts=!0}SetTransform(t,e){this.SetTransformXY(t.x,t.y,e)}GetTransform(){return this.m_xf}GetPosition(){return this.m_xf.p}SetPosition(t){this.SetTransformVec(t,this.GetAngle())}SetPositionXY(t,e){this.SetTransformXY(t,e,this.GetAngle())}GetAngle(){return this.m_sweep.a}SetAngle(t){this.SetTransformVec(this.GetPosition(),t)}GetWorldCenter(){return this.m_sweep.c}GetLocalCenter(){return this.m_sweep.localCenter}SetLinearVelocity(e){this.m_type!==t.b2BodyType.b2_staticBody&&(b.DotVV(e,e)>0&&this.SetAwake(!0),this.m_linearVelocity.Copy(e))}GetLinearVelocity(){return this.m_linearVelocity}SetAngularVelocity(e){this.m_type!==t.b2BodyType.b2_staticBody&&(e*e>0&&this.SetAwake(!0),this.m_angularVelocity=e)}GetAngularVelocity(){return this.m_angularVelocity}GetDefinition(t){return t.type=this.GetType(),t.allowSleep=this.m_autoSleepFlag,t.angle=this.GetAngle(),t.angularDamping=this.m_angularDamping,t.gravityScale=this.m_gravityScale,t.angularVelocity=this.m_angularVelocity,t.fixedRotation=this.m_fixedRotationFlag,t.bullet=this.m_bulletFlag,t.awake=this.m_awakeFlag,t.linearDamping=this.m_linearDamping,t.linearVelocity.Copy(this.GetLinearVelocity()),t.position.Copy(this.GetPosition()),t.userData=this.GetUserData(),t}ApplyForce(e,s,i=!0){this.m_type===t.b2BodyType.b2_dynamicBody&&(i&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=e.x,this.m_force.y+=e.y,this.m_torque+=(s.x-this.m_sweep.c.x)*e.y-(s.y-this.m_sweep.c.y)*e.x))}ApplyForceToCenter(e,s=!0){this.m_type===t.b2BodyType.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=e.x,this.m_force.y+=e.y))}ApplyTorque(e,s=!0){this.m_type===t.b2BodyType.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_torque+=e))}ApplyLinearImpulse(e,s,i=!0){this.m_type===t.b2BodyType.b2_dynamicBody&&(i&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*e.x,this.m_linearVelocity.y+=this.m_invMass*e.y,this.m_angularVelocity+=this.m_invI*((s.x-this.m_sweep.c.x)*e.y-(s.y-this.m_sweep.c.y)*e.x)))}ApplyLinearImpulseToCenter(e,s=!0){this.m_type===t.b2BodyType.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*e.x,this.m_linearVelocity.y+=this.m_invMass*e.y))}ApplyAngularImpulse(e,s=!0){this.m_type===t.b2BodyType.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_angularVelocity+=this.m_invI*e))}GetMass(){return this.m_mass}GetInertia(){return this.m_I+this.m_mass*b.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter)}GetMassData(t){return t.mass=this.m_mass,t.I=this.m_I+this.m_mass*b.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter),t.center.Copy(this.m_sweep.localCenter),t}SetMassData(e){if(this.m_world.IsLocked())throw new Error;if(this.m_type!==t.b2BodyType.b2_dynamicBody)return;this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_mass=e.mass,this.m_mass<=0&&(this.m_mass=1),this.m_invMass=1/this.m_mass,e.I>0&&!this.m_fixedRotationFlag&&(this.m_I=e.I-this.m_mass*b.DotVV(e.center,e.center),this.m_invI=1/this.m_I);const s=Qe.SetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(e.center),C.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),b.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,b.SubVV(this.m_sweep.c,s,b.s_t0),this.m_linearVelocity)}ResetMassData(){if(this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_sweep.localCenter.SetZero(),this.m_type===t.b2BodyType.b2_staticBody||this.m_type===t.b2BodyType.b2_kinematicBody)return this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),void(this.m_sweep.a0=this.m_sweep.a);const e=Qe.ResetMassData_s_localCenter.SetZero();for(let t=this.m_fixtureList;t;t=t.m_next){if(0===t.m_density)continue;const s=t.GetMassData(Qe.ResetMassData_s_massData);this.m_mass+=s.mass,e.x+=s.center.x*s.mass,e.y+=s.center.y*s.mass,this.m_I+=s.I}this.m_mass>0&&(this.m_invMass=1/this.m_mass,e.x*=this.m_invMass,e.y*=this.m_invMass),this.m_I>0&&!this.m_fixedRotationFlag?(this.m_I-=this.m_mass*b.DotVV(e,e),this.m_invI=1/this.m_I):(this.m_I=0,this.m_invI=0);const s=Qe.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(e),C.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),b.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,b.SubVV(this.m_sweep.c,s,b.s_t0),this.m_linearVelocity)}GetWorldPoint(t,e){return C.MulXV(this.m_xf,t,e)}GetWorldVector(t,e){return f.MulRV(this.m_xf.q,t,e)}GetLocalPoint(t,e){return C.MulTXV(this.m_xf,t,e)}GetLocalVector(t,e){return f.MulTRV(this.m_xf.q,t,e)}GetLinearVelocityFromWorldPoint(t,e){return b.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,b.SubVV(t,this.m_sweep.c,b.s_t0),e)}GetLinearVelocityFromLocalPoint(t,e){return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t,e),e)}GetLinearDamping(){return this.m_linearDamping}SetLinearDamping(t){this.m_linearDamping=t}GetAngularDamping(){return this.m_angularDamping}SetAngularDamping(t){this.m_angularDamping=t}GetGravityScale(){return this.m_gravityScale}SetGravityScale(t){this.m_gravityScale=t}SetType(e){if(this.m_world.IsLocked())throw new Error;if(this.m_type===e)return;this.m_type=e,this.ResetMassData(),this.m_type===t.b2BodyType.b2_staticBody&&(this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_sweep.a0=this.m_sweep.a,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_awakeFlag=!1,this.SynchronizeFixtures()),this.SetAwake(!0),this.m_force.SetZero(),this.m_torque=0;let s=this.m_contactList;for(;s;){const t=s;s=s.next,this.m_world.m_contactManager.Destroy(t.contact)}this.m_contactList=null;for(let t=this.m_fixtureList;t;t=t.m_next)t.TouchProxies()}GetType(){return this.m_type}SetBullet(t){this.m_bulletFlag=t}IsBullet(){return this.m_bulletFlag}SetSleepingAllowed(t){this.m_autoSleepFlag=t,t||this.SetAwake(!0)}IsSleepingAllowed(){return this.m_autoSleepFlag}SetAwake(e){this.m_type!==t.b2BodyType.b2_staticBody&&(e?(this.m_awakeFlag=!0,this.m_sleepTime=0):(this.m_awakeFlag=!1,this.m_sleepTime=0,this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_force.SetZero(),this.m_torque=0))}IsAwake(){return this.m_awakeFlag}SetEnabled(t){if(this.m_world.IsLocked())throw new Error;if(t!==this.IsEnabled())if(this.m_enabledFlag=t,t){for(let t=this.m_fixtureList;t;t=t.m_next)t.CreateProxies();this.m_world.m_newContacts=!0}else{for(let t=this.m_fixtureList;t;t=t.m_next)t.DestroyProxies();let t=this.m_contactList;for(;t;){const e=t;t=t.next,this.m_world.m_contactManager.Destroy(e.contact)}this.m_contactList=null}}IsEnabled(){return this.m_enabledFlag}SetFixedRotation(t){this.m_fixedRotationFlag!==t&&(this.m_fixedRotationFlag=t,this.m_angularVelocity=0,this.ResetMassData())}IsFixedRotation(){return this.m_fixedRotationFlag}GetFixtureList(){return this.m_fixtureList}GetJointList(){return this.m_jointList}GetContactList(){return this.m_contactList}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}GetWorld(){return this.m_world}Dump(e){const s=this.m_islandIndex;e("{\n"),e("  const bd: b2BodyDef = new b2BodyDef();\n");let i="";switch(this.m_type){case t.b2BodyType.b2_staticBody:i="b2BodyType.b2_staticBody";break;case t.b2BodyType.b2_kinematicBody:i="b2BodyType.b2_kinematicBody";break;case t.b2BodyType.b2_dynamicBody:i="b2BodyType.b2_dynamicBody"}e("  bd.type = %s;\n",i),e("  bd.position.Set(%.15f, %.15f);\n",this.m_xf.p.x,this.m_xf.p.y),e("  bd.angle = %.15f;\n",this.m_sweep.a),e("  bd.linearVelocity.Set(%.15f, %.15f);\n",this.m_linearVelocity.x,this.m_linearVelocity.y),e("  bd.angularVelocity = %.15f;\n",this.m_angularVelocity),e("  bd.linearDamping = %.15f;\n",this.m_linearDamping),e("  bd.angularDamping = %.15f;\n",this.m_angularDamping),e("  bd.allowSleep = %s;\n",this.m_autoSleepFlag?"true":"false"),e("  bd.awake = %s;\n",this.m_awakeFlag?"true":"false"),e("  bd.fixedRotation = %s;\n",this.m_fixedRotationFlag?"true":"false"),e("  bd.bullet = %s;\n",this.m_bulletFlag?"true":"false"),e("  bd.active = %s;\n",this.m_enabledFlag?"true":"false"),e("  bd.gravityScale = %.15f;\n",this.m_gravityScale),e("\n"),e("  bodies[%d] = this.m_world.CreateBody(bd);\n",this.m_islandIndex),e("\n");for(let t=this.m_fixtureList;t;t=t.m_next)e("  {\n"),t.Dump(e,s),e("  }\n");e("}\n")}SynchronizeFixtures(){if(this.m_awakeFlag){const t=Qe.SynchronizeFixtures_s_xf1;t.q.SetAngle(this.m_sweep.a0),f.MulRV(t.q,this.m_sweep.localCenter,t.p),b.SubVV(this.m_sweep.c0,t.p,t.p);for(let e=this.m_fixtureList;e;e=e.m_next)e.SynchronizeProxies(t,this.m_xf)}else for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf)}SynchronizeTransform(){this.m_xf.q.SetAngle(this.m_sweep.a),f.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),b.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}ShouldCollide(e){return(this.m_type!==t.b2BodyType.b2_staticBody||e.m_type!==t.b2BodyType.b2_staticBody)&&this.ShouldCollideConnected(e)}ShouldCollideConnected(t){for(let e=this.m_jointList;e;e=e.next)if(e.other===t&&!e.joint.m_collideConnected)return!1;return!0}Advance(t){this.m_sweep.Advance(t),this.m_sweep.c.Copy(this.m_sweep.c0),this.m_sweep.a=this.m_sweep.a0,this.m_xf.q.SetAngle(this.m_sweep.a),f.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),b.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}}function b2MixFriction(t,e){return a(t*e)}function b2MixRestitution(t,e){return t>e?t:e}function b2MixRestitutionThreshold(t,e){return t<e?t:e}Qe.CreateFixtureShapeDensity_s_def=new Ee,Qe.SetMassData_s_oldCenter=new b,Qe.ResetMassData_s_localCenter=new b,Qe.ResetMassData_s_oldCenter=new b,Qe.ResetMassData_s_massData=new v,Qe.SynchronizeFixtures_s_xf1=new C;class Ye{constructor(t){this._other=null,this.prev=null,this.next=null,this.contact=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class Ke{constructor(){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!1,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_prev=null,this.m_next=null,this.m_nodeA=new Ye(this),this.m_nodeB=new Ye(this),this.m_indexA=0,this.m_indexB=0,this.m_manifold=new it,this.m_toiCount=0,this.m_toi=0,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=0,this.m_tangentSpeed=0,this.m_oldManifold=new it}GetManifold(){return this.m_manifold}GetWorldManifold(t){const e=this.m_fixtureA.GetBody(),s=this.m_fixtureB.GetBody(),i=this.GetShapeA(),n=this.GetShapeB();t.Initialize(this.m_manifold,e.GetTransform(),i.m_radius,s.GetTransform(),n.m_radius)}IsTouching(){return this.m_touchingFlag}SetEnabled(t){this.m_enabledFlag=t}IsEnabled(){return this.m_enabledFlag}GetNext(){return this.m_next}GetFixtureA(){return this.m_fixtureA}GetChildIndexA(){return this.m_indexA}GetShapeA(){return this.m_fixtureA.GetShape()}GetFixtureB(){return this.m_fixtureB}GetChildIndexB(){return this.m_indexB}GetShapeB(){return this.m_fixtureB.GetShape()}FlagForFiltering(){this.m_filterFlag=!0}SetFriction(t){this.m_friction=t}GetFriction(){return this.m_friction}ResetFriction(){this.m_friction=b2MixFriction(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction)}SetRestitution(t){this.m_restitution=t}GetRestitution(){return this.m_restitution}ResetRestitution(){this.m_restitution=b2MixRestitution(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution)}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}ResetRestitutionThreshold(){this.m_restitutionThreshold=b2MixRestitutionThreshold(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}SetTangentSpeed(t){this.m_tangentSpeed=t}GetTangentSpeed(){return this.m_tangentSpeed}Reset(t,e,s,i){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!0,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_fixtureA=t,this.m_fixtureB=s,this.m_indexA=e,this.m_indexB=i,this.m_manifold.pointCount=0,this.m_prev=null,this.m_next=null,this.m_nodeA.Reset(),this.m_nodeB.Reset(),this.m_toiCount=0,this.m_friction=b2MixFriction(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction),this.m_restitution=b2MixRestitution(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution),this.m_restitutionThreshold=b2MixRestitutionThreshold(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}Update(t){const e=this.m_oldManifold;this.m_oldManifold=this.m_manifold,this.m_manifold=e,this.m_enabledFlag=!0;let s=!1;const i=this.m_touchingFlag,n=this.m_fixtureA.IsSensor(),o=this.m_fixtureB.IsSensor(),r=n||o,_=this.m_fixtureA.GetBody(),h=this.m_fixtureB.GetBody(),m=_.GetTransform(),a=h.GetTransform();if(r){const t=this.GetShapeA(),e=this.GetShapeB();s=b2TestOverlapShape(t,this.m_indexA,e,this.m_indexB,m,a),this.m_manifold.pointCount=0}else{this.Evaluate(this.m_manifold,m,a),s=this.m_manifold.pointCount>0;for(let t=0;t<this.m_manifold.pointCount;++t){const e=this.m_manifold.points[t];e.normalImpulse=0,e.tangentImpulse=0;const s=e.id;for(let t=0;t<this.m_oldManifold.pointCount;++t){const i=this.m_oldManifold.points[t];if(i.id.key===s.key){e.normalImpulse=i.normalImpulse,e.tangentImpulse=i.tangentImpulse;break}}}s!==i&&(_.SetAwake(!0),h.SetAwake(!0))}this.m_touchingFlag=s,!i&&s&&t&&t.BeginContact(this),i&&!s&&t&&t.EndContact(this),!r&&s&&t&&t.PreSolve(this,this.m_oldManifold)}ComputeTOI(t,e){const s=Ke.ComputeTOI_s_input;s.proxyA.SetShape(this.GetShapeA(),this.m_indexA),s.proxyB.SetShape(this.GetShapeB(),this.m_indexB),s.sweepA.Copy(t),s.sweepB.Copy(e),s.tMax=.005;const i=Ke.ComputeTOI_s_output;return b2TimeOfImpact(i,s),i.t}}Ke.ComputeTOI_s_input=new fe,Ke.ComputeTOI_s_output=new Be;class Ue extends Ke{static Create(){return new Ue}static Destroy(t){}Evaluate(t,e,s){const i=Ue.Evaluate_s_edge;this.GetShapeA().GetChildEdge(i,this.m_indexA),b2CollideEdgeAndCircle(t,i,e,this.GetShapeB(),s)}}Ue.Evaluate_s_edge=new yt;class He extends Ke{static Create(){return new He}static Destroy(t){}Evaluate(t,e,s){const i=He.Evaluate_s_edge;this.GetShapeA().GetChildEdge(i,this.m_indexA),b2CollideEdgeAndPolygon(t,i,e,this.GetShapeB(),s)}}He.Evaluate_s_edge=new yt;class $e extends Ke{static Create(){return new $e}static Destroy(t){}Evaluate(t,e,s){b2CollideCircles(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class ts extends Ke{static Create(){return new ts}static Destroy(t){}Evaluate(t,e,s){b2CollidePolygons(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class es extends Ke{static Create(){return new es}static Destroy(t){}Evaluate(t,e,s){b2CollidePolygonAndCircle(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class ss extends Ke{static Create(){return new ss}static Destroy(t){}Evaluate(t,e,s){b2CollideEdgeAndCircle(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class is extends Ke{static Create(){return new is}static Destroy(t){}Evaluate(t,e,s){b2CollideEdgeAndPolygon(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class ns{constructor(){this.pool=[],this.createFcn=null,this.destroyFcn=null,this.primary=!1}}class os{constructor(){this.m_registers=[],this.InitializeRegisters()}AddType(t,e,s,i){const n=[];function poolCreateFcn(){return n.pop()||t()}function poolDestroyFcn(t){n.push(t)}this.m_registers[s][i].pool=n,this.m_registers[s][i].createFcn=poolCreateFcn,this.m_registers[s][i].destroyFcn=poolDestroyFcn,this.m_registers[s][i].primary=!0,s!==i&&(this.m_registers[i][s].pool=n,this.m_registers[i][s].createFcn=poolCreateFcn,this.m_registers[i][s].destroyFcn=poolDestroyFcn,this.m_registers[i][s].primary=!1)}InitializeRegisters(){for(let e=0;e<t.b2ShapeType.e_shapeTypeCount;e++){this.m_registers[e]=[];for(let s=0;s<t.b2ShapeType.e_shapeTypeCount;s++)this.m_registers[e][s]=new ns}this.AddType($e.Create,$e.Destroy,t.b2ShapeType.e_circleShape,t.b2ShapeType.e_circleShape),this.AddType(es.Create,es.Destroy,t.b2ShapeType.e_polygonShape,t.b2ShapeType.e_circleShape),this.AddType(ts.Create,ts.Destroy,t.b2ShapeType.e_polygonShape,t.b2ShapeType.e_polygonShape),this.AddType(ss.Create,ss.Destroy,t.b2ShapeType.e_edgeShape,t.b2ShapeType.e_circleShape),this.AddType(is.Create,is.Destroy,t.b2ShapeType.e_edgeShape,t.b2ShapeType.e_polygonShape),this.AddType(Ue.Create,Ue.Destroy,t.b2ShapeType.e_chainShape,t.b2ShapeType.e_circleShape),this.AddType(He.Create,He.Destroy,t.b2ShapeType.e_chainShape,t.b2ShapeType.e_polygonShape)}Create(t,e,s,i){const n=t.GetType(),o=s.GetType(),r=this.m_registers[n][o];if(r.createFcn){const n=r.createFcn();return r.primary?n.Reset(t,e,s,i):n.Reset(s,i,t,e),n}return null}Destroy(t){const e=t.m_fixtureA.GetType(),s=t.m_fixtureB.GetType(),i=this.m_registers[e][s];i.destroyFcn&&i.destroyFcn(t)}}class rs{ShouldCollide(e,s){const i=e.GetBody(),n=s.GetBody();if(n.GetType()===t.b2BodyType.b2_staticBody&&i.GetType()===t.b2BodyType.b2_staticBody)return!1;if(!n.ShouldCollideConnected(i))return!1;const o=e.GetFilterData(),r=s.GetFilterData();if(o.groupIndex===r.groupIndex&&0!==o.groupIndex)return o.groupIndex>0;return 0!=(o.maskBits&r.categoryBits)&&0!=(o.categoryBits&r.maskBits)}}rs.b2_defaultFilter=new rs;class _s{constructor(){this.normalImpulses=b2MakeNumberArray(2),this.tangentImpulses=b2MakeNumberArray(2),this.count=0}}class hs{BeginContact(t){}EndContact(t){}PreSolve(t,e){}PostSolve(t,e){}}hs.b2_defaultListener=new hs;class ms{ReportFixture(t){return!0}}class as{ReportFixture(t,e,s,i){return i}}class ls{constructor(){this.m_broadPhase=new pt,this.m_contactList=null,this.m_contactCount=0,this.m_contactFilter=rs.b2_defaultFilter,this.m_contactListener=hs.b2_defaultListener,this.m_contactFactory=new os}AddPair(t,e){let s=t.fixture,i=e.fixture,n=t.childIndex,o=e.childIndex,r=s.GetBody(),_=i.GetBody();if(r===_)return;let h=_.GetContactList();for(;h;){if(h.other===r){const t=h.contact.GetFixtureA(),e=h.contact.GetFixtureB(),r=h.contact.GetChildIndexA(),_=h.contact.GetChildIndexB();if(t===s&&e===i&&r===n&&_===o)return;if(t===i&&e===s&&r===o&&_===n)return}h=h.next}if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(s,i))return;const m=this.m_contactFactory.Create(s,n,i,o);null!==m&&(s=m.GetFixtureA(),i=m.GetFixtureB(),n=m.GetChildIndexA(),o=m.GetChildIndexB(),r=s.m_body,_=i.m_body,m.m_prev=null,m.m_next=this.m_contactList,null!==this.m_contactList&&(this.m_contactList.m_prev=m),this.m_contactList=m,m.m_nodeA.other=_,m.m_nodeA.prev=null,m.m_nodeA.next=r.m_contactList,null!==r.m_contactList&&(r.m_contactList.prev=m.m_nodeA),r.m_contactList=m.m_nodeA,m.m_nodeB.other=r,m.m_nodeB.prev=null,m.m_nodeB.next=_.m_contactList,null!==_.m_contactList&&(_.m_contactList.prev=m.m_nodeB),_.m_contactList=m.m_nodeB,++this.m_contactCount)}FindNewContacts(){this.m_broadPhase.UpdatePairs((t,e)=>{this.AddPair(t,e)})}Destroy(t){const e=t.GetFixtureA(),s=t.GetFixtureB(),i=e.GetBody(),n=s.GetBody();this.m_contactListener&&t.IsTouching()&&this.m_contactListener.EndContact(t),t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_contactList&&(this.m_contactList=t.m_next),t.m_nodeA.prev&&(t.m_nodeA.prev.next=t.m_nodeA.next),t.m_nodeA.next&&(t.m_nodeA.next.prev=t.m_nodeA.prev),t.m_nodeA===i.m_contactList&&(i.m_contactList=t.m_nodeA.next),t.m_nodeB.prev&&(t.m_nodeB.prev.next=t.m_nodeB.next),t.m_nodeB.next&&(t.m_nodeB.next.prev=t.m_nodeB.prev),t.m_nodeB===n.m_contactList&&(n.m_contactList=t.m_nodeB.next),t.m_manifold.pointCount>0&&!e.IsSensor()&&!s.IsSensor()&&(e.GetBody().SetAwake(!0),s.GetBody().SetAwake(!0)),this.m_contactFactory.Destroy(t),--this.m_contactCount}Collide(){let e=this.m_contactList;for(;e;){const s=e.GetFixtureA(),i=e.GetFixtureB(),n=e.GetChildIndexA(),o=e.GetChildIndexB(),r=s.GetBody(),_=i.GetBody();if(e.m_filterFlag){if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(s,i)){const t=e;e=t.m_next,this.Destroy(t);continue}e.m_filterFlag=!1}const h=r.IsAwake()&&r.m_type!==t.b2BodyType.b2_staticBody,m=_.IsAwake()&&_.m_type!==t.b2BodyType.b2_staticBody;if(!h&&!m){e=e.m_next;continue}const a=s.m_proxies[n].treeNode,l=i.m_proxies[o].treeNode;if(b2TestOverlapAABB(a.aabb,l.aabb))e.Update(this.m_contactListener),e=e.m_next;else{const t=e;e=t.m_next,this.Destroy(t)}}}}class cs{constructor(){this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0}Reset(){return this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0,this}}class us{constructor(){this.dt=0,this.inv_dt=0,this.dtRatio=0,this.velocityIterations=0,this.positionIterations=0,this.warmStarting=!1}Copy(t){return this.dt=t.dt,this.inv_dt=t.inv_dt,this.dtRatio=t.dtRatio,this.positionIterations=t.positionIterations,this.velocityIterations=t.velocityIterations,this.warmStarting=t.warmStarting,this}}class ds{constructor(){this.c=new b,this.a=0}static MakeArray(t){return b2MakeArray(t,t=>new ds)}}class ps{constructor(){this.v=new b,this.w=0}static MakeArray(t){return b2MakeArray(t,t=>new ps)}}class ys{constructor(){this.step=new us}}t.g_blockSolve=!0;class bs{constructor(){this.rA=new b,this.rB=new b,this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.velocityBias=0}static MakeArray(t){return b2MakeArray(t,t=>new bs)}}class xs{constructor(){this.points=bs.MakeArray(2),this.normal=new b,this.tangent=new b,this.normalMass=new S,this.K=new S,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.invIA=0,this.invIB=0,this.friction=0,this.restitution=0,this.threshold=0,this.tangentSpeed=0,this.pointCount=0,this.contactIndex=0}static MakeArray(t){return b2MakeArray(t,t=>new xs)}}class As{constructor(){this.localPoints=b.MakeArray(2),this.localNormal=new b,this.localPoint=new b,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.localCenterA=new b,this.localCenterB=new b,this.invIA=0,this.invIB=0,this.type=t.b2ManifoldType.e_unknown,this.radiusA=0,this.radiusB=0,this.pointCount=0}static MakeArray(t){return b2MakeArray(t,t=>new As)}}class Ss{constructor(){this.step=new us,this.count=0}}class Vs{constructor(){this.normal=new b,this.point=new b,this.separation=0}Initialize(e,s,i,n){const o=Vs.Initialize_s_pointA,r=Vs.Initialize_s_pointB,_=Vs.Initialize_s_planePoint,h=Vs.Initialize_s_clipPoint;switch(e.type){case t.b2ManifoldType.e_circles:C.MulXV(s,e.localPoint,o),C.MulXV(i,e.localPoints[0],r),b.SubVV(r,o,this.normal).SelfNormalize(),b.MidVV(o,r,this.point),this.separation=b.DotVV(b.SubVV(r,o,b.s_t0),this.normal)-e.radiusA-e.radiusB;break;case t.b2ManifoldType.e_faceA:f.MulRV(s.q,e.localNormal,this.normal),C.MulXV(s,e.localPoint,_),C.MulXV(i,e.localPoints[n],h),this.separation=b.DotVV(b.SubVV(h,_,b.s_t0),this.normal)-e.radiusA-e.radiusB,this.point.Copy(h);break;case t.b2ManifoldType.e_faceB:f.MulRV(i.q,e.localNormal,this.normal),C.MulXV(i,e.localPoint,_),C.MulXV(s,e.localPoints[n],h),this.separation=b.DotVV(b.SubVV(h,_,b.s_t0),this.normal)-e.radiusA-e.radiusB,this.point.Copy(h),this.normal.SelfNeg()}}}Vs.Initialize_s_pointA=new b,Vs.Initialize_s_pointB=new b,Vs.Initialize_s_planePoint=new b,Vs.Initialize_s_clipPoint=new b;class fs{constructor(){this.m_step=new us,this.m_positionConstraints=As.MakeArray(1024),this.m_velocityConstraints=xs.MakeArray(1024),this.m_count=0}Initialize(t){if(this.m_step.Copy(t.step),this.m_count=t.count,this.m_positionConstraints.length<this.m_count){const t=b2Max(2*this.m_positionConstraints.length,this.m_count);for(;this.m_positionConstraints.length<t;)this.m_positionConstraints[this.m_positionConstraints.length]=new As}if(this.m_velocityConstraints.length<this.m_count){const t=b2Max(2*this.m_velocityConstraints.length,this.m_count);for(;this.m_velocityConstraints.length<t;)this.m_velocityConstraints[this.m_velocityConstraints.length]=new xs}this.m_positions=t.positions,this.m_velocities=t.velocities,this.m_contacts=t.contacts;for(let t=0;t<this.m_count;++t){const e=this.m_contacts[t],s=e.m_fixtureA,i=e.m_fixtureB,n=s.GetShape(),o=i.GetShape(),r=n.m_radius,_=o.m_radius,h=s.GetBody(),m=i.GetBody(),a=e.GetManifold(),l=a.pointCount,c=this.m_velocityConstraints[t];c.friction=e.m_friction,c.restitution=e.m_restitution,c.threshold=e.m_restitutionThreshold,c.tangentSpeed=e.m_tangentSpeed,c.indexA=h.m_islandIndex,c.indexB=m.m_islandIndex,c.invMassA=h.m_invMass,c.invMassB=m.m_invMass,c.invIA=h.m_invI,c.invIB=m.m_invI,c.contactIndex=t,c.pointCount=l,c.K.SetZero(),c.normalMass.SetZero();const u=this.m_positionConstraints[t];u.indexA=h.m_islandIndex,u.indexB=m.m_islandIndex,u.invMassA=h.m_invMass,u.invMassB=m.m_invMass,u.localCenterA.Copy(h.m_sweep.localCenter),u.localCenterB.Copy(m.m_sweep.localCenter),u.invIA=h.m_invI,u.invIB=m.m_invI,u.localNormal.Copy(a.localNormal),u.localPoint.Copy(a.localPoint),u.pointCount=l,u.radiusA=r,u.radiusB=_,u.type=a.type;for(let t=0;t<l;++t){const e=a.points[t],s=c.points[t];this.m_step.warmStarting?(s.normalImpulse=this.m_step.dtRatio*e.normalImpulse,s.tangentImpulse=this.m_step.dtRatio*e.tangentImpulse):(s.normalImpulse=0,s.tangentImpulse=0),s.rA.SetZero(),s.rB.SetZero(),s.normalMass=0,s.tangentMass=0,s.velocityBias=0,u.localPoints[t].Copy(e.localPoint)}}return this}InitializeVelocityConstraints(){const e=fs.InitializeVelocityConstraints_s_xfA,s=fs.InitializeVelocityConstraints_s_xfB,i=fs.InitializeVelocityConstraints_s_worldManifold;for(let n=0;n<this.m_count;++n){const o=this.m_velocityConstraints[n],r=this.m_positionConstraints[n],_=r.radiusA,h=r.radiusB,m=this.m_contacts[o.contactIndex].GetManifold(),a=o.indexA,l=o.indexB,c=o.invMassA,u=o.invMassB,d=o.invIA,p=o.invIB,y=r.localCenterA,x=r.localCenterB,A=this.m_positions[a].c,S=this.m_positions[a].a,V=this.m_velocities[a].v,C=this.m_velocities[a].w,w=this.m_positions[l].c,B=this.m_positions[l].a,v=this.m_velocities[l].v,g=this.m_velocities[l].w;e.q.SetAngle(S),s.q.SetAngle(B),b.SubVV(A,f.MulRV(e.q,y,b.s_t0),e.p),b.SubVV(w,f.MulRV(s.q,x,b.s_t0),s.p),i.Initialize(m,e,_,s,h),o.normal.Copy(i.normal),b.CrossVOne(o.normal,o.tangent);const M=o.pointCount;for(let t=0;t<M;++t){const e=o.points[t];b.SubVV(i.points[t],A,e.rA),b.SubVV(i.points[t],w,e.rB);const s=b.CrossVV(e.rA,o.normal),n=b.CrossVV(e.rB,o.normal),r=c+u+d*s*s+p*n*n;e.normalMass=r>0?1/r:0;const _=o.tangent,h=b.CrossVV(e.rA,_),m=b.CrossVV(e.rB,_),a=c+u+d*h*h+p*m*m;e.tangentMass=a>0?1/a:0,e.velocityBias=0;const l=b.DotVV(o.normal,b.SubVV(b.AddVCrossSV(v,g,e.rB,b.s_t0),b.AddVCrossSV(V,C,e.rA,b.s_t1),b.s_t0));l<-o.threshold&&(e.velocityBias+=-o.restitution*l)}if(2===o.pointCount&&t.g_blockSolve){const t=o.points[0],e=o.points[1],s=b.CrossVV(t.rA,o.normal),i=b.CrossVV(t.rB,o.normal),n=b.CrossVV(e.rA,o.normal),r=b.CrossVV(e.rB,o.normal),_=c+u+d*s*s+p*i*i,h=c+u+d*n*n+p*r*r,m=c+u+d*s*n+p*i*r;_*_<1e3*(_*h-m*m)?(o.K.ex.Set(_,m),o.K.ey.Set(m,h),o.K.GetInverse(o.normalMass)):o.pointCount=1}}}WarmStart(){const t=fs.WarmStart_s_P;for(let e=0;e<this.m_count;++e){const s=this.m_velocityConstraints[e],i=s.indexA,n=s.indexB,o=s.invMassA,r=s.invIA,_=s.invMassB,h=s.invIB,m=s.pointCount,a=this.m_velocities[i].v;let l=this.m_velocities[i].w;const c=this.m_velocities[n].v;let u=this.m_velocities[n].w;const d=s.normal,p=s.tangent;for(let e=0;e<m;++e){const i=s.points[e];b.AddVV(b.MulSV(i.normalImpulse,d,b.s_t0),b.MulSV(i.tangentImpulse,p,b.s_t1),t),l-=r*b.CrossVV(i.rA,t),a.SelfMulSub(o,t),u+=h*b.CrossVV(i.rB,t),c.SelfMulAdd(_,t)}this.m_velocities[i].w=l,this.m_velocities[n].w=u}}SolveVelocityConstraints(){const e=fs.SolveVelocityConstraints_s_dv,s=fs.SolveVelocityConstraints_s_dv1,i=fs.SolveVelocityConstraints_s_dv2,n=fs.SolveVelocityConstraints_s_P,o=fs.SolveVelocityConstraints_s_a,r=fs.SolveVelocityConstraints_s_b,_=fs.SolveVelocityConstraints_s_x,h=fs.SolveVelocityConstraints_s_d,m=fs.SolveVelocityConstraints_s_P1,a=fs.SolveVelocityConstraints_s_P2,l=fs.SolveVelocityConstraints_s_P1P2;for(let c=0;c<this.m_count;++c){const u=this.m_velocityConstraints[c],d=u.indexA,p=u.indexB,y=u.invMassA,x=u.invIA,A=u.invMassB,V=u.invIB,f=u.pointCount,C=this.m_velocities[d].v;let w=this.m_velocities[d].w;const B=this.m_velocities[p].v;let v=this.m_velocities[p].w;const g=u.normal,M=u.tangent,I=u.friction;for(let t=0;t<f;++t){const s=u.points[t];b.SubVV(b.AddVCrossSV(B,v,s.rB,b.s_t0),b.AddVCrossSV(C,w,s.rA,b.s_t1),e);const i=b.DotVV(e,M)-u.tangentSpeed;let o=s.tangentMass*-i;const r=I*s.normalImpulse,_=b2Clamp(s.tangentImpulse+o,-r,r);o=_-s.tangentImpulse,s.tangentImpulse=_,b.MulSV(o,M,n),C.SelfMulSub(y,n),w-=x*b.CrossVV(s.rA,n),B.SelfMulAdd(A,n),v+=V*b.CrossVV(s.rB,n)}if(1===u.pointCount||!1===t.g_blockSolve)for(let t=0;t<f;++t){const s=u.points[t];b.SubVV(b.AddVCrossSV(B,v,s.rB,b.s_t0),b.AddVCrossSV(C,w,s.rA,b.s_t1),e);const i=b.DotVV(e,g);let o=-s.normalMass*(i-s.velocityBias);const r=b2Max(s.normalImpulse+o,0);o=r-s.normalImpulse,s.normalImpulse=r,b.MulSV(o,g,n),C.SelfMulSub(y,n),w-=x*b.CrossVV(s.rA,n),B.SelfMulAdd(A,n),v+=V*b.CrossVV(s.rB,n)}else{const t=u.points[0],e=u.points[1];o.Set(t.normalImpulse,e.normalImpulse),b.SubVV(b.AddVCrossSV(B,v,t.rB,b.s_t0),b.AddVCrossSV(C,w,t.rA,b.s_t1),s),b.SubVV(b.AddVCrossSV(B,v,e.rB,b.s_t0),b.AddVCrossSV(C,w,e.rA,b.s_t1),i);let n=b.DotVV(s,g),c=b.DotVV(i,g);for(r.x=n-t.velocityBias,r.y=c-e.velocityBias,r.SelfSub(S.MulMV(u.K,o,b.s_t0));;){if(S.MulMV(u.normalMass,r,_).SelfNeg(),_.x>=0&&_.y>=0){b.SubVV(_,o,h),b.MulSV(h.x,g,m),b.MulSV(h.y,g,a),b.AddVV(m,a,l),C.SelfMulSub(y,l),w-=x*(b.CrossVV(t.rA,m)+b.CrossVV(e.rA,a)),B.SelfMulAdd(A,l),v+=V*(b.CrossVV(t.rB,m)+b.CrossVV(e.rB,a)),t.normalImpulse=_.x,e.normalImpulse=_.y;break}if(_.x=-t.normalMass*r.x,_.y=0,n=0,c=u.K.ex.y*_.x+r.y,_.x>=0&&c>=0){b.SubVV(_,o,h),b.MulSV(h.x,g,m),b.MulSV(h.y,g,a),b.AddVV(m,a,l),C.SelfMulSub(y,l),w-=x*(b.CrossVV(t.rA,m)+b.CrossVV(e.rA,a)),B.SelfMulAdd(A,l),v+=V*(b.CrossVV(t.rB,m)+b.CrossVV(e.rB,a)),t.normalImpulse=_.x,e.normalImpulse=_.y;break}if(_.x=0,_.y=-e.normalMass*r.y,n=u.K.ey.x*_.y+r.x,c=0,_.y>=0&&n>=0){b.SubVV(_,o,h),b.MulSV(h.x,g,m),b.MulSV(h.y,g,a),b.AddVV(m,a,l),C.SelfMulSub(y,l),w-=x*(b.CrossVV(t.rA,m)+b.CrossVV(e.rA,a)),B.SelfMulAdd(A,l),v+=V*(b.CrossVV(t.rB,m)+b.CrossVV(e.rB,a)),t.normalImpulse=_.x,e.normalImpulse=_.y;break}if(_.x=0,_.y=0,n=r.x,c=r.y,n>=0&&c>=0){b.SubVV(_,o,h),b.MulSV(h.x,g,m),b.MulSV(h.y,g,a),b.AddVV(m,a,l),C.SelfMulSub(y,l),w-=x*(b.CrossVV(t.rA,m)+b.CrossVV(e.rA,a)),B.SelfMulAdd(A,l),v+=V*(b.CrossVV(t.rB,m)+b.CrossVV(e.rB,a)),t.normalImpulse=_.x,e.normalImpulse=_.y;break}break}}this.m_velocities[d].w=w,this.m_velocities[p].w=v}}StoreImpulses(){for(let t=0;t<this.m_count;++t){const e=this.m_velocityConstraints[t],s=this.m_contacts[e.contactIndex].GetManifold();for(let t=0;t<e.pointCount;++t)s.points[t].normalImpulse=e.points[t].normalImpulse,s.points[t].tangentImpulse=e.points[t].tangentImpulse}}SolvePositionConstraints(){const t=fs.SolvePositionConstraints_s_xfA,e=fs.SolvePositionConstraints_s_xfB,s=fs.SolvePositionConstraints_s_psm,i=fs.SolvePositionConstraints_s_rA,n=fs.SolvePositionConstraints_s_rB,o=fs.SolvePositionConstraints_s_P;let r=0;for(let _=0;_<this.m_count;++_){const h=this.m_positionConstraints[_],m=h.indexA,a=h.indexB,l=h.localCenterA,c=h.invMassA,u=h.invIA,d=h.localCenterB,p=h.invMassB,y=h.invIB,x=h.pointCount,A=this.m_positions[m].c;let S=this.m_positions[m].a;const V=this.m_positions[a].c;let C=this.m_positions[a].a;for(let _=0;_<x;++_){t.q.SetAngle(S),e.q.SetAngle(C),b.SubVV(A,f.MulRV(t.q,l,b.s_t0),t.p),b.SubVV(V,f.MulRV(e.q,d,b.s_t0),e.p),s.Initialize(h,t,e,_);const m=s.normal,a=s.point,x=s.separation;b.SubVV(a,A,i),b.SubVV(a,V,n),r=b2Min(r,x);const w=b2Clamp(.2*(x+.005),-.2,0),B=b.CrossVV(i,m),v=b.CrossVV(n,m),g=c+p+u*B*B+y*v*v,M=g>0?-w/g:0;b.MulSV(M,m,o),A.SelfMulSub(c,o),S-=u*b.CrossVV(i,o),V.SelfMulAdd(p,o),C+=y*b.CrossVV(n,o)}this.m_positions[m].a=S,this.m_positions[a].a=C}return r>-.015}SolveTOIPositionConstraints(t,e){const s=fs.SolveTOIPositionConstraints_s_xfA,i=fs.SolveTOIPositionConstraints_s_xfB,n=fs.SolveTOIPositionConstraints_s_psm,o=fs.SolveTOIPositionConstraints_s_rA,r=fs.SolveTOIPositionConstraints_s_rB,_=fs.SolveTOIPositionConstraints_s_P;let h=0;for(let m=0;m<this.m_count;++m){const a=this.m_positionConstraints[m],l=a.indexA,c=a.indexB,u=a.localCenterA,d=a.localCenterB,p=a.pointCount;let y=0,x=0;l!==t&&l!==e||(y=a.invMassA,x=a.invIA);let A=0,S=0;c!==t&&c!==e||(A=a.invMassB,S=a.invIB);const V=this.m_positions[l].c;let C=this.m_positions[l].a;const w=this.m_positions[c].c;let B=this.m_positions[c].a;for(let t=0;t<p;++t){s.q.SetAngle(C),i.q.SetAngle(B),b.SubVV(V,f.MulRV(s.q,u,b.s_t0),s.p),b.SubVV(w,f.MulRV(i.q,d,b.s_t0),i.p),n.Initialize(a,s,i,t);const e=n.normal,m=n.point,l=n.separation;b.SubVV(m,V,o),b.SubVV(m,w,r),h=b2Min(h,l);const c=b2Clamp(.75*(l+.005),-.2,0),p=b.CrossVV(o,e),v=b.CrossVV(r,e),g=y+A+x*p*p+S*v*v,M=g>0?-c/g:0;b.MulSV(M,e,_),V.SelfMulSub(y,_),C-=x*b.CrossVV(o,_),w.SelfMulAdd(A,_),B+=S*b.CrossVV(r,_)}this.m_positions[l].a=C,this.m_positions[c].a=B}return h>=-.0075}}fs.InitializeVelocityConstraints_s_xfA=new C,fs.InitializeVelocityConstraints_s_xfB=new C,fs.InitializeVelocityConstraints_s_worldManifold=new nt,fs.WarmStart_s_P=new b,fs.SolveVelocityConstraints_s_dv=new b,fs.SolveVelocityConstraints_s_dv1=new b,fs.SolveVelocityConstraints_s_dv2=new b,fs.SolveVelocityConstraints_s_P=new b,fs.SolveVelocityConstraints_s_a=new b,fs.SolveVelocityConstraints_s_b=new b,fs.SolveVelocityConstraints_s_x=new b,fs.SolveVelocityConstraints_s_d=new b,fs.SolveVelocityConstraints_s_P1=new b,fs.SolveVelocityConstraints_s_P2=new b,fs.SolveVelocityConstraints_s_P1P2=new b,fs.SolvePositionConstraints_s_xfA=new C,fs.SolvePositionConstraints_s_xfB=new C,fs.SolvePositionConstraints_s_psm=new Vs,fs.SolvePositionConstraints_s_rA=new b,fs.SolvePositionConstraints_s_rB=new b,fs.SolvePositionConstraints_s_P=new b,fs.SolveTOIPositionConstraints_s_xfA=new C,fs.SolveTOIPositionConstraints_s_xfB=new C,fs.SolveTOIPositionConstraints_s_psm=new Vs,fs.SolveTOIPositionConstraints_s_rA=new b,fs.SolveTOIPositionConstraints_s_rB=new b,fs.SolveTOIPositionConstraints_s_P=new b;class Cs extends ze{constructor(t){super(t),this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_linearImpulse=new b,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new b,this.m_rB=new b,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new S,this.m_angularMass=0,this.m_qA=new f,this.m_qB=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_K=new S,this.m_localAnchorA.Copy(b2Maybe(t.localAnchorA,b.ZERO)),this.m_localAnchorB.Copy(b2Maybe(t.localAnchorB,b.ZERO)),this.m_linearImpulse.SetZero(),this.m_maxForce=b2Maybe(t.maxForce,0),this.m_maxTorque=b2Maybe(t.maxTorque,0),this.m_linearMass.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,o=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const _=this.m_qA.SetAngle(e),h=this.m_qB.SetAngle(n);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const m=f.MulRV(_,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const a=f.MulRV(h,this.m_lalcB,this.m_rB),l=this.m_invMassA,c=this.m_invMassB,u=this.m_invIA,d=this.m_invIB,p=this.m_K;if(p.ex.x=l+c+u*m.y*m.y+d*a.y*a.y,p.ex.y=-u*m.x*m.y-d*a.x*a.y,p.ey.x=p.ex.y,p.ey.y=l+c+u*m.x*m.x+d*a.x*a.x,p.GetInverse(this.m_linearMass),this.m_angularMass=u+d,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;s.SelfMulSub(l,e),i-=u*(b.CrossVV(this.m_rA,e)+this.m_angularImpulse),o.SelfMulAdd(c,e),r+=d*(b.CrossVV(this.m_rB,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,_=this.m_invIA,h=this.m_invIB,m=t.step.dt;{const t=n-s;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,o=m*this.m_maxTorque;this.m_angularImpulse=b2Clamp(this.m_angularImpulse+e,-o,o),e=this.m_angularImpulse-i,s-=_*e,n+=h*e}{const t=b.SubVV(b.AddVCrossSV(i,n,this.m_rB,b.s_t0),b.AddVCrossSV(e,s,this.m_rA,b.s_t1),Cs.SolveVelocityConstraints_s_Cdot_v2),a=S.MulMV(this.m_linearMass,t,Cs.SolveVelocityConstraints_s_impulseV).SelfNeg(),l=Cs.SolveVelocityConstraints_s_oldImpulseV.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(a);const c=m*this.m_maxForce;this.m_linearImpulse.LengthSquared()>c*c&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(c)),b.SubVV(this.m_linearImpulse,l,a),e.SelfMulSub(o,a),s-=_*b.CrossVV(this.m_rA,a),i.SelfMulAdd(r,a),n+=h*b.CrossVV(this.m_rB,a)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_linearImpulse.x,e.y=t*this.m_linearImpulse.y,e}GetReactionTorque(t){return t*this.m_angularImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2FrictionJointDef = new b2FrictionJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}Cs.SolveVelocityConstraints_s_Cdot_v2=new b,Cs.SolveVelocityConstraints_s_impulseV=new b,Cs.SolveVelocityConstraints_s_oldImpulseV=new b;class ws extends ze{constructor(e){let s,i;super(e),this.m_typeA=t.b2JointType.e_unknownJoint,this.m_typeB=t.b2JointType.e_unknownJoint,this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_localAnchorC=new b,this.m_localAnchorD=new b,this.m_localAxisC=new b,this.m_localAxisD=new b,this.m_referenceAngleA=0,this.m_referenceAngleB=0,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_indexC=0,this.m_indexD=0,this.m_lcA=new b,this.m_lcB=new b,this.m_lcC=new b,this.m_lcD=new b,this.m_mA=0,this.m_mB=0,this.m_mC=0,this.m_mD=0,this.m_iA=0,this.m_iB=0,this.m_iC=0,this.m_iD=0,this.m_JvAC=new b,this.m_JvBD=new b,this.m_JwA=0,this.m_JwB=0,this.m_JwC=0,this.m_JwD=0,this.m_mass=0,this.m_qA=new f,this.m_qB=new f,this.m_qC=new f,this.m_qD=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_lalcC=new b,this.m_lalcD=new b,this.m_joint1=e.joint1,this.m_joint2=e.joint2,this.m_typeA=this.m_joint1.GetType(),this.m_typeB=this.m_joint2.GetType(),this.m_bodyC=this.m_joint1.GetBodyA(),this.m_bodyA=this.m_joint1.GetBodyB();const n=this.m_bodyA.m_xf,o=this.m_bodyA.m_sweep.a,r=this.m_bodyC.m_xf,_=this.m_bodyC.m_sweep.a;if(this.m_typeA===t.b2JointType.e_revoluteJoint){const t=e.joint1;this.m_localAnchorC.Copy(t.m_localAnchorA),this.m_localAnchorA.Copy(t.m_localAnchorB),this.m_referenceAngleA=t.m_referenceAngle,this.m_localAxisC.SetZero(),s=o-_-this.m_referenceAngleA}else{const t=e.joint1;this.m_localAnchorC.Copy(t.m_localAnchorA),this.m_localAnchorA.Copy(t.m_localAnchorB),this.m_referenceAngleA=t.m_referenceAngle,this.m_localAxisC.Copy(t.m_localXAxisA);const i=this.m_localAnchorC,o=f.MulTRV(r.q,b.AddVV(f.MulRV(n.q,this.m_localAnchorA,b.s_t0),b.SubVV(n.p,r.p,b.s_t1),b.s_t0),b.s_t0);s=b.DotVV(b.SubVV(o,i,b.s_t0),this.m_localAxisC)}this.m_bodyD=this.m_joint2.GetBodyA(),this.m_bodyB=this.m_joint2.GetBodyB();const h=this.m_bodyB.m_xf,m=this.m_bodyB.m_sweep.a,a=this.m_bodyD.m_xf,l=this.m_bodyD.m_sweep.a;if(this.m_typeB===t.b2JointType.e_revoluteJoint){const t=e.joint2;this.m_localAnchorD.Copy(t.m_localAnchorA),this.m_localAnchorB.Copy(t.m_localAnchorB),this.m_referenceAngleB=t.m_referenceAngle,this.m_localAxisD.SetZero(),i=m-l-this.m_referenceAngleB}else{const t=e.joint2;this.m_localAnchorD.Copy(t.m_localAnchorA),this.m_localAnchorB.Copy(t.m_localAnchorB),this.m_referenceAngleB=t.m_referenceAngle,this.m_localAxisD.Copy(t.m_localXAxisA);const s=this.m_localAnchorD,n=f.MulTRV(a.q,b.AddVV(f.MulRV(h.q,this.m_localAnchorB,b.s_t0),b.SubVV(h.p,a.p,b.s_t1),b.s_t0),b.s_t0);i=b.DotVV(b.SubVV(n,s,b.s_t0),this.m_localAxisD)}this.m_ratio=b2Maybe(e.ratio,1),this.m_constant=s+this.m_ratio*i,this.m_impulse=0}InitVelocityConstraints(e){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_indexC=this.m_bodyC.m_islandIndex,this.m_indexD=this.m_bodyD.m_islandIndex,this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter),this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter),this.m_mA=this.m_bodyA.m_invMass,this.m_mB=this.m_bodyB.m_invMass,this.m_mC=this.m_bodyC.m_invMass,this.m_mD=this.m_bodyD.m_invMass,this.m_iA=this.m_bodyA.m_invI,this.m_iB=this.m_bodyB.m_invI,this.m_iC=this.m_bodyC.m_invI,this.m_iD=this.m_bodyD.m_invI;const s=e.positions[this.m_indexA].a,i=e.velocities[this.m_indexA].v;let n=e.velocities[this.m_indexA].w;const o=e.positions[this.m_indexB].a,r=e.velocities[this.m_indexB].v;let _=e.velocities[this.m_indexB].w;const h=e.positions[this.m_indexC].a,m=e.velocities[this.m_indexC].v;let a=e.velocities[this.m_indexC].w;const l=e.positions[this.m_indexD].a,c=e.velocities[this.m_indexD].v;let u=e.velocities[this.m_indexD].w;const d=this.m_qA.SetAngle(s),p=this.m_qB.SetAngle(o),y=this.m_qC.SetAngle(h),x=this.m_qD.SetAngle(l);if(this.m_mass=0,this.m_typeA===t.b2JointType.e_revoluteJoint)this.m_JvAC.SetZero(),this.m_JwA=1,this.m_JwC=1,this.m_mass+=this.m_iA+this.m_iC;else{const t=f.MulRV(y,this.m_localAxisC,ws.InitVelocityConstraints_s_u);b.SubVV(this.m_localAnchorC,this.m_lcC,this.m_lalcC);const e=f.MulRV(y,this.m_lalcC,ws.InitVelocityConstraints_s_rC);b.SubVV(this.m_localAnchorA,this.m_lcA,this.m_lalcA);const s=f.MulRV(d,this.m_lalcA,ws.InitVelocityConstraints_s_rA);this.m_JvAC.Copy(t),this.m_JwC=b.CrossVV(e,t),this.m_JwA=b.CrossVV(s,t),this.m_mass+=this.m_mC+this.m_mA+this.m_iC*this.m_JwC*this.m_JwC+this.m_iA*this.m_JwA*this.m_JwA}if(this.m_typeB===t.b2JointType.e_revoluteJoint)this.m_JvBD.SetZero(),this.m_JwB=this.m_ratio,this.m_JwD=this.m_ratio,this.m_mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);else{const t=f.MulRV(x,this.m_localAxisD,ws.InitVelocityConstraints_s_u);b.SubVV(this.m_localAnchorD,this.m_lcD,this.m_lalcD);const e=f.MulRV(x,this.m_lalcD,ws.InitVelocityConstraints_s_rD);b.SubVV(this.m_localAnchorB,this.m_lcB,this.m_lalcB);const s=f.MulRV(p,this.m_lalcB,ws.InitVelocityConstraints_s_rB);b.MulSV(this.m_ratio,t,this.m_JvBD),this.m_JwD=this.m_ratio*b.CrossVV(e,t),this.m_JwB=this.m_ratio*b.CrossVV(s,t),this.m_mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*this.m_JwD*this.m_JwD+this.m_iB*this.m_JwB*this.m_JwB}this.m_mass=this.m_mass>0?1/this.m_mass:0,e.step.warmStarting?(i.SelfMulAdd(this.m_mA*this.m_impulse,this.m_JvAC),n+=this.m_iA*this.m_impulse*this.m_JwA,r.SelfMulAdd(this.m_mB*this.m_impulse,this.m_JvBD),_+=this.m_iB*this.m_impulse*this.m_JwB,m.SelfMulSub(this.m_mC*this.m_impulse,this.m_JvAC),a-=this.m_iC*this.m_impulse*this.m_JwC,c.SelfMulSub(this.m_mD*this.m_impulse,this.m_JvBD),u-=this.m_iD*this.m_impulse*this.m_JwD):this.m_impulse=0,e.velocities[this.m_indexA].w=n,e.velocities[this.m_indexB].w=_,e.velocities[this.m_indexC].w=a,e.velocities[this.m_indexD].w=u}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=t.velocities[this.m_indexC].v;let r=t.velocities[this.m_indexC].w;const _=t.velocities[this.m_indexD].v;let h=t.velocities[this.m_indexD].w,m=b.DotVV(this.m_JvAC,b.SubVV(e,o,b.s_t0))+b.DotVV(this.m_JvBD,b.SubVV(i,_,b.s_t0));m+=this.m_JwA*s-this.m_JwC*r+(this.m_JwB*n-this.m_JwD*h);const a=-this.m_mass*m;this.m_impulse+=a,e.SelfMulAdd(this.m_mA*a,this.m_JvAC),s+=this.m_iA*a*this.m_JwA,i.SelfMulAdd(this.m_mB*a,this.m_JvBD),n+=this.m_iB*a*this.m_JwB,o.SelfMulSub(this.m_mC*a,this.m_JvAC),r-=this.m_iC*a*this.m_JwC,_.SelfMulSub(this.m_mD*a,this.m_JvBD),h-=this.m_iD*a*this.m_JwD,t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n,t.velocities[this.m_indexC].w=r,t.velocities[this.m_indexD].w=h}SolvePositionConstraints(e){const s=e.positions[this.m_indexA].c;let i=e.positions[this.m_indexA].a;const n=e.positions[this.m_indexB].c;let o=e.positions[this.m_indexB].a;const r=e.positions[this.m_indexC].c;let _=e.positions[this.m_indexC].a;const h=e.positions[this.m_indexD].c;let m=e.positions[this.m_indexD].a;const a=this.m_qA.SetAngle(i),l=this.m_qB.SetAngle(o),c=this.m_qC.SetAngle(_),u=this.m_qD.SetAngle(m);let d,p;const y=this.m_JvAC,x=this.m_JvBD;let A,S,V,C,w=0;if(this.m_typeA===t.b2JointType.e_revoluteJoint)y.SetZero(),A=1,V=1,w+=this.m_iA+this.m_iC,d=i-_-this.m_referenceAngleA;else{const t=f.MulRV(c,this.m_localAxisC,ws.SolvePositionConstraints_s_u),e=f.MulRV(c,this.m_lalcC,ws.SolvePositionConstraints_s_rC),i=f.MulRV(a,this.m_lalcA,ws.SolvePositionConstraints_s_rA);y.Copy(t),V=b.CrossVV(e,t),A=b.CrossVV(i,t),w+=this.m_mC+this.m_mA+this.m_iC*V*V+this.m_iA*A*A;const n=this.m_lalcC,o=f.MulTRV(c,b.AddVV(i,b.SubVV(s,r,b.s_t0),b.s_t0),b.s_t0);d=b.DotVV(b.SubVV(o,n,b.s_t0),this.m_localAxisC)}if(this.m_typeB===t.b2JointType.e_revoluteJoint)x.SetZero(),S=this.m_ratio,C=this.m_ratio,w+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD),p=o-m-this.m_referenceAngleB;else{const t=f.MulRV(u,this.m_localAxisD,ws.SolvePositionConstraints_s_u),e=f.MulRV(u,this.m_lalcD,ws.SolvePositionConstraints_s_rD),s=f.MulRV(l,this.m_lalcB,ws.SolvePositionConstraints_s_rB);b.MulSV(this.m_ratio,t,x),C=this.m_ratio*b.CrossVV(e,t),S=this.m_ratio*b.CrossVV(s,t),w+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*C*C+this.m_iB*S*S;const i=this.m_lalcD,o=f.MulTRV(u,b.AddVV(s,b.SubVV(n,h,b.s_t0),b.s_t0),b.s_t0);p=b.DotVV(b.SubVV(o,i,b.s_t0),this.m_localAxisD)}const B=d+this.m_ratio*p-this.m_constant;let v=0;return w>0&&(v=-B/w),s.SelfMulAdd(this.m_mA*v,y),i+=this.m_iA*v*A,n.SelfMulAdd(this.m_mB*v,x),o+=this.m_iB*v*S,r.SelfMulSub(this.m_mC*v,y),_-=this.m_iC*v*V,h.SelfMulSub(this.m_mD*v,x),m-=this.m_iD*v*C,e.positions[this.m_indexA].a=i,e.positions[this.m_indexB].a=o,e.positions[this.m_indexC].a=_,e.positions[this.m_indexD].a=m,!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return b.MulSV(t*this.m_impulse,this.m_JvAC,e)}GetReactionTorque(t){return t*this.m_impulse*this.m_JwA}GetJoint1(){return this.m_joint1}GetJoint2(){return this.m_joint2}GetRatio(){return this.m_ratio}SetRatio(t){this.m_ratio=t}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex,i=this.m_joint1.m_index,n=this.m_joint2.m_index;t("  const jd: b2GearJointDef = new b2GearJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.joint1 = joints[%d];\n",i),t("  jd.joint2 = joints[%d];\n",n),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}ws.InitVelocityConstraints_s_u=new b,ws.InitVelocityConstraints_s_rA=new b,ws.InitVelocityConstraints_s_rB=new b,ws.InitVelocityConstraints_s_rC=new b,ws.InitVelocityConstraints_s_rD=new b,ws.SolvePositionConstraints_s_u=new b,ws.SolvePositionConstraints_s_rA=new b,ws.SolvePositionConstraints_s_rB=new b,ws.SolvePositionConstraints_s_rC=new b,ws.SolvePositionConstraints_s_rD=new b;class Bs{constructor(){this.m_bodies=[],this.m_contacts=[],this.m_joints=[],this.m_positions=ds.MakeArray(1024),this.m_velocities=ps.MakeArray(1024),this.m_bodyCount=0,this.m_jointCount=0,this.m_contactCount=0,this.m_bodyCapacity=0,this.m_contactCapacity=0,this.m_jointCapacity=0}Initialize(t,e,s,i){if(this.m_bodyCapacity=t,this.m_contactCapacity=e,this.m_jointCapacity=s,this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0,this.m_listener=i,this.m_positions.length<t){const e=b2Max(2*this.m_positions.length,t);for(;this.m_positions.length<e;)this.m_positions[this.m_positions.length]=new ds}if(this.m_velocities.length<t){const e=b2Max(2*this.m_velocities.length,t);for(;this.m_velocities.length<e;)this.m_velocities[this.m_velocities.length]=new ps}}Clear(){this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0}AddBody(t){t.m_islandIndex=this.m_bodyCount,this.m_bodies[this.m_bodyCount++]=t}AddContact(t){this.m_contacts[this.m_contactCount++]=t}AddJoint(t){this.m_joints[this.m_jointCount++]=t}Solve(e,s,n,o){const r=Bs.s_timer.Reset(),_=s.dt;for(let e=0;e<this.m_bodyCount;++e){const s=this.m_bodies[e];this.m_positions[e].c.Copy(s.m_sweep.c);const i=s.m_sweep.a,o=this.m_velocities[e].v.Copy(s.m_linearVelocity);let r=s.m_angularVelocity;s.m_sweep.c0.Copy(s.m_sweep.c),s.m_sweep.a0=s.m_sweep.a,s.m_type===t.b2BodyType.b2_dynamicBody&&(o.x+=_*s.m_invMass*(s.m_gravityScale*s.m_mass*n.x+s.m_force.x),o.y+=_*s.m_invMass*(s.m_gravityScale*s.m_mass*n.y+s.m_force.y),r+=_*s.m_invI*s.m_torque,o.SelfMul(1/(1+_*s.m_linearDamping)),r*=1/(1+_*s.m_angularDamping)),this.m_positions[e].a=i,this.m_velocities[e].w=r}r.Reset();const m=Bs.s_solverData;m.step.Copy(s),m.positions=this.m_positions,m.velocities=this.m_velocities;const a=Bs.s_contactSolverDef;a.step.Copy(s),a.contacts=this.m_contacts,a.count=this.m_contactCount,a.positions=this.m_positions,a.velocities=this.m_velocities;const l=Bs.s_contactSolver.Initialize(a);l.InitializeVelocityConstraints(),s.warmStarting&&l.WarmStart();for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].InitVelocityConstraints(m);e.solveInit=r.GetMilliseconds(),r.Reset();for(let t=0;t<s.velocityIterations;++t){for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].SolveVelocityConstraints(m);l.SolveVelocityConstraints()}l.StoreImpulses(),e.solveVelocity=r.GetMilliseconds();for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let s=this.m_positions[t].a;const i=this.m_velocities[t].v;let n=this.m_velocities[t].w;const o=b.MulSV(_,i,Bs.s_translation);if(b.DotVV(o,o)>4){const t=2/o.Length();i.SelfMul(t)}const r=_*n;if(r*r>2.4674011002726646){n*=1.570796326795/h(r)}e.x+=_*i.x,e.y+=_*i.y,s+=_*n,this.m_positions[t].a=s,this.m_velocities[t].w=n}r.Reset();let c=!1;for(let t=0;t<s.positionIterations;++t){const t=l.SolvePositionConstraints();let e=!0;for(let t=0;t<this.m_jointCount;++t){const s=this.m_joints[t].SolvePositionConstraints(m);e=e&&s}if(t&&e){c=!0;break}}for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];e.m_sweep.c.Copy(this.m_positions[t].c),e.m_sweep.a=this.m_positions[t].a,e.m_linearVelocity.Copy(this.m_velocities[t].v),e.m_angularVelocity=this.m_velocities[t].w,e.SynchronizeTransform()}if(e.solvePosition=r.GetMilliseconds(),this.Report(l.m_velocityConstraints),o){let e=i;const s=1e-4,n=.0012184696791469947;for(let i=0;i<this.m_bodyCount;++i){const o=this.m_bodies[i];o.GetType()!==t.b2BodyType.b2_staticBody&&(!o.m_autoSleepFlag||o.m_angularVelocity*o.m_angularVelocity>n||b.DotVV(o.m_linearVelocity,o.m_linearVelocity)>s?(o.m_sleepTime=0,e=0):(o.m_sleepTime+=_,e=b2Min(e,o.m_sleepTime)))}if(e>=.5&&c)for(let t=0;t<this.m_bodyCount;++t){this.m_bodies[t].SetAwake(!1)}}}SolveTOI(t,e,s){for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c),this.m_positions[t].a=e.m_sweep.a,this.m_velocities[t].v.Copy(e.m_linearVelocity),this.m_velocities[t].w=e.m_angularVelocity}const i=Bs.s_contactSolverDef;i.contacts=this.m_contacts,i.count=this.m_contactCount,i.step.Copy(t),i.positions=this.m_positions,i.velocities=this.m_velocities;const n=Bs.s_contactSolver.Initialize(i);for(let i=0;i<t.positionIterations;++i){if(n.SolveTOIPositionConstraints(e,s))break}this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c),this.m_bodies[e].m_sweep.a0=this.m_positions[e].a,this.m_bodies[s].m_sweep.c0.Copy(this.m_positions[s].c),this.m_bodies[s].m_sweep.a0=this.m_positions[s].a,n.InitializeVelocityConstraints();for(let e=0;e<t.velocityIterations;++e)n.SolveVelocityConstraints();const o=t.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let s=this.m_positions[t].a;const i=this.m_velocities[t].v;let n=this.m_velocities[t].w;const r=b.MulSV(o,i,Bs.s_translation);if(b.DotVV(r,r)>4){const t=2/r.Length();i.SelfMul(t)}const _=o*n;if(_*_>2.4674011002726646){n*=1.570796326795/h(_)}e.SelfMulAdd(o,i),s+=o*n,this.m_positions[t].a=s,this.m_velocities[t].w=n;const m=this.m_bodies[t];m.m_sweep.c.Copy(e),m.m_sweep.a=s,m.m_linearVelocity.Copy(i),m.m_angularVelocity=n,m.SynchronizeTransform()}this.Report(n.m_velocityConstraints)}Report(t){if(null!==this.m_listener)for(let e=0;e<this.m_contactCount;++e){const s=this.m_contacts[e];if(!s)continue;const i=t[e],n=Bs.s_impulse;n.count=i.pointCount;for(let t=0;t<i.pointCount;++t)n.normalImpulses[t]=i.points[t].normalImpulse,n.tangentImpulses[t]=i.points[t].tangentImpulse;this.m_listener.PostSolve(s,n)}}}Bs.s_timer=new B,Bs.s_solverData=new ys,Bs.s_contactSolverDef=new Ss,Bs.s_contactSolver=new fs,Bs.s_translation=new b,Bs.s_impulse=new _s;class vs extends ze{constructor(t){super(t),this.m_linearOffset=new b,this.m_angularOffset=0,this.m_linearImpulse=new b,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_correctionFactor=.3,this.m_indexA=0,this.m_indexB=0,this.m_rA=new b,this.m_rB=new b,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_linearError=new b,this.m_angularError=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new S,this.m_angularMass=0,this.m_qA=new f,this.m_qB=new f,this.m_K=new S,this.m_linearOffset.Copy(b2Maybe(t.linearOffset,b.ZERO)),this.m_angularOffset=b2Maybe(t.angularOffset,0),this.m_linearImpulse.SetZero(),this.m_maxForce=b2Maybe(t.maxForce,0),this.m_maxTorque=b2Maybe(t.maxTorque,0),this.m_correctionFactor=b2Maybe(t.correctionFactor,.3)}GetAnchorA(t){const e=this.m_bodyA.GetPosition();return t.x=e.x,t.y=e.y,t}GetAnchorB(t){const e=this.m_bodyB.GetPosition();return t.x=e.x,t.y=e.y,t}GetReactionForce(t,e){return b.MulSV(t,this.m_linearImpulse,e)}GetReactionTorque(t){return t*this.m_angularImpulse}SetLinearOffset(t){b.IsEqualToV(t,this.m_linearOffset)||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_linearOffset.Copy(t))}GetLinearOffset(){return this.m_linearOffset}SetAngularOffset(t){t!==this.m_angularOffset&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_angularOffset=t)}GetAngularOffset(){return this.m_angularOffset}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,_=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const m=this.m_qA.SetAngle(s),a=this.m_qB.SetAngle(r),l=f.MulRV(m,b.SubVV(this.m_linearOffset,this.m_localCenterA,b.s_t0),this.m_rA),c=f.MulRV(a,b.NegV(this.m_localCenterB,b.s_t0),this.m_rB),u=this.m_invMassA,d=this.m_invMassB,p=this.m_invIA,y=this.m_invIB,x=this.m_K;if(x.ex.x=u+d+p*l.y*l.y+y*c.y*c.y,x.ex.y=-p*l.x*l.y-y*c.x*c.y,x.ey.x=x.ex.y,x.ey.y=u+d+p*l.x*l.x+y*c.x*c.x,x.GetInverse(this.m_linearMass),this.m_angularMass=p+y,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),b.SubVV(b.AddVV(o,c,b.s_t0),b.AddVV(e,l,b.s_t1),this.m_linearError),this.m_angularError=r-s-this.m_angularOffset,t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;i.SelfMulSub(u,e),n-=p*(b.CrossVV(l,e)+this.m_angularImpulse),_.SelfMulAdd(d,e),h+=y*(b.CrossVV(c,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,_=this.m_invIA,h=this.m_invIB,m=t.step.dt,a=t.step.inv_dt;{const t=n-s+a*this.m_correctionFactor*this.m_angularError;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,o=m*this.m_maxTorque;this.m_angularImpulse=b2Clamp(this.m_angularImpulse+e,-o,o),e=this.m_angularImpulse-i,s-=_*e,n+=h*e}{const t=this.m_rA,l=this.m_rB,c=b.AddVV(b.SubVV(b.AddVV(i,b.CrossSV(n,l,b.s_t0),b.s_t0),b.AddVV(e,b.CrossSV(s,t,b.s_t1),b.s_t1),b.s_t2),b.MulSV(a*this.m_correctionFactor,this.m_linearError,b.s_t3),vs.SolveVelocityConstraints_s_Cdot_v2),u=S.MulMV(this.m_linearMass,c,vs.SolveVelocityConstraints_s_impulse_v2).SelfNeg(),d=vs.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(u);const p=m*this.m_maxForce;this.m_linearImpulse.LengthSquared()>p*p&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(p)),b.SubVV(this.m_linearImpulse,d,u),e.SelfMulSub(o,u),s-=_*b.CrossVV(t,u),i.SelfMulAdd(r,u),n+=h*b.CrossVV(l,u)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2MotorJointDef = new b2MotorJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.linearOffset.Set(%.15f, %.15f);\n",this.m_linearOffset.x,this.m_linearOffset.y),t("  jd.angularOffset = %.15f;\n",this.m_angularOffset),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  jd.correctionFactor = %.15f;\n",this.m_correctionFactor),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}vs.SolveVelocityConstraints_s_Cdot_v2=new b,vs.SolveVelocityConstraints_s_impulse_v2=new b,vs.SolveVelocityConstraints_s_oldImpulse_v2=new b;class gs extends ze{constructor(t){super(t),this.m_localAnchorB=new b,this.m_targetA=new b,this.m_stiffness=0,this.m_damping=0,this.m_beta=0,this.m_impulse=new b,this.m_maxForce=0,this.m_gamma=0,this.m_indexA=0,this.m_indexB=0,this.m_rB=new b,this.m_localCenterB=new b,this.m_invMassB=0,this.m_invIB=0,this.m_mass=new S,this.m_C=new b,this.m_qB=new f,this.m_lalcB=new b,this.m_K=new S,this.m_targetA.Copy(b2Maybe(t.target,b.ZERO)),C.MulTXV(this.m_bodyB.GetTransform(),this.m_targetA,this.m_localAnchorB),this.m_maxForce=b2Maybe(t.maxForce,0),this.m_impulse.SetZero(),this.m_stiffness=b2Maybe(t.stiffness,0),this.m_damping=b2Maybe(t.damping,0),this.m_beta=0,this.m_gamma=0}SetTarget(t){this.m_bodyB.IsAwake()||this.m_bodyB.SetAwake(!0),this.m_targetA.Copy(t)}GetTarget(){return this.m_targetA}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexB].c,s=t.positions[this.m_indexB].a,i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const r=this.m_qB.SetAngle(s),_=this.m_bodyB.GetMass(),h=2*n*this.m_stiffness,m=2*_*this.m_damping*h,a=_*(h*h),l=t.step.dt;this.m_gamma=l*(m+l*a),0!==this.m_gamma&&(this.m_gamma=1/this.m_gamma),this.m_beta=l*a*this.m_gamma,b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),f.MulRV(r,this.m_lalcB,this.m_rB);const c=this.m_K;c.ex.x=this.m_invMassB+this.m_invIB*this.m_rB.y*this.m_rB.y+this.m_gamma,c.ex.y=-this.m_invIB*this.m_rB.x*this.m_rB.y,c.ey.x=c.ex.y,c.ey.y=this.m_invMassB+this.m_invIB*this.m_rB.x*this.m_rB.x+this.m_gamma,c.GetInverse(this.m_mass),this.m_C.x=e.x+this.m_rB.x-this.m_targetA.x,this.m_C.y=e.y+this.m_rB.y-this.m_targetA.y,this.m_C.SelfMul(this.m_beta),o*=.98,t.step.warmStarting?(this.m_impulse.SelfMul(t.step.dtRatio),i.x+=this.m_invMassB*this.m_impulse.x,i.y+=this.m_invMassB*this.m_impulse.y,o+=this.m_invIB*b.CrossVV(this.m_rB,this.m_impulse)):this.m_impulse.SetZero(),t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexB].v;let s=t.velocities[this.m_indexB].w;const i=b.AddVCrossSV(e,s,this.m_rB,gs.SolveVelocityConstraints_s_Cdot),n=S.MulMV(this.m_mass,b.AddVV(i,b.AddVV(this.m_C,b.MulSV(this.m_gamma,this.m_impulse,b.s_t0),b.s_t0),b.s_t0).SelfNeg(),gs.SolveVelocityConstraints_s_impulse),o=gs.SolveVelocityConstraints_s_oldImpulse.Copy(this.m_impulse);this.m_impulse.SelfAdd(n);const r=t.step.dt*this.m_maxForce;this.m_impulse.LengthSquared()>r*r&&this.m_impulse.SelfMul(r/this.m_impulse.Length()),b.SubVV(this.m_impulse,o,n),e.SelfMulAdd(this.m_invMassB,n),s+=this.m_invIB*b.CrossVV(this.m_rB,n),t.velocities[this.m_indexB].w=s}SolvePositionConstraints(t){return!0}GetAnchorA(t){return t.x=this.m_targetA.x,t.y=this.m_targetA.y,t}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return b.MulSV(t,this.m_impulse,e)}GetReactionTorque(t){return 0}Dump(t){t("Mouse joint dumping is not supported.\n")}ShiftOrigin(t){this.m_targetA.SelfSub(t)}}gs.SolveVelocityConstraints_s_Cdot=new b,gs.SolveVelocityConstraints_s_impulse=new b,gs.SolveVelocityConstraints_s_oldImpulse=new b;class Ms extends ze{constructor(t){super(t),this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_localXAxisA=new b,this.m_localYAxisA=new b,this.m_referenceAngle=0,this.m_impulse=new b(0,0),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorForce=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_axis=new b(0,0),this.m_perp=new b(0,0),this.m_s1=0,this.m_s2=0,this.m_a1=0,this.m_a2=0,this.m_K=new S,this.m_K3=new V,this.m_K2=new S,this.m_translation=0,this.m_axialMass=0,this.m_qA=new f,this.m_qB=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_rA=new b,this.m_rB=new b,this.m_localAnchorA.Copy(b2Maybe(t.localAnchorA,b.ZERO)),this.m_localAnchorB.Copy(b2Maybe(t.localAnchorB,b.ZERO)),this.m_localXAxisA.Copy(b2Maybe(t.localAxisA,new b(1,0))).SelfNormalize(),b.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_referenceAngle=b2Maybe(t.referenceAngle,0),this.m_lowerTranslation=b2Maybe(t.lowerTranslation,0),this.m_upperTranslation=b2Maybe(t.upperTranslation,0),this.m_maxMotorForce=b2Maybe(t.maxMotorForce,0),this.m_motorSpeed=b2Maybe(t.motorSpeed,0),this.m_enableLimit=b2Maybe(t.enableLimit,!1),this.m_enableMotor=b2Maybe(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,_=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const m=this.m_qA.SetAngle(s),a=this.m_qB.SetAngle(r);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const l=f.MulRV(m,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const c=f.MulRV(a,this.m_lalcB,this.m_rB),u=b.AddVV(b.SubVV(o,e,b.s_t0),b.SubVV(c,l,b.s_t1),Ms.InitVelocityConstraints_s_d),d=this.m_invMassA,p=this.m_invMassB,y=this.m_invIA,x=this.m_invIB;if(f.MulRV(m,this.m_localXAxisA,this.m_axis),this.m_a1=b.CrossVV(b.AddVV(u,l,b.s_t0),this.m_axis),this.m_a2=b.CrossVV(c,this.m_axis),this.m_axialMass=d+p+y*this.m_a1*this.m_a1+x*this.m_a2*this.m_a2,this.m_axialMass>0&&(this.m_axialMass=1/this.m_axialMass),f.MulRV(m,this.m_localYAxisA,this.m_perp),this.m_s1=b.CrossVV(b.AddVV(u,l,b.s_t0),this.m_perp),this.m_s2=b.CrossVV(c,this.m_perp),this.m_K.ex.x=d+p+y*this.m_s1*this.m_s1+x*this.m_s2*this.m_s2,this.m_K.ex.y=y*this.m_s1+x*this.m_s2,this.m_K.ey.x=this.m_K.ex.y,this.m_K.ey.y=y+x,0===this.m_K.ey.y&&(this.m_K.ey.y=1),this.m_enableLimit?this.m_translation=b.DotVV(this.m_axis,u):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor||(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,s=b.AddVV(b.MulSV(this.m_impulse.x,this.m_perp,b.s_t0),b.MulSV(e,this.m_axis,b.s_t1),Ms.InitVelocityConstraints_s_P),o=this.m_impulse.x*this.m_s1+this.m_impulse.y+e*this.m_a1,r=this.m_impulse.x*this.m_s2+this.m_impulse.y+e*this.m_a2;i.SelfMulSub(d,s),n-=y*o,_.SelfMulAdd(p,s),h+=x*r}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,_=this.m_invIA,h=this.m_invIB;if(this.m_enableMotor){const m=b.DotVV(this.m_axis,b.SubVV(i,e,b.s_t0))+this.m_a2*n-this.m_a1*s;let a=this.m_axialMass*(this.m_motorSpeed-m);const l=this.m_motorImpulse,c=t.step.dt*this.m_maxMotorForce;this.m_motorImpulse=b2Clamp(this.m_motorImpulse+a,-c,c),a=this.m_motorImpulse-l;const u=b.MulSV(a,this.m_axis,Ms.SolveVelocityConstraints_s_P),d=a*this.m_a1,p=a*this.m_a2;e.SelfMulSub(o,u),s-=_*d,i.SelfMulAdd(r,u),n+=h*p}if(this.m_enableLimit){{const m=this.m_translation-this.m_lowerTranslation,a=b.DotVV(this.m_axis,b.SubVV(i,e,b.s_t0))+this.m_a2*n-this.m_a1*s;let l=-this.m_axialMass*(a+b2Max(m,0)*t.step.inv_dt);const c=this.m_lowerImpulse;this.m_lowerImpulse=b2Max(this.m_lowerImpulse+l,0),l=this.m_lowerImpulse-c;const u=b.MulSV(l,this.m_axis,Ms.SolveVelocityConstraints_s_P),d=l*this.m_a1,p=l*this.m_a2;e.SelfMulSub(o,u),s-=_*d,i.SelfMulAdd(r,u),n+=h*p}{const m=this.m_upperTranslation-this.m_translation,a=b.DotVV(this.m_axis,b.SubVV(e,i,b.s_t0))+this.m_a1*s-this.m_a2*n;let l=-this.m_axialMass*(a+b2Max(m,0)*t.step.inv_dt);const c=this.m_upperImpulse;this.m_upperImpulse=b2Max(this.m_upperImpulse+l,0),l=this.m_upperImpulse-c;const u=b.MulSV(l,this.m_axis,Ms.SolveVelocityConstraints_s_P),d=l*this.m_a1,p=l*this.m_a2;e.SelfMulAdd(o,u),s+=_*d,i.SelfMulSub(r,u),n-=h*p}}{const t=b.DotVV(this.m_perp,b.SubVV(i,e,b.s_t0))+this.m_s2*n-this.m_s1*s,m=n-s,a=this.m_K.Solve(-t,-m,Ms.SolveVelocityConstraints_s_df);this.m_impulse.SelfAdd(a);const l=b.MulSV(a.x,this.m_perp,Ms.SolveVelocityConstraints_s_P),c=a.x*this.m_s1+a.y,u=a.x*this.m_s2+a.y;e.SelfMulSub(o,l),s-=_*c,i.SelfMulAdd(r,l),n+=h*u}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n),_=this.m_invMassA,m=this.m_invMassB,a=this.m_invIA,l=this.m_invIB,c=f.MulRV(o,this.m_lalcA,this.m_rA),u=f.MulRV(r,this.m_lalcB,this.m_rB),d=b.SubVV(b.AddVV(i,u,b.s_t0),b.AddVV(e,c,b.s_t1),Ms.SolvePositionConstraints_s_d),p=f.MulRV(o,this.m_localXAxisA,this.m_axis),y=b.CrossVV(b.AddVV(d,c,b.s_t0),p),x=b.CrossVV(u,p),A=f.MulRV(o,this.m_localYAxisA,this.m_perp),S=b.CrossVV(b.AddVV(d,c,b.s_t0),A),V=b.CrossVV(u,A);let C=Ms.SolvePositionConstraints_s_impulse;const w=b.DotVV(A,d),B=n-s-this.m_referenceAngle;let v=h(w);const g=h(B);let M=!1,I=0;if(this.m_enableLimit){const t=b.DotVV(p,d);h(this.m_upperTranslation-this.m_lowerTranslation)<.01?(I=t,v=b2Max(v,h(t)),M=!0):t<=this.m_lowerTranslation?(I=b2Min(t-this.m_lowerTranslation,0),v=b2Max(v,this.m_lowerTranslation-t),M=!0):t>=this.m_upperTranslation&&(I=b2Max(t-this.m_upperTranslation,0),v=b2Max(v,t-this.m_upperTranslation),M=!0)}if(M){const t=_+m+a*S*S+l*V*V,e=a*S+l*V,s=a*S*y+l*V*x;let i=a+l;0===i&&(i=1);const n=a*y+l*x,o=_+m+a*y*y+l*x*x,r=this.m_K3;r.ex.SetXYZ(t,e,s),r.ey.SetXYZ(e,i,n),r.ez.SetXYZ(s,n,o),C=r.Solve33(-w,-B,-I,C)}else{const t=_+m+a*S*S+l*V*V,e=a*S+l*V;let s=a+l;0===s&&(s=1);const i=this.m_K2;i.ex.Set(t,e),i.ey.Set(e,s);const n=i.Solve(-w,-B,Ms.SolvePositionConstraints_s_impulse1);C.x=n.x,C.y=n.y,C.z=0}const D=b.AddVV(b.MulSV(C.x,A,b.s_t0),b.MulSV(C.z,p,b.s_t1),Ms.SolvePositionConstraints_s_P),T=C.x*S+C.y+C.z*y,G=C.x*V+C.y+C.z*x;return e.SelfMulSub(_,D),s-=a*T,i.SelfMulAdd(m,D),n+=l*G,t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,v<=.005&&g<=.03490658503988889}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.x),e.y=t*(this.m_impulse.y*this.m_perp.y+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.y),e}GetReactionTorque(t){return t*this.m_impulse.y}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetReferenceAngle(){return this.m_referenceAngle}GetJointTranslation(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,Ms.GetJointTranslation_s_pA),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,Ms.GetJointTranslation_s_pB),s=b.SubVV(e,t,Ms.GetJointTranslation_s_d),i=this.m_bodyA.GetWorldVector(this.m_localXAxisA,Ms.GetJointTranslation_s_axis);return b.DotVV(s,i)}GetJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;b.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const s=f.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const i=f.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=b.AddVV(t.m_sweep.c,s,b.s_t0),o=b.AddVV(e.m_sweep.c,i,b.s_t1),r=b.SubVV(o,n,b.s_t2),_=t.GetWorldVector(this.m_localXAxisA,this.m_axis),h=t.m_linearVelocity,m=e.m_linearVelocity,a=t.m_angularVelocity,l=e.m_angularVelocity;return b.DotVV(r,b.CrossSV(a,_,b.s_t0))+b.DotVV(_,b.SubVV(b.AddVCrossSV(m,l,i,b.s_t0),b.AddVCrossSV(h,a,s,b.s_t1),b.s_t0))}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorForce(t){t!==this.m_maxMotorForce&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorForce=t)}GetMaxMotorForce(){return this.m_maxMotorForce}GetMotorForce(t){return t*this.m_motorImpulse}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerTranslation = %.15f;\n",this.m_lowerTranslation),t("  jd.upperTranslation = %.15f;\n",this.m_upperTranslation),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorForce = %.15f;\n",this.m_maxMotorForce),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=C.MulXV(e,this.m_localAnchorA,Ms.Draw_s_pA),n=C.MulXV(s,this.m_localAnchorB,Ms.Draw_s_pB),o=f.MulRV(e.q,this.m_localXAxisA,Ms.Draw_s_axis),r=Ms.Draw_s_c1,_=Ms.Draw_s_c2,h=Ms.Draw_s_c3,m=Ms.Draw_s_c4,a=Ms.Draw_s_c5;if(t.DrawSegment(i,n,a),this.m_enableLimit){const s=b.AddVMulSV(i,this.m_lowerTranslation,o,Ms.Draw_s_lower),n=b.AddVMulSV(i,this.m_upperTranslation,o,Ms.Draw_s_upper),m=f.MulRV(e.q,this.m_localYAxisA,Ms.Draw_s_perp);t.DrawSegment(s,n,r),t.DrawSegment(b.AddVMulSV(s,-.5,m,b.s_t0),b.AddVMulSV(s,.5,m,b.s_t1),_),t.DrawSegment(b.AddVMulSV(n,-.5,m,b.s_t0),b.AddVMulSV(n,.5,m,b.s_t1),h)}else t.DrawSegment(b.AddVMulSV(i,-1,o,b.s_t0),b.AddVMulSV(i,1,o,b.s_t1),r);t.DrawPoint(i,5,r),t.DrawPoint(n,5,m)}}Ms.InitVelocityConstraints_s_d=new b,Ms.InitVelocityConstraints_s_P=new b,Ms.SolveVelocityConstraints_s_P=new b,Ms.SolveVelocityConstraints_s_df=new b,Ms.SolvePositionConstraints_s_d=new b,Ms.SolvePositionConstraints_s_impulse=new A,Ms.SolvePositionConstraints_s_impulse1=new b,Ms.SolvePositionConstraints_s_P=new b,Ms.GetJointTranslation_s_pA=new b,Ms.GetJointTranslation_s_pB=new b,Ms.GetJointTranslation_s_d=new b,Ms.GetJointTranslation_s_axis=new b,Ms.Draw_s_pA=new b,Ms.Draw_s_pB=new b,Ms.Draw_s_axis=new b,Ms.Draw_s_c1=new e(.7,.7,.7),Ms.Draw_s_c2=new e(.3,.9,.3),Ms.Draw_s_c3=new e(.9,.3,.3),Ms.Draw_s_c4=new e(.3,.3,.9),Ms.Draw_s_c5=new e(.4,.4,.4),Ms.Draw_s_lower=new b,Ms.Draw_s_upper=new b,Ms.Draw_s_perp=new b;class Is extends ze{constructor(t){super(t),this.m_groundAnchorA=new b,this.m_groundAnchorB=new b,this.m_lengthA=0,this.m_lengthB=0,this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_uA=new b,this.m_uB=new b,this.m_rA=new b,this.m_rB=new b,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=0,this.m_qA=new f,this.m_qB=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_groundAnchorA.Copy(b2Maybe(t.groundAnchorA,new b(-1,1))),this.m_groundAnchorB.Copy(b2Maybe(t.groundAnchorB,new b(1,0))),this.m_localAnchorA.Copy(b2Maybe(t.localAnchorA,new b(-1,0))),this.m_localAnchorB.Copy(b2Maybe(t.localAnchorB,new b(1,0))),this.m_lengthA=b2Maybe(t.lengthA,0),this.m_lengthB=b2Maybe(t.lengthB,0),this.m_ratio=b2Maybe(t.ratio,1),this.m_constant=b2Maybe(t.lengthA,0)+this.m_ratio*b2Maybe(t.lengthB,0),this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,_=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const m=this.m_qA.SetAngle(s),a=this.m_qB.SetAngle(r);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),f.MulRV(m,this.m_lalcA,this.m_rA),b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),f.MulRV(a,this.m_lalcB,this.m_rB),this.m_uA.Copy(e).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA),this.m_uB.Copy(o).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);const l=this.m_uA.Length(),c=this.m_uB.Length();l>.05?this.m_uA.SelfMul(1/l):this.m_uA.SetZero(),c>.05?this.m_uB.SelfMul(1/c):this.m_uB.SetZero();const u=b.CrossVV(this.m_rA,this.m_uA),d=b.CrossVV(this.m_rB,this.m_uB),p=this.m_invMassA+this.m_invIA*u*u,y=this.m_invMassB+this.m_invIB*d*d;if(this.m_mass=p+this.m_ratio*this.m_ratio*y,this.m_mass>0&&(this.m_mass=1/this.m_mass),t.step.warmStarting){this.m_impulse*=t.step.dtRatio;const e=b.MulSV(-this.m_impulse,this.m_uA,Is.InitVelocityConstraints_s_PA),s=b.MulSV(-this.m_ratio*this.m_impulse,this.m_uB,Is.InitVelocityConstraints_s_PB);i.SelfMulAdd(this.m_invMassA,e),n+=this.m_invIA*b.CrossVV(this.m_rA,e),_.SelfMulAdd(this.m_invMassB,s),h+=this.m_invIB*b.CrossVV(this.m_rB,s)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=b.AddVCrossSV(e,s,this.m_rA,Is.SolveVelocityConstraints_s_vpA),r=b.AddVCrossSV(i,n,this.m_rB,Is.SolveVelocityConstraints_s_vpB),_=-b.DotVV(this.m_uA,o)-this.m_ratio*b.DotVV(this.m_uB,r),h=-this.m_mass*_;this.m_impulse+=h;const m=b.MulSV(-h,this.m_uA,Is.SolveVelocityConstraints_s_PA),a=b.MulSV(-this.m_ratio*h,this.m_uB,Is.SolveVelocityConstraints_s_PB);e.SelfMulAdd(this.m_invMassA,m),s+=this.m_invIA*b.CrossVV(this.m_rA,m),i.SelfMulAdd(this.m_invMassB,a),n+=this.m_invIB*b.CrossVV(this.m_rB,a),t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const _=f.MulRV(o,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const m=f.MulRV(r,this.m_lalcB,this.m_rB),a=this.m_uA.Copy(e).SelfAdd(_).SelfSub(this.m_groundAnchorA),l=this.m_uB.Copy(i).SelfAdd(m).SelfSub(this.m_groundAnchorB),c=a.Length(),u=l.Length();c>.05?a.SelfMul(1/c):a.SetZero(),u>.05?l.SelfMul(1/u):l.SetZero();const d=b.CrossVV(_,a),p=b.CrossVV(m,l),y=this.m_invMassA+this.m_invIA*d*d,x=this.m_invMassB+this.m_invIB*p*p;let A=y+this.m_ratio*this.m_ratio*x;A>0&&(A=1/A);const S=this.m_constant-c-this.m_ratio*u,V=h(S),C=-A*S,w=b.MulSV(-C,a,Is.SolvePositionConstraints_s_PA),B=b.MulSV(-this.m_ratio*C,l,Is.SolvePositionConstraints_s_PB);return e.SelfMulAdd(this.m_invMassA,w),s+=this.m_invIA*b.CrossVV(_,w),i.SelfMulAdd(this.m_invMassB,B),n+=this.m_invIB*b.CrossVV(m,B),t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,V<.005}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse*this.m_uB.x,e.y=t*this.m_impulse*this.m_uB.y,e}GetReactionTorque(t){return 0}GetGroundAnchorA(){return this.m_groundAnchorA}GetGroundAnchorB(){return this.m_groundAnchorB}GetLengthA(){return this.m_lengthA}GetLengthB(){return this.m_lengthB}GetRatio(){return this.m_ratio}GetCurrentLengthA(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,Is.GetCurrentLengthA_s_p),e=this.m_groundAnchorA;return b.DistanceVV(t,e)}GetCurrentLengthB(){const t=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,Is.GetCurrentLengthB_s_p),e=this.m_groundAnchorB;return b.DistanceVV(t,e)}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2PulleyJointDef = new b2PulleyJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.groundAnchorA.Set(%.15f, %.15f);\n",this.m_groundAnchorA.x,this.m_groundAnchorA.y),t("  jd.groundAnchorB.Set(%.15f, %.15f);\n",this.m_groundAnchorB.x,this.m_groundAnchorB.y),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.lengthA = %.15f;\n",this.m_lengthA),t("  jd.lengthB = %.15f;\n",this.m_lengthB),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}ShiftOrigin(t){this.m_groundAnchorA.SelfSub(t),this.m_groundAnchorB.SelfSub(t)}}Is.InitVelocityConstraints_s_PA=new b,Is.InitVelocityConstraints_s_PB=new b,Is.SolveVelocityConstraints_s_vpA=new b,Is.SolveVelocityConstraints_s_vpB=new b,Is.SolveVelocityConstraints_s_PA=new b,Is.SolveVelocityConstraints_s_PB=new b,Is.SolvePositionConstraints_s_PA=new b,Is.SolvePositionConstraints_s_PB=new b,Is.GetCurrentLengthA_s_p=new b,Is.GetCurrentLengthB_s_p=new b;class Ds extends ze{constructor(t){super(t),this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_impulse=new b,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_enableMotor=!1,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_referenceAngle=0,this.m_lowerAngle=0,this.m_upperAngle=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new b,this.m_rB=new b,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_K=new S,this.m_angle=0,this.m_axialMass=0,this.m_qA=new f,this.m_qB=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_localAnchorA.Copy(b2Maybe(t.localAnchorA,b.ZERO)),this.m_localAnchorB.Copy(b2Maybe(t.localAnchorB,b.ZERO)),this.m_referenceAngle=b2Maybe(t.referenceAngle,0),this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerAngle=b2Maybe(t.lowerAngle,0),this.m_upperAngle=b2Maybe(t.upperAngle,0),this.m_maxMotorTorque=b2Maybe(t.maxMotorTorque,0),this.m_motorSpeed=b2Maybe(t.motorSpeed,0),this.m_enableLimit=b2Maybe(t.enableLimit,!1),this.m_enableMotor=b2Maybe(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,o=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const _=this.m_qA.SetAngle(e),h=this.m_qB.SetAngle(n);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),f.MulRV(_,this.m_lalcA,this.m_rA),b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),f.MulRV(h,this.m_lalcB,this.m_rB);const m=this.m_invMassA,a=this.m_invMassB,l=this.m_invIA,c=this.m_invIB;let u;if(this.m_K.ex.x=m+a+this.m_rA.y*this.m_rA.y*l+this.m_rB.y*this.m_rB.y*c,this.m_K.ey.x=-this.m_rA.y*this.m_rA.x*l-this.m_rB.y*this.m_rB.x*c,this.m_K.ex.y=this.m_K.ey.x,this.m_K.ey.y=m+a+this.m_rA.x*this.m_rA.x*l+this.m_rB.x*this.m_rB.x*c,this.m_axialMass=l+c,this.m_axialMass>0?(this.m_axialMass=1/this.m_axialMass,u=!1):u=!0,this.m_angle=n-e-this.m_referenceAngle,(!1===this.m_enableLimit||u)&&(this.m_lowerImpulse=0,this.m_upperImpulse=0),(!1===this.m_enableMotor||u)&&(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,n=Ds.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);s.SelfMulSub(m,n),i-=l*(b.CrossVV(this.m_rA,n)+e),o.SelfMulAdd(a,n),r+=c*(b.CrossVV(this.m_rB,n)+e)}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,_=this.m_invIA,h=this.m_invIB,m=_+h===0;if(this.m_enableMotor&&!m){const e=n-s-this.m_motorSpeed;let i=-this.m_axialMass*e;const o=this.m_motorImpulse,r=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=b2Clamp(this.m_motorImpulse+i,-r,r),i=this.m_motorImpulse-o,s-=_*i,n+=h*i}if(this.m_enableLimit&&!m){{const e=this.m_angle-this.m_lowerAngle,i=n-s;let o=-this.m_axialMass*(i+b2Max(e,0)*t.step.inv_dt);const r=this.m_lowerImpulse;this.m_lowerImpulse=b2Max(this.m_lowerImpulse+o,0),o=this.m_lowerImpulse-r,s-=_*o,n+=h*o}{const e=this.m_upperAngle-this.m_angle,i=s-n;let o=-this.m_axialMass*(i+b2Max(e,0)*t.step.inv_dt);const r=this.m_upperImpulse;this.m_upperImpulse=b2Max(this.m_upperImpulse+o,0),o=this.m_upperImpulse-r,s+=_*o,n-=h*o}}{const t=b.SubVV(b.AddVCrossSV(i,n,this.m_rB,b.s_t0),b.AddVCrossSV(e,s,this.m_rA,b.s_t1),Ds.SolveVelocityConstraints_s_Cdot_v2),m=this.m_K.Solve(-t.x,-t.y,Ds.SolveVelocityConstraints_s_impulse_v2);this.m_impulse.x+=m.x,this.m_impulse.y+=m.y,e.SelfMulSub(o,m),s-=_*b.CrossVV(this.m_rA,m),i.SelfMulAdd(r,m),n+=h*b.CrossVV(this.m_rB,m)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);let _=0,m=0;const a=this.m_invIA+this.m_invIB===0;if(this.m_enableLimit&&!a){const t=n-s-this.m_referenceAngle;let e=0;h(this.m_upperAngle-this.m_lowerAngle)<.06981317007977778?e=b2Clamp(t-this.m_lowerAngle,-.13962634015955555,.13962634015955555):t<=this.m_lowerAngle?e=b2Clamp(t-this.m_lowerAngle+.03490658503988889,-.13962634015955555,0):t>=this.m_upperAngle&&(e=b2Clamp(t-this.m_upperAngle-.03490658503988889,0,.13962634015955555));const i=-this.m_axialMass*e;s-=this.m_invIA*i,n+=this.m_invIB*i,_=h(e)}{o.SetAngle(s),r.SetAngle(n),b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const t=f.MulRV(o,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const _=f.MulRV(r,this.m_lalcB,this.m_rB),h=b.SubVV(b.AddVV(i,_,b.s_t0),b.AddVV(e,t,b.s_t1),Ds.SolvePositionConstraints_s_C_v2);m=h.Length();const a=this.m_invMassA,l=this.m_invMassB,c=this.m_invIA,u=this.m_invIB,d=this.m_K;d.ex.x=a+l+c*t.y*t.y+u*_.y*_.y,d.ex.y=-c*t.x*t.y-u*_.x*_.y,d.ey.x=d.ex.y,d.ey.y=a+l+c*t.x*t.x+u*_.x*_.x;const p=d.Solve(h.x,h.y,Ds.SolvePositionConstraints_s_impulse).SelfNeg();e.SelfMulSub(a,p),s-=c*b.CrossVV(t,p),i.SelfMulAdd(l,p),n+=u*b.CrossVV(_,p)}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,m<=.005&&_<=.03490658503988889}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*(this.m_lowerImpulse-this.m_upperImpulse)}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}GetJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle}GetJointSpeed(){return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}GetMotorTorque(t){return t*this.m_motorImpulse}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMaxMotorTorque(){return this.m_maxMotorTorque}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerAngle}GetUpperLimit(){return this.m_upperAngle}SetLimits(t,e){t===this.m_lowerAngle&&e===this.m_upperAngle||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerAngle=t,this.m_upperAngle=e)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerAngle = %.15f;\n",this.m_lowerAngle),t("  jd.upperAngle = %.15f;\n",this.m_upperAngle),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=C.MulXV(e,this.m_localAnchorA,Ds.Draw_s_pA),n=C.MulXV(s,this.m_localAnchorB,Ds.Draw_s_pB),o=Ds.Draw_s_c1,r=Ds.Draw_s_c2,_=Ds.Draw_s_c3,h=Ds.Draw_s_c4,m=Ds.Draw_s_c5;t.DrawPoint(i,5,h),t.DrawPoint(n,5,m);const a=this.m_bodyA.GetAngle(),l=this.m_bodyB.GetAngle()-a-this.m_referenceAngle,c=.5,u=Ds.Draw_s_r.Set(c*Math.cos(l),c*Math.sin(l));if(t.DrawSegment(n,b.AddVV(n,u,b.s_t0),o),t.DrawCircle(n,c,o),this.m_enableLimit){const e=Ds.Draw_s_rlo.Set(c*Math.cos(this.m_lowerAngle),c*Math.sin(this.m_lowerAngle)),s=Ds.Draw_s_rhi.Set(c*Math.cos(this.m_upperAngle),c*Math.sin(this.m_upperAngle));t.DrawSegment(n,b.AddVV(n,e,b.s_t0),r),t.DrawSegment(n,b.AddVV(n,s,b.s_t0),_)}const d=Ds.Draw_s_color_;t.DrawSegment(e.p,i,d),t.DrawSegment(i,n,d),t.DrawSegment(s.p,n,d)}}Ds.InitVelocityConstraints_s_P=new b,Ds.SolveVelocityConstraints_s_Cdot_v2=new b,Ds.SolveVelocityConstraints_s_impulse_v2=new b,Ds.SolvePositionConstraints_s_C_v2=new b,Ds.SolvePositionConstraints_s_impulse=new b,Ds.Draw_s_pA=new b,Ds.Draw_s_pB=new b,Ds.Draw_s_c1=new e(.7,.7,.7),Ds.Draw_s_c2=new e(.3,.9,.3),Ds.Draw_s_c3=new e(.9,.3,.3),Ds.Draw_s_c4=new e(.3,.3,.9),Ds.Draw_s_c5=new e(.4,.4,.4),Ds.Draw_s_color_=new e(.5,.8,.8),Ds.Draw_s_r=new b,Ds.Draw_s_rlo=new b,Ds.Draw_s_rhi=new b;class Ts extends ze{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_referenceAngle=0,this.m_gamma=0,this.m_impulse=new A(0,0,0),this.m_indexA=0,this.m_indexB=0,this.m_rA=new b,this.m_rB=new b,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=new V,this.m_qA=new f,this.m_qB=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_K=new V,this.m_stiffness=b2Maybe(t.stiffness,0),this.m_damping=b2Maybe(t.damping,0),this.m_localAnchorA.Copy(b2Maybe(t.localAnchorA,b.ZERO)),this.m_localAnchorB.Copy(b2Maybe(t.localAnchorB,b.ZERO)),this.m_referenceAngle=b2Maybe(t.referenceAngle,0),this.m_impulse.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,o=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const _=this.m_qA.SetAngle(e),h=this.m_qB.SetAngle(n);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),f.MulRV(_,this.m_lalcA,this.m_rA),b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),f.MulRV(h,this.m_lalcB,this.m_rB);const m=this.m_invMassA,a=this.m_invMassB,l=this.m_invIA,c=this.m_invIB,u=this.m_K;if(u.ex.x=m+a+this.m_rA.y*this.m_rA.y*l+this.m_rB.y*this.m_rB.y*c,u.ey.x=-this.m_rA.y*this.m_rA.x*l-this.m_rB.y*this.m_rB.x*c,u.ez.x=-this.m_rA.y*l-this.m_rB.y*c,u.ex.y=u.ey.x,u.ey.y=m+a+this.m_rA.x*this.m_rA.x*l+this.m_rB.x*this.m_rB.x*c,u.ez.y=this.m_rA.x*l+this.m_rB.x*c,u.ex.z=u.ez.x,u.ey.z=u.ez.y,u.ez.z=l+c,this.m_stiffness>0){u.GetInverse22(this.m_mass);let s=l+c;const i=n-e-this.m_referenceAngle,o=this.m_damping,r=this.m_stiffness,_=t.step.dt;this.m_gamma=_*(o+_*r),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=i*_*r*this.m_gamma,s+=this.m_gamma,this.m_mass.ez.z=0!==s?1/s:0}else u.GetSymInverse33(this.m_mass),this.m_gamma=0,this.m_bias=0;if(t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio);const e=Ts.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);s.SelfMulSub(m,e),i-=l*(b.CrossVV(this.m_rA,e)+this.m_impulse.z),o.SelfMulAdd(a,e),r+=c*(b.CrossVV(this.m_rB,e)+this.m_impulse.z)}else this.m_impulse.SetZero();t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,_=this.m_invIA,h=this.m_invIB;if(this.m_stiffness>0){const t=n-s,m=-this.m_mass.ez.z*(t+this.m_bias+this.m_gamma*this.m_impulse.z);this.m_impulse.z+=m,s-=_*m,n+=h*m;const a=b.SubVV(b.AddVCrossSV(i,n,this.m_rB,b.s_t0),b.AddVCrossSV(e,s,this.m_rA,b.s_t1),Ts.SolveVelocityConstraints_s_Cdot1),l=V.MulM33XY(this.m_mass,a.x,a.y,Ts.SolveVelocityConstraints_s_impulse1).SelfNeg();this.m_impulse.x+=l.x,this.m_impulse.y+=l.y;const c=l;e.SelfMulSub(o,c),s-=_*b.CrossVV(this.m_rA,c),i.SelfMulAdd(r,c),n+=h*b.CrossVV(this.m_rB,c)}else{const t=b.SubVV(b.AddVCrossSV(i,n,this.m_rB,b.s_t0),b.AddVCrossSV(e,s,this.m_rA,b.s_t1),Ts.SolveVelocityConstraints_s_Cdot1),m=n-s,a=V.MulM33XYZ(this.m_mass,t.x,t.y,m,Ts.SolveVelocityConstraints_s_impulse).SelfNeg();this.m_impulse.SelfAdd(a);const l=Ts.SolveVelocityConstraints_s_P.Set(a.x,a.y);e.SelfMulSub(o,l),s-=_*(b.CrossVV(this.m_rA,l)+a.z),i.SelfMulAdd(r,l),n+=h*(b.CrossVV(this.m_rB,l)+a.z)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n),_=this.m_invMassA,m=this.m_invMassB,a=this.m_invIA,l=this.m_invIB;b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const c=f.MulRV(o,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const u=f.MulRV(r,this.m_lalcB,this.m_rB);let d,p;const y=this.m_K;if(y.ex.x=_+m+c.y*c.y*a+u.y*u.y*l,y.ey.x=-c.y*c.x*a-u.y*u.x*l,y.ez.x=-c.y*a-u.y*l,y.ex.y=y.ey.x,y.ey.y=_+m+c.x*c.x*a+u.x*u.x*l,y.ez.y=c.x*a+u.x*l,y.ex.z=y.ez.x,y.ey.z=y.ez.y,y.ez.z=a+l,this.m_stiffness>0){const t=b.SubVV(b.AddVV(i,u,b.s_t0),b.AddVV(e,c,b.s_t1),Ts.SolvePositionConstraints_s_C1);d=t.Length(),p=0;const o=y.Solve22(t.x,t.y,Ts.SolvePositionConstraints_s_P).SelfNeg();e.SelfMulSub(_,o),s-=a*b.CrossVV(c,o),i.SelfMulAdd(m,o),n+=l*b.CrossVV(u,o)}else{const t=b.SubVV(b.AddVV(i,u,b.s_t0),b.AddVV(e,c,b.s_t1),Ts.SolvePositionConstraints_s_C1),o=n-s-this.m_referenceAngle;d=t.Length(),p=h(o);const r=y.Solve33(t.x,t.y,o,Ts.SolvePositionConstraints_s_impulse).SelfNeg(),x=Ts.SolvePositionConstraints_s_P.Set(r.x,r.y);e.SelfMulSub(_,x),s-=a*(b.CrossVV(this.m_rA,x)+r.z),i.SelfMulAdd(m,x),n+=l*(b.CrossVV(this.m_rB,x)+r.z)}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,d<=.005&&p<=.03490658503988889}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*this.m_impulse.z}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2WeldJointDef = new b2WeldJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}Ts.InitVelocityConstraints_s_P=new b,Ts.SolveVelocityConstraints_s_Cdot1=new b,Ts.SolveVelocityConstraints_s_impulse1=new b,Ts.SolveVelocityConstraints_s_impulse=new A,Ts.SolveVelocityConstraints_s_P=new b,Ts.SolvePositionConstraints_s_C1=new b,Ts.SolvePositionConstraints_s_P=new b,Ts.SolvePositionConstraints_s_impulse=new A;class Gs extends ze{constructor(t){super(t),this.m_localAnchorA=new b,this.m_localAnchorB=new b,this.m_localXAxisA=new b,this.m_localYAxisA=new b,this.m_impulse=0,this.m_motorImpulse=0,this.m_springImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_translation=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_stiffness=0,this.m_damping=0,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new b,this.m_localCenterB=new b,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_ax=new b,this.m_ay=new b,this.m_sAx=0,this.m_sBx=0,this.m_sAy=0,this.m_sBy=0,this.m_mass=0,this.m_motorMass=0,this.m_axialMass=0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_qA=new f,this.m_qB=new f,this.m_lalcA=new b,this.m_lalcB=new b,this.m_rA=new b,this.m_rB=new b,this.m_localAnchorA.Copy(b2Maybe(t.localAnchorA,b.ZERO)),this.m_localAnchorB.Copy(b2Maybe(t.localAnchorB,b.ZERO)),this.m_localXAxisA.Copy(b2Maybe(t.localAxisA,b.UNITX)),b.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_lowerTranslation=b2Maybe(t.lowerTranslation,0),this.m_upperTranslation=b2Maybe(t.upperTranslation,0),this.m_enableLimit=b2Maybe(t.enableLimit,!1),this.m_maxMotorTorque=b2Maybe(t.maxMotorTorque,0),this.m_motorSpeed=b2Maybe(t.motorSpeed,0),this.m_enableMotor=b2Maybe(t.enableMotor,!1),this.m_ax.SetZero(),this.m_ay.SetZero(),this.m_stiffness=b2Maybe(t.stiffness,0),this.m_damping=b2Maybe(t.damping,0)}GetMotorSpeed(){return this.m_motorSpeed}GetMaxMotorTorque(){return this.m_maxMotorTorque}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_invMassA,s=this.m_invMassB,i=this.m_invIA,n=this.m_invIB,o=t.positions[this.m_indexA].c,r=t.positions[this.m_indexA].a,_=t.velocities[this.m_indexA].v;let h=t.velocities[this.m_indexA].w;const m=t.positions[this.m_indexB].c,a=t.positions[this.m_indexB].a,l=t.velocities[this.m_indexB].v;let c=t.velocities[this.m_indexB].w;const u=this.m_qA.SetAngle(r),d=this.m_qB.SetAngle(a);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const p=f.MulRV(u,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const y=f.MulRV(d,this.m_lalcB,this.m_rB),x=b.SubVV(b.AddVV(m,y,b.s_t0),b.AddVV(o,p,b.s_t1),Gs.InitVelocityConstraints_s_d);f.MulRV(u,this.m_localYAxisA,this.m_ay),this.m_sAy=b.CrossVV(b.AddVV(x,p,b.s_t0),this.m_ay),this.m_sBy=b.CrossVV(y,this.m_ay),this.m_mass=e+s+i*this.m_sAy*this.m_sAy+n*this.m_sBy*this.m_sBy,this.m_mass>0&&(this.m_mass=1/this.m_mass),f.MulRV(u,this.m_localXAxisA,this.m_ax),this.m_sAx=b.CrossVV(b.AddVV(x,p,b.s_t0),this.m_ax),this.m_sBx=b.CrossVV(y,this.m_ax);const A=e+s+i*this.m_sAx*this.m_sAx+n*this.m_sBx*this.m_sBx;if(this.m_axialMass=A>0?1/A:0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_stiffness>0&&A>0){this.m_springMass=1/A;const e=b.DotVV(x,this.m_ax),s=t.step.dt;this.m_gamma=s*(this.m_damping+s*this.m_stiffness),this.m_gamma>0&&(this.m_gamma=1/this.m_gamma),this.m_bias=e*s*this.m_stiffness*this.m_gamma,this.m_springMass=A+this.m_gamma,this.m_springMass>0&&(this.m_springMass=1/this.m_springMass)}else this.m_springImpulse=0;if(this.m_enableLimit?this.m_translation=b.DotVV(this.m_ax,x):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor?(this.m_motorMass=i+n,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass)):(this.m_motorMass=0,this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_springImpulse*=t.step.dtRatio,this.m_motorImpulse*=t.step.dtRatio;const e=this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse,s=b.AddVV(b.MulSV(this.m_impulse,this.m_ay,b.s_t0),b.MulSV(e,this.m_ax,b.s_t1),Gs.InitVelocityConstraints_s_P),i=this.m_impulse*this.m_sAy+e*this.m_sAx+this.m_motorImpulse,n=this.m_impulse*this.m_sBy+e*this.m_sBx+this.m_motorImpulse;_.SelfMulSub(this.m_invMassA,s),h-=this.m_invIA*i,l.SelfMulAdd(this.m_invMassB,s),c+=this.m_invIB*n}else this.m_impulse=0,this.m_springImpulse=0,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=h,t.velocities[this.m_indexB].w=c}SolveVelocityConstraints(t){const e=this.m_invMassA,s=this.m_invMassB,i=this.m_invIA,n=this.m_invIB,o=t.velocities[this.m_indexA].v;let r=t.velocities[this.m_indexA].w;const _=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;{const t=b.DotVV(this.m_ax,b.SubVV(_,o,b.s_t0))+this.m_sBx*h-this.m_sAx*r,m=-this.m_springMass*(t+this.m_bias+this.m_gamma*this.m_springImpulse);this.m_springImpulse+=m;const a=b.MulSV(m,this.m_ax,Gs.SolveVelocityConstraints_s_P),l=m*this.m_sAx,c=m*this.m_sBx;o.SelfMulSub(e,a),r-=i*l,_.SelfMulAdd(s,a),h+=n*c}{const e=h-r-this.m_motorSpeed;let s=-this.m_motorMass*e;const o=this.m_motorImpulse,_=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=b2Clamp(this.m_motorImpulse+s,-_,_),s=this.m_motorImpulse-o,r-=i*s,h+=n*s}if(this.m_enableLimit){{const m=this.m_translation-this.m_lowerTranslation,a=b.DotVV(this.m_ax,b.SubVV(_,o,b.s_t0))+this.m_sBx*h-this.m_sAx*r;let l=-this.m_axialMass*(a+b2Max(m,0)*t.step.inv_dt);const c=this.m_lowerImpulse;this.m_lowerImpulse=b2Max(this.m_lowerImpulse+l,0),l=this.m_lowerImpulse-c;const u=b.MulSV(l,this.m_ax,Gs.SolveVelocityConstraints_s_P),d=l*this.m_sAx,p=l*this.m_sBx;o.SelfMulSub(e,u),r-=i*d,_.SelfMulAdd(s,u),h+=n*p}{const m=this.m_upperTranslation-this.m_translation,a=b.DotVV(this.m_ax,b.SubVV(o,_,b.s_t0))+this.m_sAx*r-this.m_sBx*h;let l=-this.m_axialMass*(a+b2Max(m,0)*t.step.inv_dt);const c=this.m_upperImpulse;this.m_upperImpulse=b2Max(this.m_upperImpulse+l,0),l=this.m_upperImpulse-c;const u=b.MulSV(l,this.m_ax,Gs.SolveVelocityConstraints_s_P),d=l*this.m_sAx,p=l*this.m_sBx;o.SelfMulAdd(e,u),r+=i*d,_.SelfMulSub(s,u),h-=n*p}}{const t=b.DotVV(this.m_ay,b.SubVV(_,o,b.s_t0))+this.m_sBy*h-this.m_sAy*r,m=-this.m_mass*t;this.m_impulse+=m;const a=b.MulSV(m,this.m_ay,Gs.SolveVelocityConstraints_s_P),l=m*this.m_sAy,c=m*this.m_sBy;o.SelfMulSub(e,a),r-=i*l,_.SelfMulAdd(s,a),h+=n*c}t.velocities[this.m_indexA].w=r,t.velocities[this.m_indexB].w=h}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a,o=0;if(this.m_enableLimit){const t=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const _=f.MulRV(t,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const m=f.MulRV(r,this.m_lalcB,this.m_rB),a=b.AddVV(b.SubVV(i,e,b.s_t0),b.SubVV(m,_,b.s_t1),Gs.SolvePositionConstraints_s_d),l=f.MulRV(t,this.m_localXAxisA,this.m_ax),c=b.CrossVV(b.AddVV(a,_,b.s_t0),this.m_ax),u=b.CrossVV(m,this.m_ax);let d=0;const p=b.DotVV(l,a);if(h(this.m_upperTranslation-this.m_lowerTranslation)<.01?d=p:p<=this.m_lowerTranslation?d=b2Min(p-this.m_lowerTranslation,0):p>=this.m_upperTranslation&&(d=b2Max(p-this.m_upperTranslation,0)),0!==d){const t=this.m_invMassA+this.m_invMassB+this.m_invIA*c*c+this.m_invIB*u*u;let r=0;0!==t&&(r=-d/t);const _=b.MulSV(r,l,Gs.SolvePositionConstraints_s_P),m=r*c,a=r*u;e.SelfMulSub(this.m_invMassA,_),s-=this.m_invIA*m,i.SelfMulAdd(this.m_invMassB,_),n+=this.m_invIB*a,o=h(d)}}{const t=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);b.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const _=f.MulRV(t,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const m=f.MulRV(r,this.m_lalcB,this.m_rB),a=b.AddVV(b.SubVV(i,e,b.s_t0),b.SubVV(m,_,b.s_t1),Gs.SolvePositionConstraints_s_d),l=f.MulRV(t,this.m_localYAxisA,this.m_ay),c=b.CrossVV(b.AddVV(a,_,b.s_t0),l),u=b.CrossVV(m,l),d=b.DotVV(a,l),p=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_sAy*this.m_sAy+this.m_invIB*this.m_sBy*this.m_sBy;let y=0;0!==p&&(y=-d/p);const x=b.MulSV(y,l,Gs.SolvePositionConstraints_s_P),A=y*c,S=y*u;e.SelfMulSub(this.m_invMassA,x),s-=this.m_invIA*A,i.SelfMulAdd(this.m_invMassB,x),n+=this.m_invIB*S,o=b2Max(o,h(d))}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,o<=.005}GetDefinition(t){return t}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse*this.m_ay.x+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.x),e.y=t*(this.m_impulse*this.m_ay.y+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.y),e}GetReactionTorque(t){return t*this.m_motorImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetJointTranslation(){return this.GetPrismaticJointTranslation()}GetJointLinearSpeed(){return this.GetPrismaticJointSpeed()}GetJointAngle(){return this.GetRevoluteJointAngle()}GetJointAngularSpeed(){return this.GetRevoluteJointSpeed()}GetPrismaticJointTranslation(){const t=this.m_bodyA,e=this.m_bodyB,s=t.GetWorldPoint(this.m_localAnchorA,new b),i=e.GetWorldPoint(this.m_localAnchorB,new b),n=b.SubVV(i,s,new b),o=t.GetWorldVector(this.m_localXAxisA,new b);return b.DotVV(n,o)}GetPrismaticJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;b.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const s=f.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);b.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const i=f.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=b.AddVV(t.m_sweep.c,s,b.s_t0),o=b.AddVV(e.m_sweep.c,i,b.s_t1),r=b.SubVV(o,n,b.s_t2),_=t.GetWorldVector(this.m_localXAxisA,new b),h=t.m_linearVelocity,m=e.m_linearVelocity,a=t.m_angularVelocity,l=e.m_angularVelocity;return b.DotVV(r,b.CrossSV(a,_,b.s_t0))+b.DotVV(_,b.SubVV(b.AddVCrossSV(m,l,i,b.s_t0),b.AddVCrossSV(h,a,s,b.s_t1),b.s_t0))}GetRevoluteJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a}GetRevoluteJointSpeed(){const t=this.m_bodyA.m_angularVelocity;return this.m_bodyB.m_angularVelocity-t}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMotorTorque(t){return t*this.m_motorImpulse}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2WheelJointDef = new b2WheelJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=C.MulXV(e,this.m_localAnchorA,Gs.Draw_s_pA),n=C.MulXV(s,this.m_localAnchorB,Gs.Draw_s_pB),o=f.MulRV(e.q,this.m_localXAxisA,Gs.Draw_s_axis),r=Gs.Draw_s_c1,_=Gs.Draw_s_c2,h=Gs.Draw_s_c3,m=Gs.Draw_s_c4,a=Gs.Draw_s_c5;if(t.DrawSegment(i,n,a),this.m_enableLimit){const s=b.AddVMulSV(i,this.m_lowerTranslation,o,Gs.Draw_s_lower),n=b.AddVMulSV(i,this.m_upperTranslation,o,Gs.Draw_s_upper),m=f.MulRV(e.q,this.m_localYAxisA,Gs.Draw_s_perp);t.DrawSegment(s,n,r),t.DrawSegment(b.AddVMulSV(s,-.5,m,b.s_t0),b.AddVMulSV(s,.5,m,b.s_t1),_),t.DrawSegment(b.AddVMulSV(n,-.5,m,b.s_t0),b.AddVMulSV(n,.5,m,b.s_t1),h)}else t.DrawSegment(b.AddVMulSV(i,-1,o,b.s_t0),b.AddVMulSV(i,1,o,b.s_t1),r);t.DrawPoint(i,5,r),t.DrawPoint(n,5,m)}}Gs.InitVelocityConstraints_s_d=new b,Gs.InitVelocityConstraints_s_P=new b,Gs.SolveVelocityConstraints_s_P=new b,Gs.SolvePositionConstraints_s_d=new b,Gs.SolvePositionConstraints_s_P=new b,Gs.Draw_s_pA=new b,Gs.Draw_s_pB=new b,Gs.Draw_s_axis=new b,Gs.Draw_s_c1=new e(.7,.7,.7),Gs.Draw_s_c2=new e(.3,.9,.3),Gs.Draw_s_c3=new e(.9,.3,.3),Gs.Draw_s_c4=new e(.3,.3,.9),Gs.Draw_s_c5=new e(.4,.4,.4),Gs.Draw_s_lower=new b,Gs.Draw_s_upper=new b,Gs.Draw_s_perp=new b;class Ps{constructor(t){this.m_contactManager=new ls,this.m_bodyList=null,this.m_jointList=null,this.m_bodyCount=0,this.m_jointCount=0,this.m_gravity=new b,this.m_allowSleep=!0,this.m_destructionListener=null,this.m_debugDraw=null,this.m_inv_dt0=0,this.m_newContacts=!1,this.m_locked=!1,this.m_clearForces=!0,this.m_warmStarting=!0,this.m_continuousPhysics=!0,this.m_subStepping=!1,this.m_stepComplete=!0,this.m_profile=new cs,this.m_island=new Bs,this.s_stack=[],this.m_gravity.Copy(t)}SetDestructionListener(t){this.m_destructionListener=t}SetContactFilter(t){this.m_contactManager.m_contactFilter=t}SetContactListener(t){this.m_contactManager.m_contactListener=t}SetDebugDraw(t){this.m_debugDraw=t}CreateBody(t={}){if(this.IsLocked())throw new Error;const e=new Qe(t,this);return e.m_prev=null,e.m_next=this.m_bodyList,this.m_bodyList&&(this.m_bodyList.m_prev=e),this.m_bodyList=e,++this.m_bodyCount,e}DestroyBody(t){if(this.IsLocked())throw new Error;let e=t.m_jointList;for(;e;){const s=e;e=e.next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeJoint(s.joint),this.DestroyJoint(s.joint),t.m_jointList=e}t.m_jointList=null;let s=t.m_contactList;for(;s;){const t=s;s=s.next,this.m_contactManager.Destroy(t.contact)}t.m_contactList=null;let i=t.m_fixtureList;for(;i;){const e=i;i=i.m_next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeFixture(e),e.DestroyProxies(),e.Reset(),t.m_fixtureList=i,t.m_fixtureCount-=1}t.m_fixtureList=null,t.m_fixtureCount=0,t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_bodyList&&(this.m_bodyList=t.m_next),--this.m_bodyCount}static _Joint_Create(e){switch(e.type){case t.b2JointType.e_distanceJoint:return new Oe(e);case t.b2JointType.e_mouseJoint:return new gs(e);case t.b2JointType.e_prismaticJoint:return new Ms(e);case t.b2JointType.e_revoluteJoint:return new Ds(e);case t.b2JointType.e_pulleyJoint:return new Is(e);case t.b2JointType.e_gearJoint:return new ws(e);case t.b2JointType.e_wheelJoint:return new Gs(e);case t.b2JointType.e_weldJoint:return new Ts(e);case t.b2JointType.e_frictionJoint:return new Cs(e);case t.b2JointType.e_motorJoint:return new vs(e);case t.b2JointType.e_areaJoint:return new Ne(e)}throw new Error}static _Joint_Destroy(t){}CreateJoint(t){if(this.IsLocked())throw new Error;const e=Ps._Joint_Create(t);e.m_prev=null,e.m_next=this.m_jointList,this.m_jointList&&(this.m_jointList.m_prev=e),this.m_jointList=e,++this.m_jointCount,e.m_edgeA.prev=null,e.m_edgeA.next=e.m_bodyA.m_jointList,e.m_bodyA.m_jointList&&(e.m_bodyA.m_jointList.prev=e.m_edgeA),e.m_bodyA.m_jointList=e.m_edgeA,e.m_edgeB.prev=null,e.m_edgeB.next=e.m_bodyB.m_jointList,e.m_bodyB.m_jointList&&(e.m_bodyB.m_jointList.prev=e.m_edgeB),e.m_bodyB.m_jointList=e.m_edgeB;const s=e.m_bodyA,i=e.m_bodyB;if(!e.m_collideConnected){let t=i.GetContactList();for(;t;)t.other===s&&t.contact.FlagForFiltering(),t=t.next}return e}DestroyJoint(t){if(this.IsLocked())throw new Error;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_jointList&&(this.m_jointList=t.m_next);const e=t.m_bodyA,s=t.m_bodyB,i=t.m_collideConnected;if(e.SetAwake(!0),s.SetAwake(!0),t.m_edgeA.prev&&(t.m_edgeA.prev.next=t.m_edgeA.next),t.m_edgeA.next&&(t.m_edgeA.next.prev=t.m_edgeA.prev),t.m_edgeA===e.m_jointList&&(e.m_jointList=t.m_edgeA.next),t.m_edgeA.Reset(),t.m_edgeB.prev&&(t.m_edgeB.prev.next=t.m_edgeB.next),t.m_edgeB.next&&(t.m_edgeB.next.prev=t.m_edgeB.prev),t.m_edgeB===s.m_jointList&&(s.m_jointList=t.m_edgeB.next),t.m_edgeB.Reset(),Ps._Joint_Destroy(t),--this.m_jointCount,!i){let t=s.GetContactList();for(;t;)t.other===e&&t.contact.FlagForFiltering(),t=t.next}}Step(t,e,s){const i=Ps.Step_s_stepTimer.Reset();this.m_newContacts&&(this.m_contactManager.FindNewContacts(),this.m_newContacts=!1),this.m_locked=!0;const n=Ps.Step_s_step;n.dt=t,n.velocityIterations=e,n.positionIterations=s,n.inv_dt=t>0?1/t:0,n.dtRatio=this.m_inv_dt0*t,n.warmStarting=this.m_warmStarting;const o=Ps.Step_s_timer.Reset();if(this.m_contactManager.Collide(),this.m_profile.collide=o.GetMilliseconds(),this.m_stepComplete&&n.dt>0){const t=Ps.Step_s_timer.Reset();this.Solve(n),this.m_profile.solve=t.GetMilliseconds()}if(this.m_continuousPhysics&&n.dt>0){const t=Ps.Step_s_timer.Reset();this.SolveTOI(n),this.m_profile.solveTOI=t.GetMilliseconds()}n.dt>0&&(this.m_inv_dt0=n.inv_dt),this.m_clearForces&&this.ClearForces(),this.m_locked=!1,this.m_profile.step=i.GetMilliseconds()}ClearForces(){for(let t=this.m_bodyList;t;t=t.m_next)t.m_force.SetZero(),t.m_torque=0}DebugDraw(){if(null===this.m_debugDraw)return;const s=this.m_debugDraw.GetFlags(),i=Ps.DebugDraw_s_color.SetRGB(0,0,0);if(s&t.b2DrawFlags.e_shapeBit)for(let s=this.m_bodyList;s;s=s.m_next){const n=s.m_xf;this.m_debugDraw.PushTransform(n);for(let n=s.GetFixtureList();n;n=n.m_next)s.GetType()===t.b2BodyType.b2_dynamicBody&&0===s.m_mass?this.DrawShape(n,new e(1,0,0)):s.IsEnabled()?s.GetType()===t.b2BodyType.b2_staticBody?(i.SetRGB(.5,.9,.5),this.DrawShape(n,i)):s.GetType()===t.b2BodyType.b2_kinematicBody?(i.SetRGB(.5,.5,.9),this.DrawShape(n,i)):s.IsAwake()?(i.SetRGB(.9,.7,.7),this.DrawShape(n,i)):(i.SetRGB(.6,.6,.6),this.DrawShape(n,i)):(i.SetRGB(.5,.5,.3),this.DrawShape(n,i));this.m_debugDraw.PopTransform(n)}if(s&t.b2DrawFlags.e_jointBit)for(let t=this.m_jointList;t;t=t.m_next)t.Draw(this.m_debugDraw);if(s&t.b2DrawFlags.e_pairBit){i.SetRGB(.3,.9,.9);for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){const e=t.GetFixtureA(),s=t.GetFixtureB(),n=t.GetChildIndexA(),o=t.GetChildIndexB(),r=e.GetAABB(n).GetCenter(),_=s.GetAABB(o).GetCenter();this.m_debugDraw.DrawSegment(r,_,i)}}if(s&t.b2DrawFlags.e_aabbBit){i.SetRGB(.9,.3,.9);const t=Ps.DebugDraw_s_vs;for(let e=this.m_bodyList;e;e=e.m_next)if(e.IsEnabled())for(let s=e.GetFixtureList();s;s=s.m_next)for(let e=0;e<s.m_proxyCount;++e){const n=s.m_proxies[e].treeNode.aabb;t[0].Set(n.lowerBound.x,n.lowerBound.y),t[1].Set(n.upperBound.x,n.lowerBound.y),t[2].Set(n.upperBound.x,n.upperBound.y),t[3].Set(n.lowerBound.x,n.upperBound.y),this.m_debugDraw.DrawPolygon(t,4,i)}}if(s&t.b2DrawFlags.e_centerOfMassBit)for(let t=this.m_bodyList;t;t=t.m_next){const e=Ps.DebugDraw_s_xf;e.q.Copy(t.m_xf.q),e.p.Copy(t.GetWorldCenter()),this.m_debugDraw.DrawTransform(e)}}QueryAABB(...t){t[0]instanceof ms?this._QueryAABB(t[0],t[1]):this._QueryAABB(null,t[0],t[1])}_QueryAABB(t,e,s){this.m_contactManager.m_broadPhase.Query(e,e=>{const i=e.userData.fixture;return t?t.ReportFixture(i):!s||s(i)})}QueryAllAABB(t,e=[]){return this.QueryAABB(t,t=>(e.push(t),!0)),e}QueryPointAABB(...t){t[0]instanceof ms?this._QueryPointAABB(t[0],t[1]):this._QueryPointAABB(null,t[0],t[1])}_QueryPointAABB(t,e,s){this.m_contactManager.m_broadPhase.QueryPoint(e,e=>{const i=e.userData.fixture;return t?t.ReportFixture(i):!s||s(i)})}QueryAllPointAABB(t,e=[]){return this.QueryPointAABB(t,t=>(e.push(t),!0)),e}QueryFixtureShape(...t){t[0]instanceof ms?this._QueryFixtureShape(t[0],t[1],t[2],t[3]):this._QueryFixtureShape(null,t[0],t[1],t[2],t[3])}_QueryFixtureShape(t,e,s,i,n){const o=Ps.QueryFixtureShape_s_aabb;e.ComputeAABB(o,i,s),this.m_contactManager.m_broadPhase.Query(o,o=>{const r=o.userData,_=r.fixture;if(b2TestOverlapShape(e,s,_.GetShape(),r.childIndex,i,_.GetBody().GetTransform())){if(t)return t.ReportFixture(_);if(n)return n(_)}return!0})}QueryAllFixtureShape(t,e,s,i=[]){return this.QueryFixtureShape(t,e,s,t=>(i.push(t),!0)),i}QueryFixturePoint(...t){t[0]instanceof ms?this._QueryFixturePoint(t[0],t[1]):this._QueryFixturePoint(null,t[0],t[1])}_QueryFixturePoint(t,e,s){this.m_contactManager.m_broadPhase.QueryPoint(e,i=>{const n=i.userData.fixture;if(n.TestPoint(e)){if(t)return t.ReportFixture(n);if(s)return s(n)}return!0})}QueryAllFixturePoint(t,e=[]){return this.QueryFixturePoint(t,t=>(e.push(t),!0)),e}RayCast(...t){t[0]instanceof as?this._RayCast(t[0],t[1],t[2]):this._RayCast(null,t[0],t[1],t[2])}_RayCast(t,e,s,i){const n=Ps.RayCast_s_input;n.maxFraction=1,n.p1.Copy(e),n.p2.Copy(s),this.m_contactManager.m_broadPhase.RayCast(n,(n,o)=>{const r=o.userData,_=r.fixture,h=r.childIndex,m=Ps.RayCast_s_output;if(_.RayCast(m,n,h)){const n=m.fraction,o=Ps.RayCast_s_point;if(o.Set((1-n)*e.x+n*s.x,(1-n)*e.y+n*s.y),t)return t.ReportFixture(_,o,m.normal,n);if(i)return i(_,o,m.normal,n)}return n.maxFraction})}RayCastOne(t,e){let s=null,i=1;return this.RayCast(t,e,(t,e,n,o)=>(o<i&&(i=o,s=t),i)),s}RayCastAll(t,e,s=[]){return this.RayCast(t,e,(t,e,i,n)=>(s.push(t),1)),s}GetBodyList(){return this.m_bodyList}GetJointList(){return this.m_jointList}GetContactList(){return this.m_contactManager.m_contactList}SetAllowSleeping(t){if(t!==this.m_allowSleep&&(this.m_allowSleep=t,!this.m_allowSleep))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetAllowSleeping(){return this.m_allowSleep}SetWarmStarting(t){this.m_warmStarting=t}GetWarmStarting(){return this.m_warmStarting}SetContinuousPhysics(t){this.m_continuousPhysics=t}GetContinuousPhysics(){return this.m_continuousPhysics}SetSubStepping(t){this.m_subStepping=t}GetSubStepping(){return this.m_subStepping}GetProxyCount(){return this.m_contactManager.m_broadPhase.GetProxyCount()}GetBodyCount(){return this.m_bodyCount}GetJointCount(){return this.m_jointCount}GetContactCount(){return this.m_contactManager.m_contactCount}GetTreeHeight(){return this.m_contactManager.m_broadPhase.GetTreeHeight()}GetTreeBalance(){return this.m_contactManager.m_broadPhase.GetTreeBalance()}GetTreeQuality(){return this.m_contactManager.m_broadPhase.GetTreeQuality()}SetGravity(t,e=!0){if(!b.IsEqualToV(this.m_gravity,t)&&(this.m_gravity.Copy(t),e))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetGravity(){return this.m_gravity}IsLocked(){return this.m_locked}SetAutoClearForces(t){this.m_clearForces=t}GetAutoClearForces(){return this.m_clearForces}ShiftOrigin(t){if(this.IsLocked())throw new Error;for(let e=this.m_bodyList;e;e=e.m_next)e.m_xf.p.SelfSub(t),e.m_sweep.c0.SelfSub(t),e.m_sweep.c.SelfSub(t);for(let e=this.m_jointList;e;e=e.m_next)e.ShiftOrigin(t);this.m_contactManager.m_broadPhase.ShiftOrigin(t)}GetContactManager(){return this.m_contactManager}GetProfile(){return this.m_profile}Dump(e){if(this.m_locked)return;e("const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\n",this.m_gravity.x,this.m_gravity.y),e("this.m_world.SetGravity(g);\n"),e("const bodies: b2Body[] = [];\n"),e("const joints: b2Joint[] = [];\n");let s=0;for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandIndex=s,t.Dump(e),++s;s=0;for(let t=this.m_jointList;t;t=t.m_next)t.m_index=s,++s;for(let s=this.m_jointList;s;s=s.m_next)s.m_type!==t.b2JointType.e_gearJoint&&(e("{\n"),s.Dump(e),e("}\n"));for(let s=this.m_jointList;s;s=s.m_next)s.m_type===t.b2JointType.e_gearJoint&&(e("{\n"),s.Dump(e),e("}\n"))}DrawShape(e,s){if(null===this.m_debugDraw)return;const i=e.GetShape();switch(i.m_type){case t.b2ShapeType.e_circleShape:{const t=i,e=t.m_p,n=t.m_radius,o=b.UNITX;this.m_debugDraw.DrawSolidCircle(e,n,o,s);break}case t.b2ShapeType.e_edgeShape:{const t=i,e=t.m_vertex1,n=t.m_vertex2;this.m_debugDraw.DrawSegment(e,n,s),!1===t.m_oneSided&&(this.m_debugDraw.DrawPoint(e,4,s),this.m_debugDraw.DrawPoint(n,4,s));break}case t.b2ShapeType.e_chainShape:{const t=i,e=t.m_count,n=t.m_vertices;let o=n[0];for(let t=1;t<e;++t){const e=n[t];this.m_debugDraw.DrawSegment(o,e,s),o=e}break}case t.b2ShapeType.e_polygonShape:{const t=i,e=t.m_count,n=t.m_vertices;this.m_debugDraw.DrawSolidPolygon(n,e,s);break}}}Solve(e){this.m_profile.solveInit=0,this.m_profile.solveVelocity=0,this.m_profile.solvePosition=0;const s=this.m_island;s.Initialize(this.m_bodyCount,this.m_contactManager.m_contactCount,this.m_jointCount,this.m_contactManager.m_contactListener);for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_jointList;t;t=t.m_next)t.m_islandFlag=!1;const i=this.s_stack;for(let n=this.m_bodyList;n;n=n.m_next){if(n.m_islandFlag)continue;if(!n.IsAwake()||!n.IsEnabled())continue;if(n.GetType()===t.b2BodyType.b2_staticBody)continue;s.Clear();let o=0;for(i[o++]=n,n.m_islandFlag=!0;o>0;){const e=i[--o];if(!e)throw new Error;if(s.AddBody(e),e.GetType()!==t.b2BodyType.b2_staticBody){e.m_awakeFlag=!0;for(let t=e.m_contactList;t;t=t.next){const e=t.contact;if(e.m_islandFlag)continue;if(!e.IsEnabled()||!e.IsTouching())continue;const n=e.m_fixtureA.m_isSensor,r=e.m_fixtureB.m_isSensor;if(n||r)continue;s.AddContact(e),e.m_islandFlag=!0;const _=t.other;_.m_islandFlag||(i[o++]=_,_.m_islandFlag=!0)}for(let t=e.m_jointList;t;t=t.next){if(t.joint.m_islandFlag)continue;const e=t.other;e.IsEnabled()&&(s.AddJoint(t.joint),t.joint.m_islandFlag=!0,e.m_islandFlag||(i[o++]=e,e.m_islandFlag=!0))}}}const r=new cs;s.Solve(r,e,this.m_gravity,this.m_allowSleep),this.m_profile.solveInit+=r.solveInit,this.m_profile.solveVelocity+=r.solveVelocity,this.m_profile.solvePosition+=r.solvePosition;for(let e=0;e<s.m_bodyCount;++e){const i=s.m_bodies[e];i.GetType()===t.b2BodyType.b2_staticBody&&(i.m_islandFlag=!1)}}for(let t=0;t<i.length&&i[t];++t)i[t]=null;const n=new B;for(let e=this.m_bodyList;e;e=e.m_next)e.m_islandFlag&&e.GetType()!==t.b2BodyType.b2_staticBody&&e.SynchronizeFixtures();this.m_contactManager.FindNewContacts(),this.m_profile.broadphase=n.GetMilliseconds()}SolveTOI(e){const s=this.m_island;if(s.Initialize(64,32,0,this.m_contactManager.m_contactListener),this.m_stepComplete){for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1,t.m_sweep.alpha0=0;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_toiFlag=!1,t.m_islandFlag=!1,t.m_toiCount=0,t.m_toi=1}for(;;){let i=null,n=1;for(let e=this.m_contactManager.m_contactList;e;e=e.m_next){if(!e.IsEnabled())continue;if(e.m_toiCount>8)continue;let s=1;if(e.m_toiFlag)s=e.m_toi;else{const i=e.GetFixtureA(),n=e.GetFixtureB();if(i.IsSensor()||n.IsSensor())continue;const o=i.GetBody(),r=n.GetBody(),_=o.m_type,h=r.m_type,m=o.IsAwake()&&_!==t.b2BodyType.b2_staticBody,a=r.IsAwake()&&h!==t.b2BodyType.b2_staticBody;if(!m&&!a)continue;const l=o.IsBullet()||_!==t.b2BodyType.b2_dynamicBody,c=r.IsBullet()||h!==t.b2BodyType.b2_dynamicBody;if(!l&&!c)continue;let u=o.m_sweep.alpha0;o.m_sweep.alpha0<r.m_sweep.alpha0?(u=r.m_sweep.alpha0,o.m_sweep.Advance(u)):r.m_sweep.alpha0<o.m_sweep.alpha0&&(u=o.m_sweep.alpha0,r.m_sweep.Advance(u));const d=e.GetChildIndexA(),p=e.GetChildIndexB(),y=Ps.SolveTOI_s_toi_input;y.proxyA.SetShape(i.GetShape(),d),y.proxyB.SetShape(n.GetShape(),p),y.sweepA.Copy(o.m_sweep),y.sweepB.Copy(r.m_sweep),y.tMax=1;const b=Ps.SolveTOI_s_toi_output;b2TimeOfImpact(b,y);const x=b.t;s=b.state===t.b2TOIOutputState.e_touching?b2Min(u+(1-u)*x,1):1,e.m_toi=s,e.m_toiFlag=!0}s<n&&(i=e,n=s)}if(null===i||.9999<n){this.m_stepComplete=!0;break}const o=i.GetFixtureA(),r=i.GetFixtureB(),_=o.GetBody(),h=r.GetBody(),m=Ps.SolveTOI_s_backup1.Copy(_.m_sweep),a=Ps.SolveTOI_s_backup2.Copy(h.m_sweep);if(_.Advance(n),h.Advance(n),i.Update(this.m_contactManager.m_contactListener),i.m_toiFlag=!1,++i.m_toiCount,!i.IsEnabled()||!i.IsTouching()){i.SetEnabled(!1),_.m_sweep.Copy(m),h.m_sweep.Copy(a),_.SynchronizeTransform(),h.SynchronizeTransform();continue}_.SetAwake(!0),h.SetAwake(!0),s.Clear(),s.AddBody(_),s.AddBody(h),s.AddContact(i),_.m_islandFlag=!0,h.m_islandFlag=!0,i.m_islandFlag=!0;for(let e=0;e<2;++e){const i=0===e?_:h;if(i.m_type===t.b2BodyType.b2_dynamicBody)for(let e=i.m_contactList;e&&s.m_bodyCount!==s.m_bodyCapacity&&s.m_contactCount!==s.m_contactCapacity;e=e.next){const o=e.contact;if(o.m_islandFlag)continue;const r=e.other;if(r.m_type===t.b2BodyType.b2_dynamicBody&&!i.IsBullet()&&!r.IsBullet())continue;const _=o.m_fixtureA.m_isSensor,h=o.m_fixtureB.m_isSensor;if(_||h)continue;const m=Ps.SolveTOI_s_backup.Copy(r.m_sweep);r.m_islandFlag||r.Advance(n),o.Update(this.m_contactManager.m_contactListener),o.IsEnabled()&&o.IsTouching()?(o.m_islandFlag=!0,s.AddContact(o),r.m_islandFlag||(r.m_islandFlag=!0,r.m_type!==t.b2BodyType.b2_staticBody&&r.SetAwake(!0),s.AddBody(r))):(r.m_sweep.Copy(m),r.SynchronizeTransform())}}const l=Ps.SolveTOI_s_subStep;l.dt=(1-n)*e.dt,l.inv_dt=1/l.dt,l.dtRatio=1,l.positionIterations=20,l.velocityIterations=e.velocityIterations,l.warmStarting=!1,s.SolveTOI(l,_.m_islandIndex,h.m_islandIndex);for(let e=0;e<s.m_bodyCount;++e){const i=s.m_bodies[e];if(i.m_islandFlag=!1,i.m_type===t.b2BodyType.b2_dynamicBody){i.SynchronizeFixtures();for(let t=i.m_contactList;t;t=t.next)t.contact.m_toiFlag=!1,t.contact.m_islandFlag=!1}}if(this.m_contactManager.FindNewContacts(),this.m_subStepping){this.m_stepComplete=!1;break}}}}var Ls,Rs;Ps.Step_s_step=new us,Ps.Step_s_stepTimer=new B,Ps.Step_s_timer=new B,Ps.DebugDraw_s_color=new e(0,0,0),Ps.DebugDraw_s_vs=b.MakeArray(4),Ps.DebugDraw_s_xf=new C,Ps.QueryFixtureShape_s_aabb=new ht,Ps.RayCast_s_input=new rt,Ps.RayCast_s_output=new _t,Ps.RayCast_s_point=new b,Ps.SolveTOI_s_subStep=new us,Ps.SolveTOI_s_backup=new w,Ps.SolveTOI_s_backup1=new w,Ps.SolveTOI_s_backup2=new w,Ps.SolveTOI_s_toi_input=new fe,Ps.SolveTOI_s_toi_output=new Be,t.b2StretchingModel=void 0,(Ls=t.b2StretchingModel||(t.b2StretchingModel={}))[Ls.b2_pbdStretchingModel=0]="b2_pbdStretchingModel",Ls[Ls.b2_xpbdStretchingModel=1]="b2_xpbdStretchingModel",t.b2BendingModel=void 0,(Rs=t.b2BendingModel||(t.b2BendingModel={}))[Rs.b2_springAngleBendingModel=0]="b2_springAngleBendingModel",Rs[Rs.b2_pbdAngleBendingModel=1]="b2_pbdAngleBendingModel",Rs[Rs.b2_xpbdAngleBendingModel=2]="b2_xpbdAngleBendingModel",Rs[Rs.b2_pbdDistanceBendingModel=3]="b2_pbdDistanceBendingModel",Rs[Rs.b2_pbdHeightBendingModel=4]="b2_pbdHeightBendingModel",Rs[Rs.b2_pbdTriangleBendingModel=5]="b2_pbdTriangleBendingModel";class Fs{constructor(){this.stretchingModel=t.b2StretchingModel.b2_pbdStretchingModel,this.bendingModel=t.b2BendingModel.b2_pbdAngleBendingModel,this.damping=0,this.stretchStiffness=1,this.stretchHertz=0,this.stretchDamping=0,this.bendStiffness=.5,this.bendHertz=1,this.bendDamping=0,this.isometric=!1,this.fixedEffectiveMass=!1,this.warmStart=!1}Copy(t){return this.stretchingModel=t.stretchingModel,this.bendingModel=t.bendingModel,this.damping=t.damping,this.stretchStiffness=t.stretchStiffness,this.stretchHertz=t.stretchHertz,this.stretchDamping=t.stretchDamping,this.bendStiffness=t.bendStiffness,this.bendHertz=t.bendHertz,this.bendDamping=t.bendDamping,this.isometric=t.isometric,this.fixedEffectiveMass=t.fixedEffectiveMass,this.warmStart=t.warmStart,this}}class ks{constructor(){this.i1=0,this.i2=0,this.invMass1=0,this.invMass2=0,this.L=0,this.lambda=0,this.spring=0,this.damper=0}}class qs{constructor(){this.i1=0,this.i2=0,this.i3=0,this.invMass1=0,this.invMass2=0,this.invMass3=0,this.invEffectiveMass=0,this.lambda=0,this.L1=0,this.L2=0,this.alpha1=0,this.alpha2=0,this.spring=0,this.damper=0}}const Js=t.b2BodyType.b2_staticBody,zs=t.b2BodyType.b2_kinematicBody,js=t.b2BodyType.b2_dynamicBody,Os=t.b2BendingModel.b2_springAngleBendingModel,Ns=t.b2BendingModel.b2_pbdAngleBendingModel,Xs=t.b2BendingModel.b2_xpbdAngleBendingModel,Es=t.b2BendingModel.b2_pbdDistanceBendingModel,Zs=t.b2BendingModel.b2_pbdHeightBendingModel,Ws=t.b2BendingModel.b2_pbdTriangleBendingModel,Qs=t.b2StretchingModel.b2_pbdStretchingModel,Ys=t.b2StretchingModel.b2_xpbdStretchingModel;return t.b2AABB=ht,t.b2Abs=h,t.b2Acos=d,t.b2Alloc=function(t){return null},t.b2AngularStiffness=function(t,e,s,i,o){const r=i.GetInertia(),_=o.GetInertia();let h;h=r>0&&_>0?r*_/(r+_):r>0?r:_;const m=2*n*e;t.stiffness=h*m*m,t.damping=2*h*s*m},t.b2AreaJoint=Ne,t.b2AreaJointDef=class extends Je{constructor(){super(t.b2JointType.e_areaJoint),this.bodies=[],this.stiffness=0,this.damping=0}AddBody(t){this.bodies.push(t),1===this.bodies.length?this.bodyA=t:2===this.bodies.length&&(this.bodyB=t)}},t.b2Asin=p,t.b2Assert=function(t,...e){if(!t)throw new Error(...e)},t.b2Atan2=y,t.b2BlockAllocator=class{},t.b2Body=Qe,t.b2BodyDef=class{constructor(){this.type=t.b2BodyType.b2_staticBody,this.position=new b(0,0),this.angle=0,this.linearVelocity=new b(0,0),this.angularVelocity=0,this.linearDamping=0,this.angularDamping=0,this.allowSleep=!0,this.awake=!0,this.fixedRotation=!1,this.bullet=!1,this.enabled=!0,this.userData=null,this.gravityScale=1}},t.b2BroadPhase=pt,t.b2ChainAndCircleContact=Ue,t.b2ChainAndPolygonContact=He,t.b2ChainShape=bt,t.b2CircleContact=$e,t.b2CircleShape=xt,t.b2Clamp=b2Clamp,t.b2ClipSegmentToLine=b2ClipSegmentToLine,t.b2ClipVertex=ot,t.b2CollideCircles=b2CollideCircles,t.b2CollideEdgeAndCircle=b2CollideEdgeAndCircle,t.b2CollideEdgeAndPolygon=b2CollideEdgeAndPolygon,t.b2CollidePolygonAndCircle=b2CollidePolygonAndCircle,t.b2CollidePolygons=b2CollidePolygons,t.b2Color=e,t.b2Contact=Ke,t.b2ContactEdge=Ye,t.b2ContactFactory=os,t.b2ContactFeature=tt,t.b2ContactFilter=rs,t.b2ContactID=et,t.b2ContactImpulse=_s,t.b2ContactListener=hs,t.b2ContactManager=ls,t.b2ContactPositionConstraint=As,t.b2ContactRegister=ns,t.b2ContactSolver=fs,t.b2ContactSolverDef=Ss,t.b2ContactVelocityConstraint=xs,t.b2Cos=c,t.b2Counter=class{constructor(){this.m_count=0,this.m_min_count=0,this.m_max_count=0}GetCount(){return this.m_count}GetMinCount(){return this.m_min_count}GetMaxCount(){return this.m_max_count}ResetCount(){const t=this.m_count;return this.m_count=0,t}ResetMinCount(){this.m_min_count=0}ResetMaxCount(){this.m_max_count=0}Increment(){this.m_count++,this.m_max_count<this.m_count&&(this.m_max_count=this.m_count)}Decrement(){this.m_count--,this.m_min_count>this.m_count&&(this.m_min_count=this.m_count)}},t.b2DegToRad=function(t){return.017453292519944444*t},t.b2DestructionListener=class{SayGoodbyeJoint(t){}SayGoodbyeFixture(t){}},t.b2Distance=b2Distance,t.b2DistanceInput=T,t.b2DistanceJoint=Oe,t.b2DistanceJointDef=je,t.b2DistanceOutput=G,t.b2DistanceProxy=I,t.b2Draw=class{constructor(){this.m_drawFlags=0}SetFlags(t){this.m_drawFlags=t}GetFlags(){return this.m_drawFlags}AppendFlags(t){this.m_drawFlags|=t}ClearFlags(t){this.m_drawFlags&=~t}},t.b2DynamicTree=ut,t.b2EdgeAndCircleContact=ss,t.b2EdgeAndPolygonContact=is,t.b2EdgeShape=yt,t.b2Filter=Xe,t.b2Fixture=We,t.b2FixtureDef=Ee,t.b2FixtureProxy=Ze,t.b2Free=function(t){},t.b2FrictionJoint=Cs,t.b2FrictionJointDef=class extends Je{constructor(){super(t.b2JointType.e_frictionJoint),this.localAnchorA=new b,this.localAnchorB=new b,this.maxForce=0,this.maxTorque=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB)}},t.b2GearJoint=ws,t.b2GearJointDef=class extends Je{constructor(){super(t.b2JointType.e_gearJoint),this.ratio=1}},t.b2GetPointStates=function(e,s,i,n){let o;for(o=0;o<i.pointCount;++o){const s=i.points[o].id.key;e[o]=t.b2PointState.b2_removeState;for(let i=0,r=n.pointCount;i<r;++i)if(n.points[i].id.key===s){e[o]=t.b2PointState.b2_persistState;break}}for(;o<2;++o)e[o]=t.b2PointState.b2_nullState;for(o=0;o<n.pointCount;++o){const e=n.points[o].id.key;s[o]=t.b2PointState.b2_addState;for(let n=0,r=i.pointCount;n<r;++n)if(i.points[n].id.key===e){s[o]=t.b2PointState.b2_persistState;break}}for(;o<2;++o)s[o]=t.b2PointState.b2_nullState},t.b2GrowableStack=_,t.b2InvSqrt=function(t){return 1/Math.sqrt(t)},t.b2IsPowerOfTwo=function(t){return t>0&&0==(t&t-1)},t.b2IsValid=m,t.b2Island=Bs,t.b2Jacobian=class{constructor(){this.linear=new b,this.angularA=0,this.angularB=0}SetZero(){return this.linear.SetZero(),this.angularA=0,this.angularB=0,this}Set(t,e,s){return this.linear.Copy(t),this.angularA=e,this.angularB=s,this}},t.b2Joint=ze,t.b2JointDef=Je,t.b2JointEdge=qe,t.b2LinearStiffness=function(t,e,s,i,o){const r=i.GetMass(),_=o.GetMass();let h;h=r>0&&_>0?r*_/(r+_):r>0?r:_;const m=2*n*e;t.stiffness=h*m*m,t.damping=2*h*s*m},t.b2Log=function(t,...e){},t.b2MakeArray=b2MakeArray,t.b2MakeNullArray=function(t){const e=new Array(t);for(let s=0;s<t;++s)e[s]=null;return e},t.b2MakeNumberArray=b2MakeNumberArray,t.b2Manifold=it,t.b2ManifoldPoint=st,t.b2MassData=v,t.b2Mat22=S,t.b2Mat33=V,t.b2Max=b2Max,t.b2Maybe=b2Maybe,t.b2Min=b2Min,t.b2MixFriction=b2MixFriction,t.b2MixRestitution=b2MixRestitution,t.b2MixRestitutionThreshold=b2MixRestitutionThreshold,t.b2MotorJoint=vs,t.b2MotorJointDef=class extends Je{constructor(){super(t.b2JointType.e_motorJoint),this.linearOffset=new b(0,0),this.angularOffset=0,this.maxForce=1,this.maxTorque=1,this.correctionFactor=.3}Initialize(t,e){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(this.bodyB.GetPosition(),this.linearOffset);const s=this.bodyA.GetAngle(),i=this.bodyB.GetAngle();this.angularOffset=i-s}},t.b2MouseJoint=gs,t.b2MouseJointDef=class extends Je{constructor(){super(t.b2JointType.e_mouseJoint),this.target=new b,this.maxForce=0,this.stiffness=5,this.damping=.7}},t.b2NextPowerOfTwo=function(t){return t|=t>>1&2147483647,t|=t>>2&1073741823,t|=t>>4&268435455,t|=t>>8&16777215,(t|=t>>16&65535)+1},t.b2Pair=dt,t.b2ParseInt=function(t){return parseInt(t,10)},t.b2ParseUInt=function(t){return Math.abs(parseInt(t,10))},t.b2PolygonAndCircleContact=es,t.b2PolygonContact=ts,t.b2PolygonShape=de,t.b2Position=ds,t.b2PositionSolverManifold=Vs,t.b2Pow=l,t.b2PrismaticJoint=Ms,t.b2PrismaticJointDef=class extends Je{constructor(){super(t.b2JointType.e_prismaticJoint),this.localAnchorA=new b,this.localAnchorB=new b,this.localAxisA=new b(1,0),this.referenceAngle=0,this.enableLimit=!1,this.lowerTranslation=0,this.upperTranslation=0,this.enableMotor=!1,this.maxMotorForce=0,this.motorSpeed=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.bodyA.GetLocalVector(i,this.localAxisA),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}},t.b2Profile=cs,t.b2PulleyJoint=Is,t.b2PulleyJointDef=class extends Je{constructor(){super(t.b2JointType.e_pulleyJoint),this.groundAnchorA=new b(-1,1),this.groundAnchorB=new b(1,1),this.localAnchorA=new b(-1,0),this.localAnchorB=new b(1,0),this.lengthA=0,this.lengthB=0,this.ratio=1,this.collideConnected=!0}Initialize(t,e,s,i,n,o,r){this.bodyA=t,this.bodyB=e,this.groundAnchorA.Copy(s),this.groundAnchorB.Copy(i),this.bodyA.GetLocalPoint(n,this.localAnchorA),this.bodyB.GetLocalPoint(o,this.localAnchorB),this.lengthA=b.DistanceVV(n,s),this.lengthB=b.DistanceVV(o,i),this.ratio=r}},t.b2QueryCallback=ms,t.b2RadToDeg=function(t){return 57.29577951307855*t},t.b2Random=function(){return 2*Math.random()-1},t.b2RandomRange=function(t,e){return(e-t)*Math.random()+t},t.b2RayCastCallback=as,t.b2RayCastInput=rt,t.b2RayCastOutput=_t,t.b2RevoluteJoint=Ds,t.b2RevoluteJointDef=class extends Je{constructor(){super(t.b2JointType.e_revoluteJoint),this.localAnchorA=new b(0,0),this.localAnchorB=new b(0,0),this.referenceAngle=0,this.enableLimit=!1,this.lowerAngle=0,this.upperAngle=0,this.enableMotor=!1,this.motorSpeed=0,this.maxMotorTorque=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}},t.b2Rope=class{constructor(){this.m_position=new b,this.m_count=0,this.m_stretchCount=0,this.m_bendCount=0,this.m_stretchConstraints=[],this.m_bendConstraints=[],this.m_bindPositions=[],this.m_ps=[],this.m_p0s=[],this.m_vs=[],this.m_invMasses=[],this.m_gravity=new b,this.m_tuning=new Fs}Create(t){function make_array(t,e,s){for(let i=0;i<e;++i)t[i]=s(i)}this.m_position.Copy(t.position),this.m_count=t.count,make_array(this.m_bindPositions,this.m_count,()=>new b),make_array(this.m_ps,this.m_count,()=>new b),make_array(this.m_p0s,this.m_count,()=>new b),make_array(this.m_vs,this.m_count,()=>new b),make_array(this.m_invMasses,this.m_count,()=>0);for(let e=0;e<this.m_count;++e){this.m_bindPositions[e].Copy(t.vertices[e]),this.m_ps[e].Copy(t.vertices[e]).SelfAdd(this.m_position),this.m_p0s[e].Copy(t.vertices[e]).SelfAdd(this.m_position),this.m_vs[e].SetZero();const s=t.masses[e];this.m_invMasses[e]=s>0?1/s:0}this.m_stretchCount=this.m_count-1,this.m_bendCount=this.m_count-2,make_array(this.m_stretchConstraints,this.m_stretchCount,()=>new ks),make_array(this.m_bendConstraints,this.m_bendCount,()=>new qs);for(let t=0;t<this.m_stretchCount;++t){const e=this.m_stretchConstraints[t],s=this.m_ps[t],i=this.m_ps[t+1];e.i1=t,e.i2=t+1,e.L=b.DistanceVV(s,i),e.invMass1=this.m_invMasses[t],e.invMass2=this.m_invMasses[t+1],e.lambda=0,e.damper=0,e.spring=0}for(let t=0;t<this.m_bendCount;++t){const e=this.m_bendConstraints[t],s=this.m_ps[t],i=this.m_ps[t+1],n=this.m_ps[t+2];e.i1=t,e.i2=t+1,e.i3=t+2,e.invMass1=this.m_invMasses[t],e.invMass2=this.m_invMasses[t+1],e.invMass3=this.m_invMasses[t+2],e.invEffectiveMass=0,e.L1=b.DistanceVV(s,i),e.L2=b.DistanceVV(i,n),e.lambda=0;const o=b.SubVV(i,s,new b),r=b.SubVV(n,i,new b),_=o.LengthSquared(),h=r.LengthSquared();if(_*h==0)continue;const m=(new b).Copy(o).SelfSkew().SelfMul(-1/_),a=(new b).Copy(r).SelfSkew().SelfMul(1/h),l=m.Clone().SelfNeg(),c=m.Clone().SelfSub(a),u=a.Clone();e.invEffectiveMass=e.invMass1*b.DotVV(l,l)+e.invMass2*b.DotVV(c,c)+e.invMass3*b.DotVV(u,u);const d=b.SubVV(n,s,new b),p=d.LengthSquared();0!==p&&(e.alpha1=b.DotVV(r,d)/p,e.alpha2=b.DotVV(o,d)/p)}this.m_gravity.Copy(t.gravity),this.SetTuning(t.tuning)}SetTuning(t){this.m_tuning.Copy(t);const e=2*n*this.m_tuning.bendHertz;for(let t=0;t<this.m_bendCount;++t){const s=this.m_bendConstraints[t],i=s.L1*s.L1,n=s.L2*s.L2;if(i*n==0){s.spring=0,s.damper=0;continue}const o=1/s.L1+1/s.L2,r=s.invMass1/i+s.invMass2*o*o+s.invMass3/n;if(0===r){s.spring=0,s.damper=0;continue}const _=1/r;s.spring=_*e*e,s.damper=2*_*this.m_tuning.bendDamping*e}const s=2*n*this.m_tuning.stretchHertz;for(let t=0;t<this.m_stretchCount;++t){const e=this.m_stretchConstraints[t],i=e.invMass1+e.invMass2;if(0===i)continue;const n=1/i;e.spring=n*s*s,e.damper=2*n*this.m_tuning.stretchDamping*s}}Step(e,s,i){if(0===e)return;const n=1/e,o=Math.exp(-e*this.m_tuning.damping);for(let t=0;t<this.m_count;++t)this.m_invMasses[t]>0?(this.m_vs[t].x*=o,this.m_vs[t].y*=o,this.m_vs[t].x+=e*this.m_gravity.x,this.m_vs[t].y+=e*this.m_gravity.y):(this.m_vs[t].x=n*(this.m_bindPositions[t].x+i.x-this.m_p0s[t].x),this.m_vs[t].y=n*(this.m_bindPositions[t].y+i.y-this.m_p0s[t].y));this.m_tuning.bendingModel===t.b2BendingModel.b2_springAngleBendingModel&&this.ApplyBendForces(e);for(let t=0;t<this.m_bendCount;++t)this.m_bendConstraints[t].lambda=0;for(let t=0;t<this.m_stretchCount;++t)this.m_stretchConstraints[t].lambda=0;for(let t=0;t<this.m_count;++t)this.m_ps[t].x+=e*this.m_vs[t].x,this.m_ps[t].y+=e*this.m_vs[t].y;for(let i=0;i<s;++i)this.m_tuning.bendingModel===t.b2BendingModel.b2_pbdAngleBendingModel?this.SolveBend_PBD_Angle():this.m_tuning.bendingModel===t.b2BendingModel.b2_xpbdAngleBendingModel?this.SolveBend_XPBD_Angle(e):this.m_tuning.bendingModel===t.b2BendingModel.b2_pbdDistanceBendingModel?this.SolveBend_PBD_Distance():this.m_tuning.bendingModel===t.b2BendingModel.b2_pbdHeightBendingModel?this.SolveBend_PBD_Height():this.m_tuning.bendingModel===t.b2BendingModel.b2_pbdTriangleBendingModel&&this.SolveBend_PBD_Triangle(),this.m_tuning.stretchingModel===t.b2StretchingModel.b2_pbdStretchingModel?this.SolveStretch_PBD():this.m_tuning.stretchingModel===t.b2StretchingModel.b2_xpbdStretchingModel&&this.SolveStretch_XPBD(e);for(let t=0;t<this.m_count;++t)this.m_vs[t].x=n*(this.m_ps[t].x-this.m_p0s[t].x),this.m_vs[t].y=n*(this.m_ps[t].y-this.m_p0s[t].y),this.m_p0s[t].Copy(this.m_ps[t])}Reset(t){this.m_position.Copy(t);for(let t=0;t<this.m_count;++t)this.m_ps[t].x=this.m_bindPositions[t].x+this.m_position.x,this.m_ps[t].y=this.m_bindPositions[t].y+this.m_position.y,this.m_p0s[t].x=this.m_bindPositions[t].x+this.m_position.x,this.m_p0s[t].y=this.m_bindPositions[t].y+this.m_position.y,this.m_vs[t].SetZero();for(let t=0;t<this.m_bendCount;++t)this.m_bendConstraints[t].lambda=0;for(let t=0;t<this.m_stretchCount;++t)this.m_stretchConstraints[t].lambda=0}Draw(t){const s=new e(.4,.5,.7),i=new e(.1,.8,.1),n=new e(.7,.2,.4);for(let e=0;e<this.m_count-1;++e){t.DrawSegment(this.m_ps[e],this.m_ps[e+1],s);const o=this.m_invMasses[e]>0?n:i;t.DrawPoint(this.m_ps[e],5,o)}const o=this.m_invMasses[this.m_count-1]>0?n:i;t.DrawPoint(this.m_ps[this.m_count-1],5,o)}SolveStretch_PBD(){const t=this.m_tuning.stretchStiffness;for(let e=0;e<this.m_stretchCount;++e){const s=this.m_stretchConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=n.Clone().SelfSub(i),r=o.Normalize(),_=s.invMass1+s.invMass2;if(0===_)continue;const h=s.invMass1/_,m=s.invMass2/_;i.x-=t*h*(s.L-r)*o.x,i.y-=t*h*(s.L-r)*o.y,n.x+=t*m*(s.L-r)*o.x,n.y+=t*m*(s.L-r)*o.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n)}}SolveStretch_XPBD(t){for(let e=0;e<this.m_stretchCount;++e){const s=this.m_stretchConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=i.Clone().SelfSub(this.m_p0s[s.i1]),r=n.Clone().SelfSub(this.m_p0s[s.i2]),_=n.Clone().SelfSub(i),h=_.Normalize(),m=_.Clone().SelfNeg(),a=_,l=s.invMass1+s.invMass2;if(0===l)continue;const c=1/(s.spring*t*t),u=c*(t*t*s.damper)/t,d=h-s.L,p=b.DotVV(m,o)+b.DotVV(a,r),y=-(d+c*s.lambda+u*p)/((1+u)*l+c);i.x+=s.invMass1*y*m.x,i.y+=s.invMass1*y*m.y,n.x+=s.invMass2*y*a.x,n.y+=s.invMass2*y*a.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),s.lambda+=y}}SolveBend_PBD_Angle(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1],n=this.m_ps[s.i2],o=this.m_ps[s.i3],r=n.Clone().SelfSub(i),_=o.Clone().SelfSub(n),h=b.CrossVV(r,_),m=b.DotVV(r,_),a=y(h,m);let l=0,c=0;if(this.m_tuning.isometric?(l=s.L1*s.L1,c=s.L2*s.L2):(l=r.LengthSquared(),c=_.LengthSquared()),l*c==0)continue;const u=(new b).Copy(r).SelfSkew().SelfMul(-1/l),d=(new b).Copy(_).SelfSkew().SelfMul(1/c),p=u.Clone().SelfNeg(),x=u.Clone().SelfSub(d),A=d;let S=0;S=this.m_tuning.fixedEffectiveMass?s.invEffectiveMass:s.invMass1*b.DotVV(p,p)+s.invMass2*b.DotVV(x,x)+s.invMass3*b.DotVV(A,A),0===S&&(S=s.invEffectiveMass);const V=-t*a/S;i.x+=s.invMass1*V*p.x,i.y+=s.invMass1*V*p.y,n.x+=s.invMass2*V*x.x,n.y+=s.invMass2*V*x.y,o.x+=s.invMass3*V*A.x,o.y+=s.invMass3*V*A.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o)}}SolveBend_XPBD_Angle(t){for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1],n=this.m_ps[s.i2],o=this.m_ps[s.i3],r=i.Clone().SelfSub(this.m_p0s[s.i1]),_=n.Clone().SelfSub(this.m_p0s[s.i2]),h=o.Clone().SelfSub(this.m_p0s[s.i3]),m=n.Clone().SelfSub(i),a=o.Clone().SelfSub(n);let l,c;if(this.m_tuning.isometric?(l=s.L1*s.L1,c=s.L2*s.L2):(l=m.LengthSquared(),c=a.LengthSquared()),l*c==0)continue;const u=b.CrossVV(m,a),d=b.DotVV(m,a),p=y(u,d),x=(new b).Copy(m).SelfSkew().SelfMul(-1/l),A=(new b).Copy(a).SelfSkew().SelfMul(1/c),S=x.Clone().SelfNeg(),V=x.Clone().SelfSub(A),f=A;let C;if(C=this.m_tuning.fixedEffectiveMass?s.invEffectiveMass:s.invMass1*b.DotVV(S,S)+s.invMass2*b.DotVV(V,V)+s.invMass3*b.DotVV(f,f),0===C)continue;const w=1/(s.spring*t*t),B=w*(t*t*s.damper)/t,v=p,g=b.DotVV(S,r)+b.DotVV(V,_)+b.DotVV(f,h),M=-(v+w*s.lambda+B*g)/((1+B)*C+w);i.x+=s.invMass1*M*S.x,i.y+=s.invMass1*M*S.y,n.x+=s.invMass2*M*V.x,n.y+=s.invMass2*M*V.y,o.x+=s.invMass3*M*f.x,o.y+=s.invMass3*M*f.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o),s.lambda+=M}}SolveBend_PBD_Distance(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=s.i1,n=s.i3,o=this.m_ps[i].Clone(),r=this.m_ps[n].Clone(),_=r.Clone().SelfSub(o),h=_.Normalize(),m=s.invMass1+s.invMass3;if(0===m)continue;const a=s.invMass1/m,l=s.invMass3/m;o.x-=t*a*(s.L1+s.L2-h)*_.x,o.y-=t*a*(s.L1+s.L2-h)*_.y,r.x+=t*l*(s.L1+s.L2-h)*_.x,r.y+=t*l*(s.L1+s.L2-h)*_.y,this.m_ps[i].Copy(o),this.m_ps[n].Copy(r)}}SolveBend_PBD_Height(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=this.m_ps[s.i3].Clone(),r=new b;r.x=s.alpha1*i.x+s.alpha2*o.x-n.x,r.y=s.alpha1*i.y+s.alpha2*o.y-n.y;const _=r.Length();if(0===_)continue;const h=r.Clone().SelfMul(1/_),m=h.Clone().SelfMul(s.alpha1),a=h.Clone().SelfNeg(),l=h.Clone().SelfMul(s.alpha2),c=s.invMass1*s.alpha1*s.alpha1+s.invMass2+s.invMass3*s.alpha2*s.alpha2;if(0===c)continue;const u=-t*(1/c)*_;i.x+=s.invMass1*u*m.x,i.y+=s.invMass1*u*m.y,n.x+=s.invMass2*u*a.x,n.y+=s.invMass2*u*a.y,o.x+=s.invMass3*u*l.x,o.y+=s.invMass3*u*l.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o)}}SolveBend_PBD_Triangle(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=this.m_ps[s.i3].Clone(),r=s.invMass1,_=s.invMass2,h=s.invMass3,m=t/(r+h+2*_),a=new b;a.x=n.x-1/3*(i.x+n.x+o.x),a.y=n.y-1/3*(i.y+n.y+o.y);const l=new b;l.x=2*r*m*a.x,l.y=2*r*m*a.y;const c=new b;c.x=-4*_*m*a.x,c.y=-4*_*m*a.y;const u=new b;u.x=2*h*m*a.x,u.y=2*h*m*a.y,i.SelfAdd(l),n.SelfAdd(c),o.SelfAdd(u),this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o)}}ApplyBendForces(t){const e=2*n*this.m_tuning.bendHertz;for(let s=0;s<this.m_bendCount;++s){const i=this.m_bendConstraints[s],n=this.m_ps[i.i1].Clone(),o=this.m_ps[i.i2].Clone(),r=this.m_ps[i.i3].Clone(),_=this.m_vs[i.i1],h=this.m_vs[i.i2],m=this.m_vs[i.i3],a=n.Clone().SelfSub(n),l=r.Clone().SelfSub(o);let c,u;if(this.m_tuning.isometric?(c=i.L1*i.L1,u=i.L2*i.L2):(c=a.LengthSquared(),u=l.LengthSquared()),c*u==0)continue;const d=b.CrossVV(a,l),p=b.DotVV(a,l),x=y(d,p),A=(new b).Copy(a).SelfSkew().SelfMul(-1/c),S=(new b).Copy(l).SelfSkew().SelfMul(1/u),V=A.Clone().SelfNeg(),f=A.Clone().SelfSub(S),C=S;let w=0;if(w=this.m_tuning.fixedEffectiveMass?i.invEffectiveMass:i.invMass1*b.DotVV(V,V)+i.invMass2*b.DotVV(f,f)+i.invMass3*b.DotVV(C,C),0===w)continue;const B=1/w,v=-t*(B*e*e*x+2*B*this.m_tuning.bendDamping*e*(b.DotVV(V,_)+b.DotVV(f,h)+b.DotVV(C,m)));this.m_vs[i.i1].x+=i.invMass1*v*V.x,this.m_vs[i.i1].y+=i.invMass1*v*V.y,this.m_vs[i.i2].x+=i.invMass2*v*f.x,this.m_vs[i.i2].y+=i.invMass2*v*f.y,this.m_vs[i.i3].x+=i.invMass3*v*C.x,this.m_vs[i.i3].y+=i.invMass3*v*C.y}}},t.b2RopeDef=class{constructor(){this.position=new b,this.vertices=[],this.count=0,this.masses=[],this.gravity=new b,this.tuning=new Fs}},t.b2RopeTuning=Fs,t.b2Rot=f,t.b2SeparationFunction=ve,t.b2Shape=M,t.b2ShapeCast=function(t,e){t.iterations=0,t.lambda=1,t.normal.SetZero(),t.point.SetZero();const s=e.proxyA,i=e.proxyB,n=b2Max(s.m_radius,.01)+b2Max(i.m_radius,.01),o=e.transformA,r=e.transformB,_=e.translationB,h=N.Set(0,0);let m=0;const a=X;a.m_count=0;const l=a.m_vertices;let c=s.GetSupport(f.MulTRV(o.q,b.NegV(_,b.s_t1),b.s_t0)),u=C.MulXV(o,s.GetVertex(c),E),d=i.GetSupport(f.MulTRV(r.q,_,b.s_t0)),p=C.MulXV(r,i.GetVertex(d),Z);const y=b.SubVV(u,p,W),x=b2Max(.01,n-.01);let A=0;for(;A<20&&y.Length()-x>.0025;){t.iterations+=1,c=s.GetSupport(f.MulTRV(o.q,b.NegV(y,b.s_t1),b.s_t0)),u=C.MulXV(o,s.GetVertex(c),E),d=i.GetSupport(f.MulTRV(r.q,y,b.s_t0)),p=C.MulXV(r,i.GetVertex(d),Z);const e=b.SubVV(u,p,Q);y.Normalize();const n=b.DotVV(y,e),S=b.DotVV(y,_);if(n-x>m*S){if(S<=0)return!1;if(m=(n-x)/S,m>1)return!1;h.Copy(y).SelfNeg(),a.m_count=0}const V=l[a.m_count];switch(V.indexA=d,V.wA.Copy(p).SelfMulAdd(m,_),V.indexB=c,V.wB.Copy(u),V.w.Copy(V.wB).SelfSub(V.wA),V.a=1,a.m_count+=1,a.m_count){case 1:break;case 2:a.Solve2();break;case 3:a.Solve3()}if(3===a.m_count)return!1;a.GetClosestPoint(y),++A}if(0===A)return!1;const S=Y,V=K;return a.GetWitnessPoints(S,V),y.LengthSquared()>0&&(h.Copy(y).SelfNeg(),h.Normalize()),t.normal.Copy(h),t.lambda=m,t.iterations=A,!0},t.b2ShapeCastInput=class{constructor(){this.proxyA=new I,this.proxyB=new I,this.transformA=new C,this.transformB=new C,this.translationB=new b}},t.b2ShapeCastOutput=class{constructor(){this.point=new b,this.normal=new b,this.lambda=0,this.iterations=0}},t.b2Simplex=L,t.b2SimplexCache=D,t.b2SimplexVertex=P,t.b2Sin=u,t.b2SolverData=ys,t.b2Sq=b2Sq,t.b2Sqrt=a,t.b2StackAllocator=class{},t.b2Swap=function(t,e){const s=t[0];t[0]=e[0],e[0]=s},t.b2Sweep=w,t.b2TOIInput=fe,t.b2TOIOutput=Be,t.b2TestOverlapAABB=b2TestOverlapAABB,t.b2TestOverlapShape=b2TestOverlapShape,t.b2TimeOfImpact=b2TimeOfImpact,t.b2TimeStep=us,t.b2Timer=B,t.b2Transform=C,t.b2TreeNode=ct,t.b2Vec2=b,t.b2Vec2_zero=x,t.b2Vec3=A,t.b2Velocity=ps,t.b2VelocityConstraintPoint=bs,t.b2Version=o,t.b2WeldJoint=Ts,t.b2WeldJointDef=class extends Je{constructor(){super(t.b2JointType.e_weldJoint),this.localAnchorA=new b,this.localAnchorB=new b,this.referenceAngle=0,this.stiffness=0,this.damping=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}},t.b2WheelJoint=Gs,t.b2WheelJointDef=class extends Je{constructor(){super(t.b2JointType.e_wheelJoint),this.localAnchorA=new b(0,0),this.localAnchorB=new b(0,0),this.localAxisA=new b(1,0),this.enableLimit=!1,this.lowerTranslation=0,this.upperTranslation=0,this.enableMotor=!1,this.maxMotorTorque=0,this.motorSpeed=0,this.stiffness=0,this.damping=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.bodyA.GetLocalVector(i,this.localAxisA)}},t.b2World=Ps,t.b2WorldManifold=nt,t.b2_180_over_pi=57.29577951307855,t.b2_aabbExtension=.1,t.b2_aabbMultiplier=4,t.b2_angularSleepTolerance=.03490658503988889,t.b2_angularSlop=.03490658503988889,t.b2_baumgarte=.2,t.b2_branch="master",t.b2_commit="9ebbbcd960ad424e03e5de6e66a40764c16f51bc",t.b2_epsilon=1e-5,t.b2_epsilon_sq=1e-5*1e-5,t.b2_gjk_reset=function(){t.b2_gjkCalls=0,t.b2_gjkIters=0,t.b2_gjkMaxIters=0},t.b2_lengthUnitsPerMeter=1,t.b2_linearSleepTolerance=.01,t.b2_linearSlop=.005,t.b2_maxAngularCorrection=.13962634015955555,t.b2_maxFloat=i,t.b2_maxLinearCorrection=.2,t.b2_maxManifoldPoints=2,t.b2_maxPolygonVertices=8,t.b2_maxRotation=1.570796326795,t.b2_maxRotationSquared=2.4674011002726646,t.b2_maxSubSteps=8,t.b2_maxTOIContacts=32,t.b2_maxTranslation=2,t.b2_maxTranslationSquared=4,t.b2_minPulleyLength=2,t.b2_pi=n,t.b2_pi_over_180=.017453292519944444,t.b2_polygonRadius=.01,t.b2_timeToSleep=.5,t.b2_toiBaumgarte=.75,t.b2_toi_reset=function(){t.b2_toiTime=0,t.b2_toiMaxTime=0,t.b2_toiCalls=0,t.b2_toiIters=0,t.b2_toiMaxIters=0,t.b2_toiRootIters=0,t.b2_toiMaxRootIters=0},t.b2_two_pi=6.28318530718,t.b2_version=r,t.dynamicBody=js,t.get_g_blockSolve=function(){return t.g_blockSolve},t.kinematicBody=zs,t.pbdAngleBendingModel=Ns,t.pbdDistanceBendingModel=Es,t.pbdHeightBendingModel=Zs,t.pbdStretchingModel=Qs,t.pbdTriangleBendingModel=Ws,t.set_g_blockSolve=function(e){t.g_blockSolve=e},t.springAngleBendingModel=Os,t.staticBody=Js,t.xpbdAngleBendingModel=Xs,t.xpbdStretchingModel=Ys,Object.defineProperty(t,"__esModule",{value:!0}),t}({});